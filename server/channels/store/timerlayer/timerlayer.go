// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make store-layers"
// DO NOT EDIT

package timerlayer

import (
	"context"
	"time"

	"github.com/mattermost/mattermost/server/public/model"
	"github.com/mattermost/mattermost/server/public/shared/request"
	"github.com/mattermost/mattermost/server/v8/channels/store"
	"github.com/mattermost/mattermost/server/v8/einterfaces"
)

type TimerLayer struct {
	store.Store
	Metrics                         einterfaces.MetricsInterface
	AccessControlPolicyStore        store.AccessControlPolicyStore
	AttributesStore                 store.AttributesStore
	AuditStore                      store.AuditStore
	BotStore                        store.BotStore
	ChannelStore                    store.ChannelStore
	ChannelBookmarkStore            store.ChannelBookmarkStore
	ChannelMemberHistoryStore       store.ChannelMemberHistoryStore
	ClusterDiscoveryStore           store.ClusterDiscoveryStore
	CommandStore                    store.CommandStore
	CommandWebhookStore             store.CommandWebhookStore
	ComplianceStore                 store.ComplianceStore
	DesktopTokensStore              store.DesktopTokensStore
	DraftStore                      store.DraftStore
	EmojiStore                      store.EmojiStore
	FileInfoStore                   store.FileInfoStore
	GroupStore                      store.GroupStore
	JobStore                        store.JobStore
	LicenseStore                    store.LicenseStore
	LinkMetadataStore               store.LinkMetadataStore
	NotifyAdminStore                store.NotifyAdminStore
	OAuthStore                      store.OAuthStore
	OutgoingOAuthConnectionStore    store.OutgoingOAuthConnectionStore
	PluginStore                     store.PluginStore
	PostStore                       store.PostStore
	PostAcknowledgementStore        store.PostAcknowledgementStore
	PostPersistentNotificationStore store.PostPersistentNotificationStore
	PostPriorityStore               store.PostPriorityStore
	PreferenceStore                 store.PreferenceStore
	ProductNoticesStore             store.ProductNoticesStore
	PropertyFieldStore              store.PropertyFieldStore
	PropertyGroupStore              store.PropertyGroupStore
	PropertyValueStore              store.PropertyValueStore
	ReactionStore                   store.ReactionStore
	RemoteClusterStore              store.RemoteClusterStore
	RetentionPolicyStore            store.RetentionPolicyStore
	RoleStore                       store.RoleStore
	ScheduledPostStore              store.ScheduledPostStore
	SchemeStore                     store.SchemeStore
	SessionStore                    store.SessionStore
	SharedChannelStore              store.SharedChannelStore
	StatusStore                     store.StatusStore
	SystemStore                     store.SystemStore
	TeamStore                       store.TeamStore
	TermsOfServiceStore             store.TermsOfServiceStore
	ThreadStore                     store.ThreadStore
	TokenStore                      store.TokenStore
	UploadSessionStore              store.UploadSessionStore
	UserStore                       store.UserStore
	UserAccessTokenStore            store.UserAccessTokenStore
	UserTermsOfServiceStore         store.UserTermsOfServiceStore
	WebhookStore                    store.WebhookStore
}

func (s *TimerLayer) AccessControlPolicy() store.AccessControlPolicyStore {
	return s.AccessControlPolicyStore
}

func (s *TimerLayer) Attributes() store.AttributesStore {
	return s.AttributesStore
}

func (s *TimerLayer) Audit() store.AuditStore {
	return s.AuditStore
}

func (s *TimerLayer) Bot() store.BotStore {
	return s.BotStore
}

func (s *TimerLayer) Channel() store.ChannelStore {
	return s.ChannelStore
}

func (s *TimerLayer) ChannelBookmark() store.ChannelBookmarkStore {
	return s.ChannelBookmarkStore
}

func (s *TimerLayer) ChannelMemberHistory() store.ChannelMemberHistoryStore {
	return s.ChannelMemberHistoryStore
}

func (s *TimerLayer) ClusterDiscovery() store.ClusterDiscoveryStore {
	return s.ClusterDiscoveryStore
}

func (s *TimerLayer) Command() store.CommandStore {
	return s.CommandStore
}

func (s *TimerLayer) CommandWebhook() store.CommandWebhookStore {
	return s.CommandWebhookStore
}

func (s *TimerLayer) Compliance() store.ComplianceStore {
	return s.ComplianceStore
}

func (s *TimerLayer) DesktopTokens() store.DesktopTokensStore {
	return s.DesktopTokensStore
}

func (s *TimerLayer) Draft() store.DraftStore {
	return s.DraftStore
}

func (s *TimerLayer) Emoji() store.EmojiStore {
	return s.EmojiStore
}

func (s *TimerLayer) FileInfo() store.FileInfoStore {
	return s.FileInfoStore
}

func (s *TimerLayer) Group() store.GroupStore {
	return s.GroupStore
}

func (s *TimerLayer) Job() store.JobStore {
	return s.JobStore
}

func (s *TimerLayer) License() store.LicenseStore {
	return s.LicenseStore
}

func (s *TimerLayer) LinkMetadata() store.LinkMetadataStore {
	return s.LinkMetadataStore
}

func (s *TimerLayer) NotifyAdmin() store.NotifyAdminStore {
	return s.NotifyAdminStore
}

func (s *TimerLayer) OAuth() store.OAuthStore {
	return s.OAuthStore
}

func (s *TimerLayer) OutgoingOAuthConnection() store.OutgoingOAuthConnectionStore {
	return s.OutgoingOAuthConnectionStore
}

func (s *TimerLayer) Plugin() store.PluginStore {
	return s.PluginStore
}

func (s *TimerLayer) Post() store.PostStore {
	return s.PostStore
}

func (s *TimerLayer) PostAcknowledgement() store.PostAcknowledgementStore {
	return s.PostAcknowledgementStore
}

func (s *TimerLayer) PostPersistentNotification() store.PostPersistentNotificationStore {
	return s.PostPersistentNotificationStore
}

func (s *TimerLayer) PostPriority() store.PostPriorityStore {
	return s.PostPriorityStore
}

func (s *TimerLayer) Preference() store.PreferenceStore {
	return s.PreferenceStore
}

func (s *TimerLayer) ProductNotices() store.ProductNoticesStore {
	return s.ProductNoticesStore
}

func (s *TimerLayer) PropertyField() store.PropertyFieldStore {
	return s.PropertyFieldStore
}

func (s *TimerLayer) PropertyGroup() store.PropertyGroupStore {
	return s.PropertyGroupStore
}

func (s *TimerLayer) PropertyValue() store.PropertyValueStore {
	return s.PropertyValueStore
}

func (s *TimerLayer) Reaction() store.ReactionStore {
	return s.ReactionStore
}

func (s *TimerLayer) RemoteCluster() store.RemoteClusterStore {
	return s.RemoteClusterStore
}

func (s *TimerLayer) RetentionPolicy() store.RetentionPolicyStore {
	return s.RetentionPolicyStore
}

func (s *TimerLayer) Role() store.RoleStore {
	return s.RoleStore
}

func (s *TimerLayer) ScheduledPost() store.ScheduledPostStore {
	return s.ScheduledPostStore
}

func (s *TimerLayer) Scheme() store.SchemeStore {
	return s.SchemeStore
}

func (s *TimerLayer) Session() store.SessionStore {
	return s.SessionStore
}

func (s *TimerLayer) SharedChannel() store.SharedChannelStore {
	return s.SharedChannelStore
}

func (s *TimerLayer) Status() store.StatusStore {
	return s.StatusStore
}

func (s *TimerLayer) System() store.SystemStore {
	return s.SystemStore
}

func (s *TimerLayer) Team() store.TeamStore {
	return s.TeamStore
}

func (s *TimerLayer) TermsOfService() store.TermsOfServiceStore {
	return s.TermsOfServiceStore
}

func (s *TimerLayer) Thread() store.ThreadStore {
	return s.ThreadStore
}

func (s *TimerLayer) Token() store.TokenStore {
	return s.TokenStore
}

func (s *TimerLayer) UploadSession() store.UploadSessionStore {
	return s.UploadSessionStore
}

func (s *TimerLayer) User() store.UserStore {
	return s.UserStore
}

func (s *TimerLayer) UserAccessToken() store.UserAccessTokenStore {
	return s.UserAccessTokenStore
}

func (s *TimerLayer) UserTermsOfService() store.UserTermsOfServiceStore {
	return s.UserTermsOfServiceStore
}

func (s *TimerLayer) Webhook() store.WebhookStore {
	return s.WebhookStore
}

type TimerLayerAccessControlPolicyStore struct {
	store.AccessControlPolicyStore
	Root *TimerLayer
}

type TimerLayerAttributesStore struct {
	store.AttributesStore
	Root *TimerLayer
}

type TimerLayerAuditStore struct {
	store.AuditStore
	Root *TimerLayer
}

type TimerLayerBotStore struct {
	store.BotStore
	Root *TimerLayer
}

type TimerLayerChannelStore struct {
	store.ChannelStore
	Root *TimerLayer
}

type TimerLayerChannelBookmarkStore struct {
	store.ChannelBookmarkStore
	Root *TimerLayer
}

type TimerLayerChannelMemberHistoryStore struct {
	store.ChannelMemberHistoryStore
	Root *TimerLayer
}

type TimerLayerClusterDiscoveryStore struct {
	store.ClusterDiscoveryStore
	Root *TimerLayer
}

type TimerLayerCommandStore struct {
	store.CommandStore
	Root *TimerLayer
}

type TimerLayerCommandWebhookStore struct {
	store.CommandWebhookStore
	Root *TimerLayer
}

type TimerLayerComplianceStore struct {
	store.ComplianceStore
	Root *TimerLayer
}

type TimerLayerDesktopTokensStore struct {
	store.DesktopTokensStore
	Root *TimerLayer
}

type TimerLayerDraftStore struct {
	store.DraftStore
	Root *TimerLayer
}

type TimerLayerEmojiStore struct {
	store.EmojiStore
	Root *TimerLayer
}

type TimerLayerFileInfoStore struct {
	store.FileInfoStore
	Root *TimerLayer
}

type TimerLayerGroupStore struct {
	store.GroupStore
	Root *TimerLayer
}

type TimerLayerJobStore struct {
	store.JobStore
	Root *TimerLayer
}

type TimerLayerLicenseStore struct {
	store.LicenseStore
	Root *TimerLayer
}

type TimerLayerLinkMetadataStore struct {
	store.LinkMetadataStore
	Root *TimerLayer
}

type TimerLayerNotifyAdminStore struct {
	store.NotifyAdminStore
	Root *TimerLayer
}

type TimerLayerOAuthStore struct {
	store.OAuthStore
	Root *TimerLayer
}

type TimerLayerOutgoingOAuthConnectionStore struct {
	store.OutgoingOAuthConnectionStore
	Root *TimerLayer
}

type TimerLayerPluginStore struct {
	store.PluginStore
	Root *TimerLayer
}

type TimerLayerPostStore struct {
	store.PostStore
	Root *TimerLayer
}

type TimerLayerPostAcknowledgementStore struct {
	store.PostAcknowledgementStore
	Root *TimerLayer
}

type TimerLayerPostPersistentNotificationStore struct {
	store.PostPersistentNotificationStore
	Root *TimerLayer
}

type TimerLayerPostPriorityStore struct {
	store.PostPriorityStore
	Root *TimerLayer
}

type TimerLayerPreferenceStore struct {
	store.PreferenceStore
	Root *TimerLayer
}

type TimerLayerProductNoticesStore struct {
	store.ProductNoticesStore
	Root *TimerLayer
}

type TimerLayerPropertyFieldStore struct {
	store.PropertyFieldStore
	Root *TimerLayer
}

type TimerLayerPropertyGroupStore struct {
	store.PropertyGroupStore
	Root *TimerLayer
}

type TimerLayerPropertyValueStore struct {
	store.PropertyValueStore
	Root *TimerLayer
}

type TimerLayerReactionStore struct {
	store.ReactionStore
	Root *TimerLayer
}

type TimerLayerRemoteClusterStore struct {
	store.RemoteClusterStore
	Root *TimerLayer
}

type TimerLayerRetentionPolicyStore struct {
	store.RetentionPolicyStore
	Root *TimerLayer
}

type TimerLayerRoleStore struct {
	store.RoleStore
	Root *TimerLayer
}

type TimerLayerScheduledPostStore struct {
	store.ScheduledPostStore
	Root *TimerLayer
}

type TimerLayerSchemeStore struct {
	store.SchemeStore
	Root *TimerLayer
}

type TimerLayerSessionStore struct {
	store.SessionStore
	Root *TimerLayer
}

type TimerLayerSharedChannelStore struct {
	store.SharedChannelStore
	Root *TimerLayer
}

type TimerLayerStatusStore struct {
	store.StatusStore
	Root *TimerLayer
}

type TimerLayerSystemStore struct {
	store.SystemStore
	Root *TimerLayer
}

type TimerLayerTeamStore struct {
	store.TeamStore
	Root *TimerLayer
}

type TimerLayerTermsOfServiceStore struct {
	store.TermsOfServiceStore
	Root *TimerLayer
}

type TimerLayerThreadStore struct {
	store.ThreadStore
	Root *TimerLayer
}

type TimerLayerTokenStore struct {
	store.TokenStore
	Root *TimerLayer
}

type TimerLayerUploadSessionStore struct {
	store.UploadSessionStore
	Root *TimerLayer
}

type TimerLayerUserStore struct {
	store.UserStore
	Root *TimerLayer
}

type TimerLayerUserAccessTokenStore struct {
	store.UserAccessTokenStore
	Root *TimerLayer
}

type TimerLayerUserTermsOfServiceStore struct {
	store.UserTermsOfServiceStore
	Root *TimerLayer
}

type TimerLayerWebhookStore struct {
	store.WebhookStore
	Root *TimerLayer
}

func (s *TimerLayerAccessControlPolicyStore) Delete(c request.CTX, id string) error {
	start := time.Now()

	err := s.AccessControlPolicyStore.Delete(c, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AccessControlPolicyStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerAccessControlPolicyStore) Get(c request.CTX, id string) (*model.AccessControlPolicy, error) {
	start := time.Now()

	result, err := s.AccessControlPolicyStore.Get(c, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AccessControlPolicyStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAccessControlPolicyStore) Save(c request.CTX, policy *model.AccessControlPolicy) (*model.AccessControlPolicy, error) {
	start := time.Now()

	result, err := s.AccessControlPolicyStore.Save(c, policy)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AccessControlPolicyStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAccessControlPolicyStore) SearchPolicies(rctx request.CTX, opts model.AccessControlPolicySearch) ([]*model.AccessControlPolicy, int64, error) {
	start := time.Now()

	result, resultVar1, err := s.AccessControlPolicyStore.SearchPolicies(rctx, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AccessControlPolicyStore.SearchPolicies", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerAccessControlPolicyStore) SetActiveStatus(c request.CTX, id string, active bool) (*model.AccessControlPolicy, error) {
	start := time.Now()

	result, err := s.AccessControlPolicyStore.SetActiveStatus(c, id, active)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AccessControlPolicyStore.SetActiveStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributesStore) GetChannelMembersToRemove(rctx request.CTX, channelID string, opts model.SubjectSearchOptions) ([]*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.AttributesStore.GetChannelMembersToRemove(rctx, channelID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributesStore.GetChannelMembersToRemove", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributesStore) GetSubject(rctx request.CTX, ID string, groupID string) (*model.Subject, error) {
	start := time.Now()

	result, err := s.AttributesStore.GetSubject(rctx, ID, groupID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributesStore.GetSubject", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributesStore) RefreshAttributes() error {
	start := time.Now()

	err := s.AttributesStore.RefreshAttributes()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributesStore.RefreshAttributes", success, elapsed)
	}
	return err
}

func (s *TimerLayerAttributesStore) SearchUsers(rctx request.CTX, opts model.SubjectSearchOptions) ([]*model.User, int64, error) {
	start := time.Now()

	result, resultVar1, err := s.AttributesStore.SearchUsers(rctx, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributesStore.SearchUsers", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerAuditStore) Get(userID string, offset int, limit int) (model.Audits, error) {
	start := time.Now()

	result, err := s.AuditStore.Get(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAuditStore) PermanentDeleteByUser(userID string) error {
	start := time.Now()

	err := s.AuditStore.PermanentDeleteByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerAuditStore) Save(audit *model.Audit) error {
	start := time.Now()

	err := s.AuditStore.Save(audit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerBotStore) Get(userID string, includeDeleted bool) (*model.Bot, error) {
	start := time.Now()

	result, err := s.BotStore.Get(userID, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BotStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerBotStore) GetAll(options *model.BotGetOptions) ([]*model.Bot, error) {
	start := time.Now()

	result, err := s.BotStore.GetAll(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BotStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerBotStore) GetAllAfter(limit int, afterId string) ([]*model.Bot, error) {
	start := time.Now()

	result, err := s.BotStore.GetAllAfter(limit, afterId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BotStore.GetAllAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerBotStore) GetByUsername(username string) (*model.Bot, error) {
	start := time.Now()

	result, err := s.BotStore.GetByUsername(username)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BotStore.GetByUsername", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerBotStore) PermanentDelete(userID string) error {
	start := time.Now()

	err := s.BotStore.PermanentDelete(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BotStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerBotStore) Save(bot *model.Bot) (*model.Bot, error) {
	start := time.Now()

	result, err := s.BotStore.Save(bot)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BotStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerBotStore) Update(bot *model.Bot) (*model.Bot, error) {
	start := time.Now()

	result, err := s.BotStore.Update(bot)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("BotStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) AnalyticsCountAll(teamID string) (map[model.ChannelType]int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.AnalyticsCountAll(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.AnalyticsCountAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) AnalyticsDeletedTypeCount(teamID string, channelType model.ChannelType) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.AnalyticsDeletedTypeCount(teamID, channelType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.AnalyticsDeletedTypeCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) AnalyticsTypeCount(teamID string, channelType model.ChannelType) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.AnalyticsTypeCount(teamID, channelType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.AnalyticsTypeCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) Autocomplete(rctx request.CTX, userID string, term string, includeDeleted bool, isGuest bool) (model.ChannelListWithTeamData, error) {
	start := time.Now()

	result, err := s.ChannelStore.Autocomplete(rctx, userID, term, includeDeleted, isGuest)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Autocomplete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) AutocompleteInTeam(rctx request.CTX, teamID string, userID string, term string, includeDeleted bool, isGuest bool) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.AutocompleteInTeam(rctx, teamID, userID, term, includeDeleted, isGuest)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.AutocompleteInTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) AutocompleteInTeamForSearch(teamID string, userID string, term string, includeDeleted bool) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.AutocompleteInTeamForSearch(teamID, userID, term, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.AutocompleteInTeamForSearch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) ClearAllCustomRoleAssignments() error {
	start := time.Now()

	err := s.ChannelStore.ClearAllCustomRoleAssignments()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.ClearAllCustomRoleAssignments", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) ClearCaches() {
	start := time.Now()

	s.ChannelStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerChannelStore) ClearMembersForUserCache() {
	start := time.Now()

	s.ChannelStore.ClearMembersForUserCache()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.ClearMembersForUserCache", success, elapsed)
	}
}

func (s *TimerLayerChannelStore) ClearSidebarOnTeamLeave(userID string, teamID string) error {
	start := time.Now()

	err := s.ChannelStore.ClearSidebarOnTeamLeave(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.ClearSidebarOnTeamLeave", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) CountPostsAfter(channelID string, timestamp int64, excludedUserID string) (int, int, error) {
	start := time.Now()

	result, resultVar1, err := s.ChannelStore.CountPostsAfter(channelID, timestamp, excludedUserID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.CountPostsAfter", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerChannelStore) CountUrgentPostsAfter(channelID string, timestamp int64, excludedUserID string) (int, error) {
	start := time.Now()

	result, err := s.ChannelStore.CountUrgentPostsAfter(channelID, timestamp, excludedUserID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.CountUrgentPostsAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) CreateDirectChannel(ctx request.CTX, userID *model.User, otherUserID *model.User, channelOptions ...model.ChannelOption) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.CreateDirectChannel(ctx, userID, otherUserID, channelOptions...)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.CreateDirectChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) CreateInitialSidebarCategories(c request.CTX, userID string, opts *store.SidebarCategorySearchOpts) (*model.OrderedSidebarCategories, error) {
	start := time.Now()

	result, err := s.ChannelStore.CreateInitialSidebarCategories(c, userID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.CreateInitialSidebarCategories", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) CreateSidebarCategory(userID string, teamID string, newCategory *model.SidebarCategoryWithChannels) (*model.SidebarCategoryWithChannels, error) {
	start := time.Now()

	result, err := s.ChannelStore.CreateSidebarCategory(userID, teamID, newCategory)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.CreateSidebarCategory", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) Delete(channelID string, timestamp int64) error {
	start := time.Now()

	err := s.ChannelStore.Delete(channelID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) DeleteAllSidebarChannelForChannel(channelID string) error {
	start := time.Now()

	err := s.ChannelStore.DeleteAllSidebarChannelForChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.DeleteAllSidebarChannelForChannel", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) DeleteSidebarCategory(categoryID string) error {
	start := time.Now()

	err := s.ChannelStore.DeleteSidebarCategory(categoryID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.DeleteSidebarCategory", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) DeleteSidebarChannelsByPreferences(preferences model.Preferences) error {
	start := time.Now()

	err := s.ChannelStore.DeleteSidebarChannelsByPreferences(preferences)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.DeleteSidebarChannelsByPreferences", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) Get(id string, allowFromCache bool) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.Get(id, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetAll(teamID string) ([]*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAll(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetAllChannelMemberIdsByChannelId(id string) ([]string, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannelMemberIdsByChannelId(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetAllChannelMemberIdsByChannelId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetAllChannelMembersForUser(ctx request.CTX, userID string, allowFromCache bool, includeDeleted bool) (map[string]string, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannelMembersForUser(ctx, userID, allowFromCache, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetAllChannelMembersForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetAllChannelMembersNotifyPropsForChannel(channelID string, allowFromCache bool) (map[string]model.StringMap, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannelMembersNotifyPropsForChannel(channelID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetAllChannelMembersNotifyPropsForChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetAllChannels(page int, perPage int, opts store.ChannelSearchOpts) (model.ChannelListWithTeamData, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannels(page, perPage, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetAllChannels", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetAllChannelsCount(opts store.ChannelSearchOpts) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannelsCount(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetAllChannelsCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetAllChannelsForExportAfter(limit int, afterID string) ([]*model.ChannelForExport, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannelsForExportAfter(limit, afterID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetAllChannelsForExportAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetAllDirectChannelsForExportAfter(limit int, afterID string, includeArchivedChannels bool) ([]*model.DirectChannelForExport, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllDirectChannelsForExportAfter(limit, afterID, includeArchivedChannels)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetAllDirectChannelsForExportAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetByName(teamID string, name string, allowFromCache bool) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetByName(teamID, name, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetByNameIncludeDeleted(teamID string, name string, allowFromCache bool) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetByNameIncludeDeleted(teamID, name, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetByNameIncludeDeleted", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetByNames(teamID string, names []string, allowFromCache bool) ([]*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetByNames(teamID, names, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetByNames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetByNamesIncludeDeleted(teamID string, names []string, allowFromCache bool) ([]*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetByNamesIncludeDeleted(teamID, names, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetByNamesIncludeDeleted", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelCounts(teamID string, userID string) (*model.ChannelCounts, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelCounts(teamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelCounts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelMembersForExport(userID string, teamID string, includeArchivedChannel bool) ([]*model.ChannelMemberForExport, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelMembersForExport(userID, teamID, includeArchivedChannel)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelMembersForExport", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelMembersTimezones(channelID string) ([]model.StringMap, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelMembersTimezones(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelMembersTimezones", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelUnread(channelID string, userID string) (*model.ChannelUnread, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelUnread(channelID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelUnread", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannels(teamID string, userID string, opts *model.ChannelSearchOpts) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannels(teamID, userID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannels", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelsBatchForIndexing(startTime int64, startChannelID string, limit int) ([]*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsBatchForIndexing(startTime, startChannelID, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelsBatchForIndexing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelsByIds(channelIds []string, includeDeleted bool) ([]*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsByIds(channelIds, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelsByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelsByScheme(schemeID string, offset int, limit int) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsByScheme(schemeID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelsByScheme", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelsByUser(userID string, includeDeleted bool, lastDeleteAt int, pageSize int, fromChannelID string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsByUser(userID, includeDeleted, lastDeleteAt, pageSize, fromChannelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelsByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelsMemberCount(channelIDs []string) (map[string]int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsMemberCount(channelIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelsMemberCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelsWithTeamDataByIds(channelIds []string, includeDeleted bool) ([]*model.ChannelWithTeamData, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsWithTeamDataByIds(channelIds, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelsWithTeamDataByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelsWithUnreadsAndWithMentions(ctx context.Context, channelIDs []string, userID string, userNotifyProps model.StringMap) ([]string, []string, map[string]int64, error) {
	start := time.Now()

	result, resultVar1, resultVar2, err := s.ChannelStore.GetChannelsWithUnreadsAndWithMentions(ctx, channelIDs, userID, userNotifyProps)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelsWithUnreadsAndWithMentions", success, elapsed)
	}
	return result, resultVar1, resultVar2, err
}

func (s *TimerLayerChannelStore) GetDeleted(teamID string, offset int, limit int, userID string, skipTeamMembershipCheck bool) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetDeleted(teamID, offset, limit, userID, skipTeamMembershipCheck)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetDeleted", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetDeletedByName(teamID string, name string) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetDeletedByName(teamID, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetDeletedByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetFileCount(channelID string) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetFileCount(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetFileCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetForPost(postID string) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetForPost(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetForPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetGuestCount(channelID string, allowFromCache bool) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetGuestCount(channelID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetGuestCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMany(ids []string, allowFromCache bool) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMany(ids, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMany", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMember(ctx context.Context, channelID string, userID string) (*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMember(ctx, channelID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMemberCount(channelID string, allowFromCache bool) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMemberCount(channelID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMemberCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMemberCountFromCache(channelID string) int64 {
	start := time.Now()

	result := s.ChannelStore.GetMemberCountFromCache(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMemberCountFromCache", success, elapsed)
	}
	return result
}

func (s *TimerLayerChannelStore) GetMemberCountsByGroup(ctx context.Context, channelID string, includeTimezones bool) ([]*model.ChannelMemberCountByGroup, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMemberCountsByGroup(ctx, channelID, includeTimezones)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMemberCountsByGroup", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMemberForPost(postID string, userID string, includeArchivedChannels bool) (*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMemberForPost(postID, userID, includeArchivedChannels)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMemberForPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMemberLastViewedAt(ctx context.Context, channelID string, userID string) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMemberLastViewedAt(ctx, channelID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMemberLastViewedAt", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMembers(channelID string, offset int, limit int) (model.ChannelMembers, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembers(channelID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMembersByChannelIds(channelIds []string, userID string) (model.ChannelMembers, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersByChannelIds(channelIds, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMembersByChannelIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMembersByIds(channelID string, userIds []string) (model.ChannelMembers, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersByIds(channelID, userIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMembersByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMembersForUser(teamID string, userID string) (model.ChannelMembers, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersForUser(teamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMembersForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMembersForUserWithCursorPagination(userId string, perPage int, fromChanneID string) (model.ChannelMembersWithTeamData, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersForUserWithCursorPagination(userId, perPage, fromChanneID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMembersForUserWithCursorPagination", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMembersForUserWithPagination(userID string, page int, perPage int) (model.ChannelMembersWithTeamData, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersForUserWithPagination(userID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMembersForUserWithPagination", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMembersInfoByChannelIds(channelIDs []string) (map[string][]*model.User, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersInfoByChannelIds(channelIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMembersInfoByChannelIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetMoreChannels(teamID string, userID string, offset int, limit int) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMoreChannels(teamID, userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetMoreChannels", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetPinnedPostCount(channelID string, allowFromCache bool) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetPinnedPostCount(channelID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetPinnedPostCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetPinnedPosts(channelID string) (*model.PostList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetPinnedPosts(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetPinnedPosts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetPrivateChannelsForTeam(teamID string, offset int, limit int) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetPrivateChannelsForTeam(teamID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetPrivateChannelsForTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetPublicChannelsByIdsForTeam(teamID string, channelIds []string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetPublicChannelsByIdsForTeam(teamID, channelIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetPublicChannelsByIdsForTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetPublicChannelsForTeam(teamID string, offset int, limit int) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetPublicChannelsForTeam(teamID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetPublicChannelsForTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetSidebarCategories(userID string, opts *store.SidebarCategorySearchOpts) (*model.OrderedSidebarCategories, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetSidebarCategories(userID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetSidebarCategories", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetSidebarCategoriesForTeamForUser(userID string, teamID string) (*model.OrderedSidebarCategories, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetSidebarCategoriesForTeamForUser(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetSidebarCategoriesForTeamForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetSidebarCategory(categoryID string) (*model.SidebarCategoryWithChannels, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetSidebarCategory(categoryID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetSidebarCategory", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetSidebarCategoryOrder(userID string, teamID string) ([]string, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetSidebarCategoryOrder(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetSidebarCategoryOrder", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetTeamChannels(teamID string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetTeamChannels(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetTeamChannels", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetTeamForChannel(channelID string) (*model.Team, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetTeamForChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetTeamForChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetTeamMembersForChannel(channelID string) ([]string, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetTeamMembersForChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetTeamMembersForChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GroupSyncedChannelCount() (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GroupSyncedChannelCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GroupSyncedChannelCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) IncrementMentionCount(channelID string, userIDs []string, isRoot bool, isUrgent bool) error {
	start := time.Now()

	err := s.ChannelStore.IncrementMentionCount(channelID, userIDs, isRoot, isUrgent)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.IncrementMentionCount", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) InvalidateAllChannelMembersForUser(userID string) {
	start := time.Now()

	s.ChannelStore.InvalidateAllChannelMembersForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.InvalidateAllChannelMembersForUser", success, elapsed)
	}
}

func (s *TimerLayerChannelStore) InvalidateCacheForChannelMembersNotifyProps(channelID string) {
	start := time.Now()

	s.ChannelStore.InvalidateCacheForChannelMembersNotifyProps(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.InvalidateCacheForChannelMembersNotifyProps", success, elapsed)
	}
}

func (s *TimerLayerChannelStore) InvalidateChannel(id string) {
	start := time.Now()

	s.ChannelStore.InvalidateChannel(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.InvalidateChannel", success, elapsed)
	}
}

func (s *TimerLayerChannelStore) InvalidateChannelByName(teamID string, name string) {
	start := time.Now()

	s.ChannelStore.InvalidateChannelByName(teamID, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.InvalidateChannelByName", success, elapsed)
	}
}

func (s *TimerLayerChannelStore) InvalidateGuestCount(channelID string) {
	start := time.Now()

	s.ChannelStore.InvalidateGuestCount(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.InvalidateGuestCount", success, elapsed)
	}
}

func (s *TimerLayerChannelStore) InvalidateMemberCount(channelID string) {
	start := time.Now()

	s.ChannelStore.InvalidateMemberCount(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.InvalidateMemberCount", success, elapsed)
	}
}

func (s *TimerLayerChannelStore) InvalidatePinnedPostCount(channelID string) {
	start := time.Now()

	s.ChannelStore.InvalidatePinnedPostCount(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.InvalidatePinnedPostCount", success, elapsed)
	}
}

func (s *TimerLayerChannelStore) IsChannelReadOnlyScheme(schemeID string) (bool, error) {
	start := time.Now()

	result, err := s.ChannelStore.IsChannelReadOnlyScheme(schemeID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.IsChannelReadOnlyScheme", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) IsReadOnlyChannel(channelID string) (bool, error) {
	start := time.Now()

	result, err := s.ChannelStore.IsReadOnlyChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.IsReadOnlyChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) MigrateChannelMembers(fromChannelID string, fromUserID string) (map[string]string, error) {
	start := time.Now()

	result, err := s.ChannelStore.MigrateChannelMembers(fromChannelID, fromUserID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.MigrateChannelMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) PatchMultipleMembersNotifyProps(members []*model.ChannelMemberIdentifier, notifyProps map[string]string) ([]*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.PatchMultipleMembersNotifyProps(members, notifyProps)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.PatchMultipleMembersNotifyProps", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) PermanentDelete(ctx request.CTX, channelID string) error {
	start := time.Now()

	err := s.ChannelStore.PermanentDelete(ctx, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) PermanentDeleteByTeam(teamID string) error {
	start := time.Now()

	err := s.ChannelStore.PermanentDeleteByTeam(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.PermanentDeleteByTeam", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) PermanentDeleteMembersByChannel(ctx request.CTX, channelID string) error {
	start := time.Now()

	err := s.ChannelStore.PermanentDeleteMembersByChannel(ctx, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.PermanentDeleteMembersByChannel", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) PermanentDeleteMembersByUser(ctx request.CTX, userID string) error {
	start := time.Now()

	err := s.ChannelStore.PermanentDeleteMembersByUser(ctx, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.PermanentDeleteMembersByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) RemoveAllDeactivatedMembers(ctx request.CTX, channelID string) error {
	start := time.Now()

	err := s.ChannelStore.RemoveAllDeactivatedMembers(ctx, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.RemoveAllDeactivatedMembers", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) RemoveMember(ctx request.CTX, channelID string, userID string) error {
	start := time.Now()

	err := s.ChannelStore.RemoveMember(ctx, channelID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.RemoveMember", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) RemoveMembers(ctx request.CTX, channelID string, userIds []string) error {
	start := time.Now()

	err := s.ChannelStore.RemoveMembers(ctx, channelID, userIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.RemoveMembers", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) ResetAllChannelSchemes() error {
	start := time.Now()

	err := s.ChannelStore.ResetAllChannelSchemes()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.ResetAllChannelSchemes", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) Restore(channelID string, timestamp int64) error {
	start := time.Now()

	err := s.ChannelStore.Restore(channelID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Restore", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) Save(rctx request.CTX, channel *model.Channel, maxChannelsPerTeam int64) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.Save(rctx, channel, maxChannelsPerTeam)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) SaveDirectChannel(ctx request.CTX, channel *model.Channel, member1 *model.ChannelMember, member2 *model.ChannelMember) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.SaveDirectChannel(ctx, channel, member1, member2)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.SaveDirectChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) SaveMember(rctx request.CTX, member *model.ChannelMember) (*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.SaveMember(rctx, member)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.SaveMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) SaveMultipleMembers(members []*model.ChannelMember) ([]*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.SaveMultipleMembers(members)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.SaveMultipleMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) SearchAllChannels(term string, opts store.ChannelSearchOpts) (model.ChannelListWithTeamData, int64, error) {
	start := time.Now()

	result, resultVar1, err := s.ChannelStore.SearchAllChannels(term, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.SearchAllChannels", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerChannelStore) SearchArchivedInTeam(teamID string, term string, userID string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.SearchArchivedInTeam(teamID, term, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.SearchArchivedInTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) SearchForUserInTeam(userID string, teamID string, term string, includeDeleted bool) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.SearchForUserInTeam(userID, teamID, term, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.SearchForUserInTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) SearchGroupChannels(userID string, term string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.SearchGroupChannels(userID, term)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.SearchGroupChannels", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) SearchInTeam(teamID string, term string, includeDeleted bool) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.SearchInTeam(teamID, term, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.SearchInTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) SearchMore(userID string, teamID string, term string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.SearchMore(userID, teamID, term)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.SearchMore", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) SetDeleteAt(channelID string, deleteAt int64, updateAt int64) error {
	start := time.Now()

	err := s.ChannelStore.SetDeleteAt(channelID, deleteAt, updateAt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.SetDeleteAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) SetShared(channelID string, shared bool) error {
	start := time.Now()

	err := s.ChannelStore.SetShared(channelID, shared)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.SetShared", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) Update(ctx request.CTX, channel *model.Channel) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.Update(ctx, channel)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) UpdateLastViewedAt(channelIds []string, userID string) (map[string]int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.UpdateLastViewedAt(channelIds, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.UpdateLastViewedAt", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) UpdateLastViewedAtPost(unreadPost *model.Post, userID string, mentionCount int, mentionCountRoot int, urgentMentionCount int, setUnreadCountRoot bool) (*model.ChannelUnreadAt, error) {
	start := time.Now()

	result, err := s.ChannelStore.UpdateLastViewedAtPost(unreadPost, userID, mentionCount, mentionCountRoot, urgentMentionCount, setUnreadCountRoot)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.UpdateLastViewedAtPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) UpdateMember(ctx request.CTX, member *model.ChannelMember) (*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.UpdateMember(ctx, member)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.UpdateMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) UpdateMemberNotifyProps(channelID string, userID string, props map[string]string) (*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.UpdateMemberNotifyProps(channelID, userID, props)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.UpdateMemberNotifyProps", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) UpdateMembersRole(channelID string, userIDs []string) ([]*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.UpdateMembersRole(channelID, userIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.UpdateMembersRole", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) UpdateMultipleMembers(members []*model.ChannelMember) ([]*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.UpdateMultipleMembers(members)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.UpdateMultipleMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) UpdateSidebarCategories(userID string, teamID string, categories []*model.SidebarCategoryWithChannels) ([]*model.SidebarCategoryWithChannels, []*model.SidebarCategoryWithChannels, error) {
	start := time.Now()

	result, resultVar1, err := s.ChannelStore.UpdateSidebarCategories(userID, teamID, categories)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.UpdateSidebarCategories", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerChannelStore) UpdateSidebarCategoryOrder(userID string, teamID string, categoryOrder []string) error {
	start := time.Now()

	err := s.ChannelStore.UpdateSidebarCategoryOrder(userID, teamID, categoryOrder)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.UpdateSidebarCategoryOrder", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) UpdateSidebarChannelCategoryOnMove(channel *model.Channel, newTeamID string) error {
	start := time.Now()

	err := s.ChannelStore.UpdateSidebarChannelCategoryOnMove(channel, newTeamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.UpdateSidebarChannelCategoryOnMove", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) UpdateSidebarChannelsByPreferences(preferences model.Preferences) error {
	start := time.Now()

	err := s.ChannelStore.UpdateSidebarChannelsByPreferences(preferences)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.UpdateSidebarChannelsByPreferences", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) UserBelongsToChannels(userID string, channelIds []string) (bool, error) {
	start := time.Now()

	result, err := s.ChannelStore.UserBelongsToChannels(userID, channelIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.UserBelongsToChannels", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelBookmarkStore) Delete(bookmarkID string, deleteFile bool) error {
	start := time.Now()

	err := s.ChannelBookmarkStore.Delete(bookmarkID, deleteFile)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelBookmarkStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelBookmarkStore) ErrorIfBookmarkFileInfoAlreadyAttached(fileID string, channelID string) error {
	start := time.Now()

	err := s.ChannelBookmarkStore.ErrorIfBookmarkFileInfoAlreadyAttached(fileID, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelBookmarkStore.ErrorIfBookmarkFileInfoAlreadyAttached", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelBookmarkStore) Get(Id string, includeDeleted bool) (*model.ChannelBookmarkWithFileInfo, error) {
	start := time.Now()

	result, err := s.ChannelBookmarkStore.Get(Id, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelBookmarkStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelBookmarkStore) GetBookmarksForChannelSince(channelID string, since int64) ([]*model.ChannelBookmarkWithFileInfo, error) {
	start := time.Now()

	result, err := s.ChannelBookmarkStore.GetBookmarksForChannelSince(channelID, since)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelBookmarkStore.GetBookmarksForChannelSince", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelBookmarkStore) Save(bookmark *model.ChannelBookmark, increaseSortOrder bool) (*model.ChannelBookmarkWithFileInfo, error) {
	start := time.Now()

	result, err := s.ChannelBookmarkStore.Save(bookmark, increaseSortOrder)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelBookmarkStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelBookmarkStore) Update(bookmark *model.ChannelBookmark) error {
	start := time.Now()

	err := s.ChannelBookmarkStore.Update(bookmark)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelBookmarkStore.Update", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelBookmarkStore) UpdateSortOrder(bookmarkID string, channelID string, newIndex int64) ([]*model.ChannelBookmarkWithFileInfo, error) {
	start := time.Now()

	result, err := s.ChannelBookmarkStore.UpdateSortOrder(bookmarkID, channelID, newIndex)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelBookmarkStore.UpdateSortOrder", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelMemberHistoryStore) DeleteOrphanedRows(limit int) (int64, error) {
	start := time.Now()

	result, err := s.ChannelMemberHistoryStore.DeleteOrphanedRows(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelMemberHistoryStore.DeleteOrphanedRows", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelMemberHistoryStore) GetChannelsLeftSince(userID string, since int64) ([]string, error) {
	start := time.Now()

	result, err := s.ChannelMemberHistoryStore.GetChannelsLeftSince(userID, since)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelMemberHistoryStore.GetChannelsLeftSince", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelMemberHistoryStore) GetChannelsWithActivityDuring(startTime int64, endTime int64) ([]string, error) {
	start := time.Now()

	result, err := s.ChannelMemberHistoryStore.GetChannelsWithActivityDuring(startTime, endTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelMemberHistoryStore.GetChannelsWithActivityDuring", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelMemberHistoryStore) GetUsersInChannelDuring(startTime int64, endTime int64, channelID []string) ([]*model.ChannelMemberHistoryResult, error) {
	start := time.Now()

	result, err := s.ChannelMemberHistoryStore.GetUsersInChannelDuring(startTime, endTime, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelMemberHistoryStore.GetUsersInChannelDuring", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelMemberHistoryStore) LogJoinEvent(userID string, channelID string, joinTime int64) error {
	start := time.Now()

	err := s.ChannelMemberHistoryStore.LogJoinEvent(userID, channelID, joinTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelMemberHistoryStore.LogJoinEvent", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelMemberHistoryStore) LogLeaveEvent(userID string, channelID string, leaveTime int64) error {
	start := time.Now()

	err := s.ChannelMemberHistoryStore.LogLeaveEvent(userID, channelID, leaveTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelMemberHistoryStore.LogLeaveEvent", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelMemberHistoryStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := time.Now()

	result, err := s.ChannelMemberHistoryStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelMemberHistoryStore.PermanentDeleteBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelMemberHistoryStore) PermanentDeleteBatchForRetentionPolicies(now int64, globalPolicyEndTime int64, limit int64, cursor model.RetentionPolicyCursor) (int64, model.RetentionPolicyCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.ChannelMemberHistoryStore.PermanentDeleteBatchForRetentionPolicies(now, globalPolicyEndTime, limit, cursor)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelMemberHistoryStore.PermanentDeleteBatchForRetentionPolicies", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerClusterDiscoveryStore) Cleanup() error {
	start := time.Now()

	err := s.ClusterDiscoveryStore.Cleanup()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Cleanup", success, elapsed)
	}
	return err
}

func (s *TimerLayerClusterDiscoveryStore) Delete(discovery *model.ClusterDiscovery) (bool, error) {
	start := time.Now()

	result, err := s.ClusterDiscoveryStore.Delete(discovery)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Exists(discovery *model.ClusterDiscovery) (bool, error) {
	start := time.Now()

	result, err := s.ClusterDiscoveryStore.Exists(discovery)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Exists", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) GetAll(discoveryType string, clusterName string) ([]*model.ClusterDiscovery, error) {
	start := time.Now()

	result, err := s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Save(discovery *model.ClusterDiscovery) error {
	start := time.Now()

	err := s.ClusterDiscoveryStore.Save(discovery)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerClusterDiscoveryStore) SetLastPingAt(discovery *model.ClusterDiscovery) error {
	start := time.Now()

	err := s.ClusterDiscoveryStore.SetLastPingAt(discovery)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.SetLastPingAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerCommandStore) AnalyticsCommandCount(teamID string) (int64, error) {
	start := time.Now()

	result, err := s.CommandStore.AnalyticsCommandCount(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.AnalyticsCommandCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandStore) Delete(commandID string, timestamp int64) error {
	start := time.Now()

	err := s.CommandStore.Delete(commandID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerCommandStore) Get(id string) (*model.Command, error) {
	start := time.Now()

	result, err := s.CommandStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandStore) GetByTeam(teamID string) ([]*model.Command, error) {
	start := time.Now()

	result, err := s.CommandStore.GetByTeam(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.GetByTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandStore) GetByTrigger(teamID string, trigger string) (*model.Command, error) {
	start := time.Now()

	result, err := s.CommandStore.GetByTrigger(teamID, trigger)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.GetByTrigger", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandStore) PermanentDeleteByTeam(teamID string) error {
	start := time.Now()

	err := s.CommandStore.PermanentDeleteByTeam(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.PermanentDeleteByTeam", success, elapsed)
	}
	return err
}

func (s *TimerLayerCommandStore) PermanentDeleteByUser(userID string) error {
	start := time.Now()

	err := s.CommandStore.PermanentDeleteByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerCommandStore) Save(webhook *model.Command) (*model.Command, error) {
	start := time.Now()

	result, err := s.CommandStore.Save(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandStore) Update(hook *model.Command) (*model.Command, error) {
	start := time.Now()

	result, err := s.CommandStore.Update(hook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandWebhookStore) Cleanup() {
	start := time.Now()

	s.CommandWebhookStore.Cleanup()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandWebhookStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerCommandWebhookStore) Get(id string) (*model.CommandWebhook, error) {
	start := time.Now()

	result, err := s.CommandWebhookStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandWebhookStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandWebhookStore) Save(webhook *model.CommandWebhook) (*model.CommandWebhook, error) {
	start := time.Now()

	result, err := s.CommandWebhookStore.Save(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandWebhookStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandWebhookStore) TryUse(id string, limit int) error {
	start := time.Now()

	err := s.CommandWebhookStore.TryUse(id, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandWebhookStore.TryUse", success, elapsed)
	}
	return err
}

func (s *TimerLayerComplianceStore) ComplianceExport(compliance *model.Compliance, cursor model.ComplianceExportCursor, limit int) ([]*model.CompliancePost, model.ComplianceExportCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.ComplianceStore.ComplianceExport(compliance, cursor, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.ComplianceExport", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerComplianceStore) Get(id string) (*model.Compliance, error) {
	start := time.Now()

	result, err := s.ComplianceStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) GetAll(offset int, limit int) (model.Compliances, error) {
	start := time.Now()

	result, err := s.ComplianceStore.GetAll(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) MessageExport(c request.CTX, cursor model.MessageExportCursor, limit int) ([]*model.MessageExport, model.MessageExportCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.ComplianceStore.MessageExport(c, cursor, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.MessageExport", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerComplianceStore) Save(compliance *model.Compliance) (*model.Compliance, error) {
	start := time.Now()

	result, err := s.ComplianceStore.Save(compliance)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) Update(compliance *model.Compliance) (*model.Compliance, error) {
	start := time.Now()

	result, err := s.ComplianceStore.Update(compliance)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDesktopTokensStore) Delete(token string) error {
	start := time.Now()

	err := s.DesktopTokensStore.Delete(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DesktopTokensStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerDesktopTokensStore) DeleteByUserId(userID string) error {
	start := time.Now()

	err := s.DesktopTokensStore.DeleteByUserId(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DesktopTokensStore.DeleteByUserId", success, elapsed)
	}
	return err
}

func (s *TimerLayerDesktopTokensStore) DeleteOlderThan(minCreatedAt int64) error {
	start := time.Now()

	err := s.DesktopTokensStore.DeleteOlderThan(minCreatedAt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DesktopTokensStore.DeleteOlderThan", success, elapsed)
	}
	return err
}

func (s *TimerLayerDesktopTokensStore) GetUserId(token string, minCreatedAt int64) (*string, error) {
	start := time.Now()

	result, err := s.DesktopTokensStore.GetUserId(token, minCreatedAt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DesktopTokensStore.GetUserId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDesktopTokensStore) Insert(token string, createAt int64, userID string) error {
	start := time.Now()

	err := s.DesktopTokensStore.Insert(token, createAt, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DesktopTokensStore.Insert", success, elapsed)
	}
	return err
}

func (s *TimerLayerDraftStore) Delete(userID string, channelID string, rootID string) error {
	start := time.Now()

	err := s.DraftStore.Delete(userID, channelID, rootID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DraftStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerDraftStore) DeleteDraftsAssociatedWithPost(channelID string, rootID string) error {
	start := time.Now()

	err := s.DraftStore.DeleteDraftsAssociatedWithPost(channelID, rootID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DraftStore.DeleteDraftsAssociatedWithPost", success, elapsed)
	}
	return err
}

func (s *TimerLayerDraftStore) DeleteEmptyDraftsByCreateAtAndUserId(createAt int64, userID string) error {
	start := time.Now()

	err := s.DraftStore.DeleteEmptyDraftsByCreateAtAndUserId(createAt, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DraftStore.DeleteEmptyDraftsByCreateAtAndUserId", success, elapsed)
	}
	return err
}

func (s *TimerLayerDraftStore) DeleteOrphanDraftsByCreateAtAndUserId(createAt int64, userID string) error {
	start := time.Now()

	err := s.DraftStore.DeleteOrphanDraftsByCreateAtAndUserId(createAt, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DraftStore.DeleteOrphanDraftsByCreateAtAndUserId", success, elapsed)
	}
	return err
}

func (s *TimerLayerDraftStore) Get(userID string, channelID string, rootID string, includeDeleted bool) (*model.Draft, error) {
	start := time.Now()

	result, err := s.DraftStore.Get(userID, channelID, rootID, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DraftStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDraftStore) GetDraftsForUser(userID string, teamID string) ([]*model.Draft, error) {
	start := time.Now()

	result, err := s.DraftStore.GetDraftsForUser(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DraftStore.GetDraftsForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDraftStore) GetLastCreateAtAndUserIdValuesForEmptyDraftsMigration(createAt int64, userID string) (int64, string, error) {
	start := time.Now()

	result, resultVar1, err := s.DraftStore.GetLastCreateAtAndUserIdValuesForEmptyDraftsMigration(createAt, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DraftStore.GetLastCreateAtAndUserIdValuesForEmptyDraftsMigration", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerDraftStore) PermanentDeleteByUser(userId string) error {
	start := time.Now()

	err := s.DraftStore.PermanentDeleteByUser(userId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DraftStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerDraftStore) Upsert(d *model.Draft) (*model.Draft, error) {
	start := time.Now()

	result, err := s.DraftStore.Upsert(d)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DraftStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerEmojiStore) Delete(emoji *model.Emoji, timestamp int64) error {
	start := time.Now()

	err := s.EmojiStore.Delete(emoji, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerEmojiStore) Get(c request.CTX, id string, allowFromCache bool) (*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.Get(c, id, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerEmojiStore) GetByName(c request.CTX, name string, allowFromCache bool) (*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.GetByName(c, name, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerEmojiStore) GetList(offset int, limit int, sort string) ([]*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.GetList(offset, limit, sort)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.GetList", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerEmojiStore) GetMultipleByName(c request.CTX, names []string) ([]*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.GetMultipleByName(c, names)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.GetMultipleByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerEmojiStore) Save(emoji *model.Emoji) (*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.Save(emoji)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerEmojiStore) Search(name string, prefixOnly bool, limit int) ([]*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.Search(name, prefixOnly, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("EmojiStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) AttachToPost(c request.CTX, fileID string, postID string, channelID string, creatorID string) error {
	start := time.Now()

	err := s.FileInfoStore.AttachToPost(c, fileID, postID, channelID, creatorID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.AttachToPost", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) ClearCaches() {
	start := time.Now()

	s.FileInfoStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) CountAll() (int64, error) {
	start := time.Now()

	result, err := s.FileInfoStore.CountAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.CountAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) DeleteForPost(c request.CTX, postID string) (string, error) {
	start := time.Now()

	result, err := s.FileInfoStore.DeleteForPost(c, postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.DeleteForPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) DeleteForPostByIds(rctx request.CTX, postId string, fileIDs []string) error {
	start := time.Now()

	err := s.FileInfoStore.DeleteForPostByIds(rctx, postId, fileIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.DeleteForPostByIds", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) Get(id string) (*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetByIds(ids []string, includeDeleted bool, allowFromCache bool) ([]*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetByIds(ids, includeDeleted, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetByPath(path string) (*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetByPath(path)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetByPath", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetFilesBatchForIndexing(startTime int64, startFileID string, includeDeleted bool, limit int) ([]*model.FileForIndexing, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetFilesBatchForIndexing(startTime, startFileID, includeDeleted, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetFilesBatchForIndexing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetForPost(postID string, readFromMaster bool, includeDeleted bool, allowFromCache bool) ([]*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetForPost(postID, readFromMaster, includeDeleted, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetForPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetForUser(userID string) ([]*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetFromMaster(id string) (*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetFromMaster(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetFromMaster", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetStorageUsage(allowFromCache bool, includeDeleted bool) (int64, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetStorageUsage(allowFromCache, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetStorageUsage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetUptoNSizeFileTime(n int64) (int64, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetUptoNSizeFileTime(n)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetUptoNSizeFileTime", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetWithOptions(page int, perPage int, opt *model.GetFileInfosOptions) ([]*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetWithOptions(page, perPage, opt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetWithOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) InvalidateFileInfosForPostCache(postID string, deleted bool) {
	start := time.Now()

	s.FileInfoStore.InvalidateFileInfosForPostCache(postID, deleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.InvalidateFileInfosForPostCache", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) PermanentDelete(c request.CTX, fileID string) error {
	start := time.Now()

	err := s.FileInfoStore.PermanentDelete(c, fileID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) PermanentDeleteBatch(ctx request.CTX, endTime int64, limit int64) (int64, error) {
	start := time.Now()

	result, err := s.FileInfoStore.PermanentDeleteBatch(ctx, endTime, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) PermanentDeleteByUser(ctx request.CTX, userID string) (int64, error) {
	start := time.Now()

	result, err := s.FileInfoStore.PermanentDeleteByUser(ctx, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) PermanentDeleteForPost(rctx request.CTX, postID string) error {
	start := time.Now()

	err := s.FileInfoStore.PermanentDeleteForPost(rctx, postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteForPost", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) RefreshFileStats() error {
	start := time.Now()

	err := s.FileInfoStore.RefreshFileStats()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.RefreshFileStats", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) RestoreForPostByIds(rctx request.CTX, postId string, fileIDs []string) error {
	start := time.Now()

	err := s.FileInfoStore.RestoreForPostByIds(rctx, postId, fileIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.RestoreForPostByIds", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) Save(ctx request.CTX, info *model.FileInfo) (*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.Save(ctx, info)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) Search(ctx request.CTX, paramsList []*model.SearchParams, userID string, teamID string, page int, perPage int) (*model.FileInfoList, error) {
	start := time.Now()

	result, err := s.FileInfoStore.Search(ctx, paramsList, userID, teamID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) SetContent(ctx request.CTX, fileID string, content string) error {
	start := time.Now()

	err := s.FileInfoStore.SetContent(ctx, fileID, content)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.SetContent", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) Upsert(rctx request.CTX, info *model.FileInfo) (*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.Upsert(rctx, info)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) AdminRoleGroupsForSyncableMember(userID string, syncableID string, syncableType model.GroupSyncableType) ([]string, error) {
	start := time.Now()

	result, err := s.GroupStore.AdminRoleGroupsForSyncableMember(userID, syncableID, syncableType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.AdminRoleGroupsForSyncableMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) ChannelMembersMinusGroupMembers(channelID string, groupIDs []string, page int, perPage int) ([]*model.UserWithGroups, error) {
	start := time.Now()

	result, err := s.GroupStore.ChannelMembersMinusGroupMembers(channelID, groupIDs, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.ChannelMembersMinusGroupMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) ChannelMembersToAdd(since int64, channelID *string, reAddRemovedMembers bool) ([]*model.UserChannelIDPair, error) {
	start := time.Now()

	result, err := s.GroupStore.ChannelMembersToAdd(since, channelID, reAddRemovedMembers)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.ChannelMembersToAdd", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) ChannelMembersToRemove(channelID *string) ([]*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.GroupStore.ChannelMembersToRemove(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.ChannelMembersToRemove", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) CountChannelMembersMinusGroupMembers(channelID string, groupIDs []string) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.CountChannelMembersMinusGroupMembers(channelID, groupIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.CountChannelMembersMinusGroupMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) CountGroupsByChannel(channelID string, opts model.GroupSearchOpts) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.CountGroupsByChannel(channelID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.CountGroupsByChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) CountGroupsByTeam(teamID string, opts model.GroupSearchOpts) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.CountGroupsByTeam(teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.CountGroupsByTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) CountTeamMembersMinusGroupMembers(teamID string, groupIDs []string) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.CountTeamMembersMinusGroupMembers(teamID, groupIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.CountTeamMembersMinusGroupMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) Create(group *model.Group) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.Create(group)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.Create", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) CreateGroupSyncable(groupSyncable *model.GroupSyncable) (*model.GroupSyncable, error) {
	start := time.Now()

	result, err := s.GroupStore.CreateGroupSyncable(groupSyncable)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.CreateGroupSyncable", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) CreateWithUserIds(group *model.GroupWithUserIds) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.CreateWithUserIds(group)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.CreateWithUserIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) Delete(groupID string) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.Delete(groupID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) DeleteGroupSyncable(groupID string, syncableID string, syncableType model.GroupSyncableType) (*model.GroupSyncable, error) {
	start := time.Now()

	result, err := s.GroupStore.DeleteGroupSyncable(groupID, syncableID, syncableType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.DeleteGroupSyncable", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) DeleteMember(groupID string, userID string) (*model.GroupMember, error) {
	start := time.Now()

	result, err := s.GroupStore.DeleteMember(groupID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.DeleteMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) DeleteMembers(groupID string, userIDs []string) ([]*model.GroupMember, error) {
	start := time.Now()

	result, err := s.GroupStore.DeleteMembers(groupID, userIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.DeleteMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) DistinctGroupMemberCount() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.DistinctGroupMemberCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.DistinctGroupMemberCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) DistinctGroupMemberCountForSource(source model.GroupSource) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.DistinctGroupMemberCountForSource(source)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.DistinctGroupMemberCountForSource", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) Get(groupID string) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.Get(groupID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetAllBySource(groupSource model.GroupSource) ([]*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetAllBySource(groupSource)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetAllBySource", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetAllGroupSyncablesByGroupId(groupID string, syncableType model.GroupSyncableType) ([]*model.GroupSyncable, error) {
	start := time.Now()

	result, err := s.GroupStore.GetAllGroupSyncablesByGroupId(groupID, syncableType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetAllGroupSyncablesByGroupId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetByIDs(groupIDs []string) ([]*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetByIDs(groupIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetByIDs", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetByName(name string, opts model.GroupSearchOpts) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetByName(name, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetByRemoteID(remoteID string, groupSource model.GroupSource) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetByRemoteID(remoteID, groupSource)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetByRemoteID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetByUser(userID string, opts model.GroupSearchOpts) ([]*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetByUser(userID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetGroupSyncable(groupID string, syncableID string, syncableType model.GroupSyncableType) (*model.GroupSyncable, error) {
	start := time.Now()

	result, err := s.GroupStore.GetGroupSyncable(groupID, syncableID, syncableType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetGroupSyncable", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetGroups(page int, perPage int, opts model.GroupSearchOpts, viewRestrictions *model.ViewUsersRestrictions) ([]*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetGroups(page, perPage, opts, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetGroups", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetGroupsAssociatedToChannelsByTeam(teamID string, opts model.GroupSearchOpts) (map[string][]*model.GroupWithSchemeAdmin, error) {
	start := time.Now()

	result, err := s.GroupStore.GetGroupsAssociatedToChannelsByTeam(teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetGroupsAssociatedToChannelsByTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetGroupsByChannel(channelID string, opts model.GroupSearchOpts) ([]*model.GroupWithSchemeAdmin, error) {
	start := time.Now()

	result, err := s.GroupStore.GetGroupsByChannel(channelID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetGroupsByChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetGroupsByTeam(teamID string, opts model.GroupSearchOpts) ([]*model.GroupWithSchemeAdmin, error) {
	start := time.Now()

	result, err := s.GroupStore.GetGroupsByTeam(teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetGroupsByTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetMember(groupID string, userID string) (*model.GroupMember, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMember(groupID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetMemberCount(groupID string) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberCount(groupID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetMemberCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetMemberCountWithRestrictions(groupID string, viewRestrictions *model.ViewUsersRestrictions) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberCountWithRestrictions(groupID, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetMemberCountWithRestrictions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetMemberUsers(groupID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberUsers(groupID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetMemberUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetMemberUsersInTeam(groupID string, teamID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberUsersInTeam(groupID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetMemberUsersInTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetMemberUsersNotInChannel(groupID string, channelID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberUsersNotInChannel(groupID, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetMemberUsersNotInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetMemberUsersPage(groupID string, page int, perPage int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberUsersPage(groupID, page, perPage, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetMemberUsersPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetMemberUsersSortedPage(groupID string, page int, perPage int, viewRestrictions *model.ViewUsersRestrictions, teammateNameDisplay string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberUsersSortedPage(groupID, page, perPage, viewRestrictions, teammateNameDisplay)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetMemberUsersSortedPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GetNonMemberUsersPage(groupID string, page int, perPage int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetNonMemberUsersPage(groupID, page, perPage, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GetNonMemberUsersPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GroupChannelCount() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupChannelCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GroupChannelCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GroupCount() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GroupCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GroupCountBySource(source model.GroupSource) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupCountBySource(source)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GroupCountBySource", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GroupCountWithAllowReference() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupCountWithAllowReference()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GroupCountWithAllowReference", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GroupMemberCount() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupMemberCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GroupMemberCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) GroupTeamCount() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupTeamCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.GroupTeamCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) PermanentDeleteMembersByUser(userID string) error {
	start := time.Now()

	err := s.GroupStore.PermanentDeleteMembersByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.PermanentDeleteMembersByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerGroupStore) PermittedSyncableAdmins(syncableID string, syncableType model.GroupSyncableType) ([]string, error) {
	start := time.Now()

	result, err := s.GroupStore.PermittedSyncableAdmins(syncableID, syncableType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.PermittedSyncableAdmins", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) Restore(groupID string) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.Restore(groupID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.Restore", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) TeamMembersMinusGroupMembers(teamID string, groupIDs []string, page int, perPage int) ([]*model.UserWithGroups, error) {
	start := time.Now()

	result, err := s.GroupStore.TeamMembersMinusGroupMembers(teamID, groupIDs, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.TeamMembersMinusGroupMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) TeamMembersToAdd(since int64, teamID *string, reAddRemovedMembers bool) ([]*model.UserTeamIDPair, error) {
	start := time.Now()

	result, err := s.GroupStore.TeamMembersToAdd(since, teamID, reAddRemovedMembers)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.TeamMembersToAdd", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) TeamMembersToRemove(teamID *string) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.GroupStore.TeamMembersToRemove(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.TeamMembersToRemove", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) Update(group *model.Group) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.Update(group)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) UpdateGroupSyncable(groupSyncable *model.GroupSyncable) (*model.GroupSyncable, error) {
	start := time.Now()

	result, err := s.GroupStore.UpdateGroupSyncable(groupSyncable)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.UpdateGroupSyncable", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) UpsertMember(groupID string, userID string) (*model.GroupMember, error) {
	start := time.Now()

	result, err := s.GroupStore.UpsertMember(groupID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.UpsertMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGroupStore) UpsertMembers(groupID string, userIDs []string) ([]*model.GroupMember, error) {
	start := time.Now()

	result, err := s.GroupStore.UpsertMembers(groupID, userIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GroupStore.UpsertMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Cleanup(expiryTime int64, batchSize int) error {
	start := time.Now()

	err := s.JobStore.Cleanup(expiryTime, batchSize)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Cleanup", success, elapsed)
	}
	return err
}

func (s *TimerLayerJobStore) Delete(id string) (string, error) {
	start := time.Now()

	result, err := s.JobStore.Delete(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Get(c request.CTX, id string) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.Get(c, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByStatus(c request.CTX, status string) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllByStatus(c, status)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByType(c request.CTX, jobType string) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllByType(c, jobType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByTypeAndStatus(c request.CTX, jobType string, status string) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllByTypeAndStatus(c, jobType, status)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByTypeAndStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByTypeAndStatusPage(c request.CTX, jobType []string, status string, offset int, limit int) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllByTypeAndStatusPage(c, jobType, status, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByTypeAndStatusPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByTypePage(c request.CTX, jobType string, offset int, limit int) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllByTypePage(c, jobType, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByTypePage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByTypesPage(c request.CTX, jobTypes []string, offset int, limit int) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllByTypesPage(c, jobTypes, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByTypesPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetCountByStatusAndType(status string, jobType string) (int64, error) {
	start := time.Now()

	result, err := s.JobStore.GetCountByStatusAndType(status, jobType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetCountByStatusAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetNewestJobByStatusAndType(status string, jobType string) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetNewestJobByStatusAndType(status, jobType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetNewestJobByStatusAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetNewestJobByStatusesAndType(statuses []string, jobType string) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetNewestJobByStatusesAndType(statuses, jobType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetNewestJobByStatusesAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Save(job *model.Job) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.Save(job)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) SaveOnce(job *model.Job) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.SaveOnce(job)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.SaveOnce", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateOptimistically(job *model.Job, currentStatus string) (bool, error) {
	start := time.Now()

	result, err := s.JobStore.UpdateOptimistically(job, currentStatus)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateOptimistically", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateStatus(id string, status string) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.UpdateStatus(id, status)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateStatusOptimistically(id string, currentStatus string, newStatus string) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatusOptimistically", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerLicenseStore) Get(c request.CTX, id string) (*model.LicenseRecord, error) {
	start := time.Now()

	result, err := s.LicenseStore.Get(c, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LicenseStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerLicenseStore) GetAll() ([]*model.LicenseRecord, error) {
	start := time.Now()

	result, err := s.LicenseStore.GetAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LicenseStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerLicenseStore) Save(license *model.LicenseRecord) error {
	start := time.Now()

	err := s.LicenseStore.Save(license)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LicenseStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerLinkMetadataStore) Get(url string, timestamp int64) (*model.LinkMetadata, error) {
	start := time.Now()

	result, err := s.LinkMetadataStore.Get(url, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LinkMetadataStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerLinkMetadataStore) Save(linkMetadata *model.LinkMetadata) (*model.LinkMetadata, error) {
	start := time.Now()

	result, err := s.LinkMetadataStore.Save(linkMetadata)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LinkMetadataStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerNotifyAdminStore) DeleteBefore(trial bool, now int64) error {
	start := time.Now()

	err := s.NotifyAdminStore.DeleteBefore(trial, now)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("NotifyAdminStore.DeleteBefore", success, elapsed)
	}
	return err
}

func (s *TimerLayerNotifyAdminStore) Get(trial bool) ([]*model.NotifyAdminData, error) {
	start := time.Now()

	result, err := s.NotifyAdminStore.Get(trial)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("NotifyAdminStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerNotifyAdminStore) GetDataByUserIdAndFeature(userID string, feature model.MattermostFeature) ([]*model.NotifyAdminData, error) {
	start := time.Now()

	result, err := s.NotifyAdminStore.GetDataByUserIdAndFeature(userID, feature)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("NotifyAdminStore.GetDataByUserIdAndFeature", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerNotifyAdminStore) Save(data *model.NotifyAdminData) (*model.NotifyAdminData, error) {
	start := time.Now()

	result, err := s.NotifyAdminStore.Save(data)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("NotifyAdminStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerNotifyAdminStore) Update(userID string, requiredPlan string, requiredFeature model.MattermostFeature, now int64) error {
	start := time.Now()

	err := s.NotifyAdminStore.Update(userID, requiredPlan, requiredFeature, now)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("NotifyAdminStore.Update", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) DeleteApp(id string) error {
	start := time.Now()

	err := s.OAuthStore.DeleteApp(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.DeleteApp", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) GetAccessData(token string) (*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAccessData(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAccessData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetAccessDataByRefreshToken(token string) (*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAccessDataByRefreshToken(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAccessDataByRefreshToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetAccessDataByUserForApp(userID string, clientID string) ([]*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAccessDataByUserForApp(userID, clientID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAccessDataByUserForApp", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetApp(id string) (*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetApp(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetApp", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetAppByUser(userID string, offset int, limit int) ([]*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAppByUser(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAppByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetApps(offset int, limit int) ([]*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetApps(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetApps", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetAuthData(code string) (*model.AuthData, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAuthData(code)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAuthData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetAuthorizedApps(userID string, offset int, limit int) ([]*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAuthorizedApps(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAuthorizedApps", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetPreviousAccessData(userID string, clientID string) (*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetPreviousAccessData(userID, clientID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetPreviousAccessData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) PermanentDeleteAuthDataByUser(userID string) error {
	start := time.Now()

	err := s.OAuthStore.PermanentDeleteAuthDataByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.PermanentDeleteAuthDataByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) RemoveAccessData(token string) error {
	start := time.Now()

	err := s.OAuthStore.RemoveAccessData(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.RemoveAccessData", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) RemoveAllAccessData() error {
	start := time.Now()

	err := s.OAuthStore.RemoveAllAccessData()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.RemoveAllAccessData", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) RemoveAuthData(code string) error {
	start := time.Now()

	err := s.OAuthStore.RemoveAuthData(code)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.RemoveAuthData", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) RemoveAuthDataByClientId(clientID string, userID string) error {
	start := time.Now()

	err := s.OAuthStore.RemoveAuthDataByClientId(clientID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.RemoveAuthDataByClientId", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) RemoveAuthDataByUserId(userID string) error {
	start := time.Now()

	err := s.OAuthStore.RemoveAuthDataByUserId(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.RemoveAuthDataByUserId", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) SaveAccessData(accessData *model.AccessData) (*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.SaveAccessData(accessData)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.SaveAccessData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) SaveApp(app *model.OAuthApp) (*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.SaveApp(app)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.SaveApp", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) SaveAuthData(authData *model.AuthData) (*model.AuthData, error) {
	start := time.Now()

	result, err := s.OAuthStore.SaveAuthData(authData)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.SaveAuthData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) UpdateAccessData(accessData *model.AccessData) (*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.UpdateAccessData(accessData)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.UpdateAccessData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) UpdateApp(app *model.OAuthApp) (*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.UpdateApp(app)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.UpdateApp", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOutgoingOAuthConnectionStore) DeleteConnection(c request.CTX, id string) error {
	start := time.Now()

	err := s.OutgoingOAuthConnectionStore.DeleteConnection(c, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OutgoingOAuthConnectionStore.DeleteConnection", success, elapsed)
	}
	return err
}

func (s *TimerLayerOutgoingOAuthConnectionStore) GetConnection(c request.CTX, id string) (*model.OutgoingOAuthConnection, error) {
	start := time.Now()

	result, err := s.OutgoingOAuthConnectionStore.GetConnection(c, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OutgoingOAuthConnectionStore.GetConnection", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOutgoingOAuthConnectionStore) GetConnections(c request.CTX, filters model.OutgoingOAuthConnectionGetConnectionsFilter) ([]*model.OutgoingOAuthConnection, error) {
	start := time.Now()

	result, err := s.OutgoingOAuthConnectionStore.GetConnections(c, filters)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OutgoingOAuthConnectionStore.GetConnections", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOutgoingOAuthConnectionStore) SaveConnection(c request.CTX, conn *model.OutgoingOAuthConnection) (*model.OutgoingOAuthConnection, error) {
	start := time.Now()

	result, err := s.OutgoingOAuthConnectionStore.SaveConnection(c, conn)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OutgoingOAuthConnectionStore.SaveConnection", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOutgoingOAuthConnectionStore) UpdateConnection(c request.CTX, conn *model.OutgoingOAuthConnection) (*model.OutgoingOAuthConnection, error) {
	start := time.Now()

	result, err := s.OutgoingOAuthConnectionStore.UpdateConnection(c, conn)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OutgoingOAuthConnectionStore.UpdateConnection", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) CompareAndDelete(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {
	start := time.Now()

	result, err := s.PluginStore.CompareAndDelete(keyVal, oldValue)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.CompareAndDelete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) CompareAndSet(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {
	start := time.Now()

	result, err := s.PluginStore.CompareAndSet(keyVal, oldValue)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.CompareAndSet", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) Delete(pluginID string, key string) error {
	start := time.Now()

	err := s.PluginStore.Delete(pluginID, key)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) DeleteAllExpired() error {
	start := time.Now()

	err := s.PluginStore.DeleteAllExpired()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.DeleteAllExpired", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) DeleteAllForPlugin(PluginID string) error {
	start := time.Now()

	err := s.PluginStore.DeleteAllForPlugin(PluginID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.DeleteAllForPlugin", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) Get(pluginID string, key string) (*model.PluginKeyValue, error) {
	start := time.Now()

	result, err := s.PluginStore.Get(pluginID, key)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) List(pluginID string, page int, perPage int) ([]string, error) {
	start := time.Now()

	result, err := s.PluginStore.List(pluginID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.List", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) SaveOrUpdate(keyVal *model.PluginKeyValue) (*model.PluginKeyValue, error) {
	start := time.Now()

	result, err := s.PluginStore.SaveOrUpdate(keyVal)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.SaveOrUpdate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) SetWithOptions(pluginID string, key string, value []byte, options model.PluginKVSetOptions) (bool, error) {
	start := time.Now()

	result, err := s.PluginStore.SetWithOptions(pluginID, key, value, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.SetWithOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) AnalyticsPostCount(options *model.PostCountOptions) (int64, error) {
	start := time.Now()

	result, err := s.PostStore.AnalyticsPostCount(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.AnalyticsPostCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) AnalyticsPostCountByTeam(teamID string) (int64, error) {
	start := time.Now()

	result, err := s.PostStore.AnalyticsPostCountByTeam(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.AnalyticsPostCountByTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) AnalyticsPostCountsByDay(options *model.AnalyticsPostCountsOptions) (model.AnalyticsRows, error) {
	start := time.Now()

	result, err := s.PostStore.AnalyticsPostCountsByDay(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.AnalyticsPostCountsByDay", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) AnalyticsUserCountsWithPostsByDay(teamID string) (model.AnalyticsRows, error) {
	start := time.Now()

	result, err := s.PostStore.AnalyticsUserCountsWithPostsByDay(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.AnalyticsUserCountsWithPostsByDay", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) ClearCaches() {
	start := time.Now()

	s.PostStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerPostStore) Delete(rctx request.CTX, postID string, timestamp int64, deleteByID string) error {
	start := time.Now()

	err := s.PostStore.Delete(rctx, postID, timestamp, deleteByID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostStore) Get(ctx context.Context, id string, opts model.GetPostsOptions, userID string, sanitizeOptions map[string]bool) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.Get(ctx, id, opts, userID, sanitizeOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetDirectPostParentsForExportAfter(limit int, afterID string, includeArchivedChannels bool) ([]*model.DirectPostForExport, error) {
	start := time.Now()

	result, err := s.PostStore.GetDirectPostParentsForExportAfter(limit, afterID, includeArchivedChannels)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetDirectPostParentsForExportAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetEditHistoryForPost(postID string) ([]*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetEditHistoryForPost(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetEditHistoryForPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetEtag(channelID string, allowFromCache bool, collapsedThreads bool) string {
	start := time.Now()

	result := s.PostStore.GetEtag(channelID, allowFromCache, collapsedThreads)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetEtag", success, elapsed)
	}
	return result
}

func (s *TimerLayerPostStore) GetFlaggedPosts(userID string, offset int, limit int) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetFlaggedPosts(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetFlaggedPosts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetFlaggedPostsForChannel(userID string, channelID string, offset int, limit int) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetFlaggedPostsForChannel(userID, channelID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetFlaggedPostsForChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetFlaggedPostsForTeam(userID string, teamID string, offset int, limit int) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetFlaggedPostsForTeam(userID, teamID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetFlaggedPostsForTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetMaxPostSize() int {
	start := time.Now()

	result := s.PostStore.GetMaxPostSize()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetMaxPostSize", success, elapsed)
	}
	return result
}

func (s *TimerLayerPostStore) GetNthRecentPostTime(n int64) (int64, error) {
	start := time.Now()

	result, err := s.PostStore.GetNthRecentPostTime(n)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetNthRecentPostTime", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetOldest() (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetOldest()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetOldest", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetOldestEntityCreationTime() (int64, error) {
	start := time.Now()

	result, err := s.PostStore.GetOldestEntityCreationTime()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetOldestEntityCreationTime", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetParentsForExportAfter(limit int, afterID string, includeArchivedChannels bool) ([]*model.PostForExport, error) {
	start := time.Now()

	result, err := s.PostStore.GetParentsForExportAfter(limit, afterID, includeArchivedChannels)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetParentsForExportAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostAfterTime(channelID string, timestamp int64, collapsedThreads bool) (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostAfterTime(channelID, timestamp, collapsedThreads)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostAfterTime", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostIdAfterTime(channelID string, timestamp int64, collapsedThreads bool) (string, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostIdAfterTime(channelID, timestamp, collapsedThreads)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostIdAfterTime", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostIdBeforeTime(channelID string, timestamp int64, collapsedThreads bool) (string, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostIdBeforeTime(channelID, timestamp, collapsedThreads)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostIdBeforeTime", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostReminderMetadata(postID string) (*store.PostReminderMetadata, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostReminderMetadata(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostReminderMetadata", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostReminders(now int64) ([]*model.PostReminder, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostReminders(now)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostReminders", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPosts(options model.GetPostsOptions, allowFromCache bool, sanitizeOptions map[string]bool) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetPosts(options, allowFromCache, sanitizeOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPosts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostsAfter(options model.GetPostsOptions, sanitizeOptions map[string]bool) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsAfter(options, sanitizeOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostsBatchForIndexing(startTime int64, startPostID string, limit int) ([]*model.PostForIndexing, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsBatchForIndexing(startTime, startPostID, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsBatchForIndexing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostsBefore(options model.GetPostsOptions, sanitizeOptions map[string]bool) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsBefore(options, sanitizeOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsBefore", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostsByIds(postIds []string) ([]*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsByIds(postIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostsByThread(threadID string, since int64) ([]*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsByThread(threadID, since)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsByThread", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostsCreatedAt(channelID string, timestamp int64) ([]*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsCreatedAt(channelID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsCreatedAt", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostsSince(options model.GetPostsSinceOptions, allowFromCache bool, sanitizeOptions map[string]bool) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsSince(options, allowFromCache, sanitizeOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsSince", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetPostsSinceForSync(options model.GetPostsSinceForSyncOptions, cursor model.GetPostsSinceForSyncCursor, limit int) ([]*model.Post, model.GetPostsSinceForSyncCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.PostStore.GetPostsSinceForSync(options, cursor, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetPostsSinceForSync", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerPostStore) GetRepliesForExport(parentID string) ([]*model.ReplyForExport, error) {
	start := time.Now()

	result, err := s.PostStore.GetRepliesForExport(parentID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetRepliesForExport", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) GetSingle(rctx request.CTX, id string, inclDeleted bool) (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetSingle(rctx, id, inclDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.GetSingle", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) HasAutoResponsePostByUserSince(options model.GetPostsSinceOptions, userID string) (bool, error) {
	start := time.Now()

	result, err := s.PostStore.HasAutoResponsePostByUserSince(options, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.HasAutoResponsePostByUserSince", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) InvalidateLastPostTimeCache(channelID string) {
	start := time.Now()

	s.PostStore.InvalidateLastPostTimeCache(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.InvalidateLastPostTimeCache", success, elapsed)
	}
}

func (s *TimerLayerPostStore) Overwrite(rctx request.CTX, post *model.Post) (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.Overwrite(rctx, post)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Overwrite", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) OverwriteMultiple(rctx request.CTX, posts []*model.Post) ([]*model.Post, int, error) {
	start := time.Now()

	result, resultVar1, err := s.PostStore.OverwriteMultiple(rctx, posts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.OverwriteMultiple", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerPostStore) PermanentDelete(rctx request.CTX, postID string) error {
	start := time.Now()

	err := s.PostStore.PermanentDelete(rctx, postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := time.Now()

	result, err := s.PostStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.PermanentDeleteBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) PermanentDeleteBatchForRetentionPolicies(now int64, globalPolicyEndTime int64, limit int64, cursor model.RetentionPolicyCursor) (int64, model.RetentionPolicyCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.PostStore.PermanentDeleteBatchForRetentionPolicies(now, globalPolicyEndTime, limit, cursor)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.PermanentDeleteBatchForRetentionPolicies", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerPostStore) PermanentDeleteByChannel(rctx request.CTX, channelID string) error {
	start := time.Now()

	err := s.PostStore.PermanentDeleteByChannel(rctx, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.PermanentDeleteByChannel", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostStore) PermanentDeleteByUser(rctx request.CTX, userID string) error {
	start := time.Now()

	err := s.PostStore.PermanentDeleteByUser(rctx, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostStore) RefreshPostStats() error {
	start := time.Now()

	err := s.PostStore.RefreshPostStats()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.RefreshPostStats", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostStore) Save(rctx request.CTX, post *model.Post) (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.Save(rctx, post)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) SaveMultiple(rctx request.CTX, posts []*model.Post) ([]*model.Post, int, error) {
	start := time.Now()

	result, resultVar1, err := s.PostStore.SaveMultiple(rctx, posts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.SaveMultiple", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerPostStore) Search(teamID string, userID string, params *model.SearchParams) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.Search(teamID, userID, params)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) SearchPostsForUser(rctx request.CTX, paramsList []*model.SearchParams, userID string, teamID string, page int, perPage int) (*model.PostSearchResults, error) {
	start := time.Now()

	result, err := s.PostStore.SearchPostsForUser(rctx, paramsList, userID, teamID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.SearchPostsForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostStore) SetPostReminder(reminder *model.PostReminder) error {
	start := time.Now()

	err := s.PostStore.SetPostReminder(reminder)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.SetPostReminder", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostStore) Update(rctx request.CTX, newPost *model.Post, oldPost *model.Post) (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.Update(rctx, newPost, oldPost)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostAcknowledgementStore) Delete(acknowledgement *model.PostAcknowledgement) error {
	start := time.Now()

	err := s.PostAcknowledgementStore.Delete(acknowledgement)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostAcknowledgementStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostAcknowledgementStore) Get(postID string, userID string) (*model.PostAcknowledgement, error) {
	start := time.Now()

	result, err := s.PostAcknowledgementStore.Get(postID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostAcknowledgementStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostAcknowledgementStore) GetForPost(postID string) ([]*model.PostAcknowledgement, error) {
	start := time.Now()

	result, err := s.PostAcknowledgementStore.GetForPost(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostAcknowledgementStore.GetForPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostAcknowledgementStore) GetForPosts(postIds []string) ([]*model.PostAcknowledgement, error) {
	start := time.Now()

	result, err := s.PostAcknowledgementStore.GetForPosts(postIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostAcknowledgementStore.GetForPosts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostAcknowledgementStore) Save(postID string, userID string, acknowledgedAt int64) (*model.PostAcknowledgement, error) {
	start := time.Now()

	result, err := s.PostAcknowledgementStore.Save(postID, userID, acknowledgedAt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostAcknowledgementStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostPersistentNotificationStore) Delete(postIds []string) error {
	start := time.Now()

	err := s.PostPersistentNotificationStore.Delete(postIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostPersistentNotificationStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostPersistentNotificationStore) DeleteByChannel(channelIds []string) error {
	start := time.Now()

	err := s.PostPersistentNotificationStore.DeleteByChannel(channelIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostPersistentNotificationStore.DeleteByChannel", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostPersistentNotificationStore) DeleteByTeam(teamIds []string) error {
	start := time.Now()

	err := s.PostPersistentNotificationStore.DeleteByTeam(teamIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostPersistentNotificationStore.DeleteByTeam", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostPersistentNotificationStore) DeleteExpired(maxSentCount int16) error {
	start := time.Now()

	err := s.PostPersistentNotificationStore.DeleteExpired(maxSentCount)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostPersistentNotificationStore.DeleteExpired", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostPersistentNotificationStore) Get(params model.GetPersistentNotificationsPostsParams) ([]*model.PostPersistentNotifications, error) {
	start := time.Now()

	result, err := s.PostPersistentNotificationStore.Get(params)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostPersistentNotificationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostPersistentNotificationStore) GetSingle(postID string) (*model.PostPersistentNotifications, error) {
	start := time.Now()

	result, err := s.PostPersistentNotificationStore.GetSingle(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostPersistentNotificationStore.GetSingle", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostPersistentNotificationStore) UpdateLastActivity(postIds []string) error {
	start := time.Now()

	err := s.PostPersistentNotificationStore.UpdateLastActivity(postIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostPersistentNotificationStore.UpdateLastActivity", success, elapsed)
	}
	return err
}

func (s *TimerLayerPostPriorityStore) GetForPost(postID string) (*model.PostPriority, error) {
	start := time.Now()

	result, err := s.PostPriorityStore.GetForPost(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostPriorityStore.GetForPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPostPriorityStore) GetForPosts(ids []string) ([]*model.PostPriority, error) {
	start := time.Now()

	result, err := s.PostPriorityStore.GetForPosts(ids)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PostPriorityStore.GetForPosts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, error) {
	start := time.Now()

	result, err := s.PreferenceStore.CleanupFlagsBatch(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.CleanupFlagsBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) Delete(userID string, category string, name string) error {
	start := time.Now()

	err := s.PreferenceStore.Delete(userID, category, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteCategory(userID string, category string) error {
	start := time.Now()

	err := s.PreferenceStore.DeleteCategory(userID, category)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategory", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteCategoryAndName(category string, name string) error {
	start := time.Now()

	err := s.PreferenceStore.DeleteCategoryAndName(category, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategoryAndName", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteInvalidVisibleDmsGms() (int64, error) {
	start := time.Now()

	result, err := s.PreferenceStore.DeleteInvalidVisibleDmsGms()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteInvalidVisibleDmsGms", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) DeleteOrphanedRows(limit int) (int64, error) {
	start := time.Now()

	result, err := s.PreferenceStore.DeleteOrphanedRows(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteOrphanedRows", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) Get(userID string, category string, name string) (*model.Preference, error) {
	start := time.Now()

	result, err := s.PreferenceStore.Get(userID, category, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) GetAll(userID string) (model.Preferences, error) {
	start := time.Now()

	result, err := s.PreferenceStore.GetAll(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) GetCategory(userID string, category string) (model.Preferences, error) {
	start := time.Now()

	result, err := s.PreferenceStore.GetCategory(userID, category)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetCategory", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) GetCategoryAndName(category string, name string) (model.Preferences, error) {
	start := time.Now()

	result, err := s.PreferenceStore.GetCategoryAndName(category, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetCategoryAndName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) PermanentDeleteByUser(userID string) error {
	start := time.Now()

	err := s.PreferenceStore.PermanentDeleteByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) Save(preferences model.Preferences) error {
	start := time.Now()

	err := s.PreferenceStore.Save(preferences)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerProductNoticesStore) Clear(notices []string) error {
	start := time.Now()

	err := s.ProductNoticesStore.Clear(notices)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductNoticesStore.Clear", success, elapsed)
	}
	return err
}

func (s *TimerLayerProductNoticesStore) ClearOldNotices(currentNotices model.ProductNotices) error {
	start := time.Now()

	err := s.ProductNoticesStore.ClearOldNotices(currentNotices)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductNoticesStore.ClearOldNotices", success, elapsed)
	}
	return err
}

func (s *TimerLayerProductNoticesStore) GetViews(userID string) ([]model.ProductNoticeViewState, error) {
	start := time.Now()

	result, err := s.ProductNoticesStore.GetViews(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductNoticesStore.GetViews", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductNoticesStore) View(userID string, notices []string) error {
	start := time.Now()

	err := s.ProductNoticesStore.View(userID, notices)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductNoticesStore.View", success, elapsed)
	}
	return err
}

func (s *TimerLayerPropertyFieldStore) CountForGroup(groupID string, includeDeleted bool) (int64, error) {
	start := time.Now()

	result, err := s.PropertyFieldStore.CountForGroup(groupID, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyFieldStore.CountForGroup", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyFieldStore) Create(field *model.PropertyField) (*model.PropertyField, error) {
	start := time.Now()

	result, err := s.PropertyFieldStore.Create(field)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyFieldStore.Create", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyFieldStore) Delete(groupID string, id string) error {
	start := time.Now()

	err := s.PropertyFieldStore.Delete(groupID, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyFieldStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPropertyFieldStore) Get(groupID string, id string) (*model.PropertyField, error) {
	start := time.Now()

	result, err := s.PropertyFieldStore.Get(groupID, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyFieldStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyFieldStore) GetFieldByName(groupID string, targetID string, name string) (*model.PropertyField, error) {
	start := time.Now()

	result, err := s.PropertyFieldStore.GetFieldByName(groupID, targetID, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyFieldStore.GetFieldByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyFieldStore) GetMany(groupID string, ids []string) ([]*model.PropertyField, error) {
	start := time.Now()

	result, err := s.PropertyFieldStore.GetMany(groupID, ids)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyFieldStore.GetMany", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyFieldStore) SearchPropertyFields(opts model.PropertyFieldSearchOpts) ([]*model.PropertyField, error) {
	start := time.Now()

	result, err := s.PropertyFieldStore.SearchPropertyFields(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyFieldStore.SearchPropertyFields", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyFieldStore) Update(groupID string, fields []*model.PropertyField) ([]*model.PropertyField, error) {
	start := time.Now()

	result, err := s.PropertyFieldStore.Update(groupID, fields)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyFieldStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyGroupStore) Get(name string) (*model.PropertyGroup, error) {
	start := time.Now()

	result, err := s.PropertyGroupStore.Get(name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyGroupStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyGroupStore) Register(name string) (*model.PropertyGroup, error) {
	start := time.Now()

	result, err := s.PropertyGroupStore.Register(name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyGroupStore.Register", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyValueStore) Create(value *model.PropertyValue) (*model.PropertyValue, error) {
	start := time.Now()

	result, err := s.PropertyValueStore.Create(value)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyValueStore.Create", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyValueStore) Delete(groupID string, id string) error {
	start := time.Now()

	err := s.PropertyValueStore.Delete(groupID, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyValueStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPropertyValueStore) DeleteForField(id string) error {
	start := time.Now()

	err := s.PropertyValueStore.DeleteForField(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyValueStore.DeleteForField", success, elapsed)
	}
	return err
}

func (s *TimerLayerPropertyValueStore) DeleteForTarget(groupID string, targetType string, targetID string) error {
	start := time.Now()

	err := s.PropertyValueStore.DeleteForTarget(groupID, targetType, targetID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyValueStore.DeleteForTarget", success, elapsed)
	}
	return err
}

func (s *TimerLayerPropertyValueStore) Get(groupID string, id string) (*model.PropertyValue, error) {
	start := time.Now()

	result, err := s.PropertyValueStore.Get(groupID, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyValueStore) GetMany(groupID string, ids []string) ([]*model.PropertyValue, error) {
	start := time.Now()

	result, err := s.PropertyValueStore.GetMany(groupID, ids)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyValueStore.GetMany", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyValueStore) SearchPropertyValues(opts model.PropertyValueSearchOpts) ([]*model.PropertyValue, error) {
	start := time.Now()

	result, err := s.PropertyValueStore.SearchPropertyValues(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyValueStore.SearchPropertyValues", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyValueStore) Update(groupID string, values []*model.PropertyValue) ([]*model.PropertyValue, error) {
	start := time.Now()

	result, err := s.PropertyValueStore.Update(groupID, values)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyValueStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPropertyValueStore) Upsert(values []*model.PropertyValue) ([]*model.PropertyValue, error) {
	start := time.Now()

	result, err := s.PropertyValueStore.Upsert(values)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PropertyValueStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) BulkGetForPosts(postIds []string) ([]*model.Reaction, error) {
	start := time.Now()

	result, err := s.ReactionStore.BulkGetForPosts(postIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.BulkGetForPosts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) Delete(reaction *model.Reaction) (*model.Reaction, error) {
	start := time.Now()

	result, err := s.ReactionStore.Delete(reaction)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) DeleteAllWithEmojiName(emojiName string) error {
	start := time.Now()

	err := s.ReactionStore.DeleteAllWithEmojiName(emojiName)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.DeleteAllWithEmojiName", success, elapsed)
	}
	return err
}

func (s *TimerLayerReactionStore) DeleteOrphanedRowsByIds(r *model.RetentionIdsForDeletion) (int64, error) {
	start := time.Now()

	result, err := s.ReactionStore.DeleteOrphanedRowsByIds(r)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.DeleteOrphanedRowsByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) ExistsOnPost(postID string, emojiName string) (bool, error) {
	start := time.Now()

	result, err := s.ReactionStore.ExistsOnPost(postID, emojiName)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.ExistsOnPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) GetForPost(postID string, allowFromCache bool) ([]*model.Reaction, error) {
	start := time.Now()

	result, err := s.ReactionStore.GetForPost(postID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.GetForPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) GetForPostSince(postID string, since int64, excludeRemoteID string, inclDeleted bool) ([]*model.Reaction, error) {
	start := time.Now()

	result, err := s.ReactionStore.GetForPostSince(postID, since, excludeRemoteID, inclDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.GetForPostSince", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) GetSingle(userID string, postID string, remoteID string, emojiName string) (*model.Reaction, error) {
	start := time.Now()

	result, err := s.ReactionStore.GetSingle(userID, postID, remoteID, emojiName)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.GetSingle", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) GetUniqueCountForPost(postID string) (int, error) {
	start := time.Now()

	result, err := s.ReactionStore.GetUniqueCountForPost(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.GetUniqueCountForPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := time.Now()

	result, err := s.ReactionStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.PermanentDeleteBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) PermanentDeleteByUser(userID string) error {
	start := time.Now()

	err := s.ReactionStore.PermanentDeleteByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerReactionStore) Save(reaction *model.Reaction) (*model.Reaction, error) {
	start := time.Now()

	result, err := s.ReactionStore.Save(reaction)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRemoteClusterStore) Delete(remoteClusterID string) (bool, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.Delete(remoteClusterID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RemoteClusterStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRemoteClusterStore) Get(remoteClusterID string, includeDeleted bool) (*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.Get(remoteClusterID, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RemoteClusterStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRemoteClusterStore) GetAll(offset int, limit int, filter model.RemoteClusterQueryFilter) ([]*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.GetAll(offset, limit, filter)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RemoteClusterStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRemoteClusterStore) GetByPluginID(pluginID string) (*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.GetByPluginID(pluginID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RemoteClusterStore.GetByPluginID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRemoteClusterStore) Save(rc *model.RemoteCluster) (*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.Save(rc)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RemoteClusterStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRemoteClusterStore) SetLastPingAt(remoteClusterID string) error {
	start := time.Now()

	err := s.RemoteClusterStore.SetLastPingAt(remoteClusterID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RemoteClusterStore.SetLastPingAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerRemoteClusterStore) Update(rc *model.RemoteCluster) (*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.Update(rc)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RemoteClusterStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRemoteClusterStore) UpdateTopics(remoteClusterID string, topics string) (*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.UpdateTopics(remoteClusterID, topics)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RemoteClusterStore.UpdateTopics", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) AddChannels(policyID string, channelIds []string) error {
	start := time.Now()

	err := s.RetentionPolicyStore.AddChannels(policyID, channelIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.AddChannels", success, elapsed)
	}
	return err
}

func (s *TimerLayerRetentionPolicyStore) AddTeams(policyID string, teamIds []string) error {
	start := time.Now()

	err := s.RetentionPolicyStore.AddTeams(policyID, teamIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.AddTeams", success, elapsed)
	}
	return err
}

func (s *TimerLayerRetentionPolicyStore) Delete(id string) error {
	start := time.Now()

	err := s.RetentionPolicyStore.Delete(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerRetentionPolicyStore) DeleteOrphanedRows(limit int) (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.DeleteOrphanedRows(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.DeleteOrphanedRows", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) Get(id string) (*model.RetentionPolicyWithTeamAndChannelCounts, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) GetAll(offset int, limit int) ([]*model.RetentionPolicyWithTeamAndChannelCounts, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetAll(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) GetChannelPoliciesCountForUser(userID string) (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetChannelPoliciesCountForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.GetChannelPoliciesCountForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) GetChannelPoliciesForUser(userID string, offset int, limit int) ([]*model.RetentionPolicyForChannel, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetChannelPoliciesForUser(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.GetChannelPoliciesForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) GetChannels(policyID string, offset int, limit int) (model.ChannelListWithTeamData, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetChannels(policyID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.GetChannels", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) GetChannelsCount(policyID string) (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetChannelsCount(policyID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.GetChannelsCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) GetCount() (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.GetCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) GetIdsForDeletionByTableName(tableName string, limit int) ([]*model.RetentionIdsForDeletion, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetIdsForDeletionByTableName(tableName, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.GetIdsForDeletionByTableName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) GetTeamPoliciesCountForUser(userID string) (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetTeamPoliciesCountForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.GetTeamPoliciesCountForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) GetTeamPoliciesForUser(userID string, offset int, limit int) ([]*model.RetentionPolicyForTeam, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetTeamPoliciesForUser(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.GetTeamPoliciesForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) GetTeams(policyID string, offset int, limit int) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetTeams(policyID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.GetTeams", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) GetTeamsCount(policyID string) (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetTeamsCount(policyID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.GetTeamsCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) Patch(patch *model.RetentionPolicyWithTeamAndChannelIDs) (*model.RetentionPolicyWithTeamAndChannelCounts, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.Patch(patch)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.Patch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRetentionPolicyStore) RemoveChannels(policyID string, channelIds []string) error {
	start := time.Now()

	err := s.RetentionPolicyStore.RemoveChannels(policyID, channelIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.RemoveChannels", success, elapsed)
	}
	return err
}

func (s *TimerLayerRetentionPolicyStore) RemoveTeams(policyID string, teamIds []string) error {
	start := time.Now()

	err := s.RetentionPolicyStore.RemoveTeams(policyID, teamIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.RemoveTeams", success, elapsed)
	}
	return err
}

func (s *TimerLayerRetentionPolicyStore) Save(policy *model.RetentionPolicyWithTeamAndChannelIDs) (*model.RetentionPolicyWithTeamAndChannelCounts, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.Save(policy)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RetentionPolicyStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) AllChannelSchemeRoles() ([]*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.AllChannelSchemeRoles()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.AllChannelSchemeRoles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) ChannelHigherScopedPermissions(roleNames []string) (map[string]*model.RolePermissions, error) {
	start := time.Now()

	result, err := s.RoleStore.ChannelHigherScopedPermissions(roleNames)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.ChannelHigherScopedPermissions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) ChannelRolesUnderTeamRole(roleName string) ([]*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.ChannelRolesUnderTeamRole(roleName)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.ChannelRolesUnderTeamRole", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) Delete(roleID string) (*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.Delete(roleID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) Get(roleID string) (*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.Get(roleID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetAll() ([]*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.GetAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetByName(ctx context.Context, name string) (*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.GetByName(ctx, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetByNames(names []string) ([]*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.GetByNames(names)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByNames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) PermanentDeleteAll() error {
	start := time.Now()

	err := s.RoleStore.PermanentDeleteAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.PermanentDeleteAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerRoleStore) Save(role *model.Role) (*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.Save(role)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerScheduledPostStore) CreateScheduledPost(scheduledPost *model.ScheduledPost) (*model.ScheduledPost, error) {
	start := time.Now()

	result, err := s.ScheduledPostStore.CreateScheduledPost(scheduledPost)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ScheduledPostStore.CreateScheduledPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerScheduledPostStore) Get(scheduledPostId string) (*model.ScheduledPost, error) {
	start := time.Now()

	result, err := s.ScheduledPostStore.Get(scheduledPostId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ScheduledPostStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerScheduledPostStore) GetMaxMessageSize() int {
	start := time.Now()

	result := s.ScheduledPostStore.GetMaxMessageSize()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ScheduledPostStore.GetMaxMessageSize", success, elapsed)
	}
	return result
}

func (s *TimerLayerScheduledPostStore) GetPendingScheduledPosts(beforeTime int64, afterTime int64, lastScheduledPostId string, perPage uint64) ([]*model.ScheduledPost, error) {
	start := time.Now()

	result, err := s.ScheduledPostStore.GetPendingScheduledPosts(beforeTime, afterTime, lastScheduledPostId, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ScheduledPostStore.GetPendingScheduledPosts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerScheduledPostStore) GetScheduledPostsForUser(userId string, teamId string) ([]*model.ScheduledPost, error) {
	start := time.Now()

	result, err := s.ScheduledPostStore.GetScheduledPostsForUser(userId, teamId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ScheduledPostStore.GetScheduledPostsForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerScheduledPostStore) PermanentDeleteByUser(userId string) error {
	start := time.Now()

	err := s.ScheduledPostStore.PermanentDeleteByUser(userId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ScheduledPostStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerScheduledPostStore) PermanentlyDeleteScheduledPosts(scheduledPostIDs []string) error {
	start := time.Now()

	err := s.ScheduledPostStore.PermanentlyDeleteScheduledPosts(scheduledPostIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ScheduledPostStore.PermanentlyDeleteScheduledPosts", success, elapsed)
	}
	return err
}

func (s *TimerLayerScheduledPostStore) UpdateOldScheduledPosts(beforeTime int64) error {
	start := time.Now()

	err := s.ScheduledPostStore.UpdateOldScheduledPosts(beforeTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ScheduledPostStore.UpdateOldScheduledPosts", success, elapsed)
	}
	return err
}

func (s *TimerLayerScheduledPostStore) UpdatedScheduledPost(scheduledPost *model.ScheduledPost) error {
	start := time.Now()

	err := s.ScheduledPostStore.UpdatedScheduledPost(scheduledPost)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ScheduledPostStore.UpdatedScheduledPost", success, elapsed)
	}
	return err
}

func (s *TimerLayerSchemeStore) CountByScope(scope string) (int64, error) {
	start := time.Now()

	result, err := s.SchemeStore.CountByScope(scope)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.CountByScope", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) CountWithoutPermission(scope string, permissionID string, roleScope model.RoleScope, roleType model.RoleType) (int64, error) {
	start := time.Now()

	result, err := s.SchemeStore.CountWithoutPermission(scope, permissionID, roleScope, roleType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.CountWithoutPermission", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) Delete(schemeID string) (*model.Scheme, error) {
	start := time.Now()

	result, err := s.SchemeStore.Delete(schemeID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) Get(schemeID string) (*model.Scheme, error) {
	start := time.Now()

	result, err := s.SchemeStore.Get(schemeID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) GetAllPage(scope string, offset int, limit int) ([]*model.Scheme, error) {
	start := time.Now()

	result, err := s.SchemeStore.GetAllPage(scope, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.GetAllPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) GetByName(schemeName string) (*model.Scheme, error) {
	start := time.Now()

	result, err := s.SchemeStore.GetByName(schemeName)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) PermanentDeleteAll() error {
	start := time.Now()

	err := s.SchemeStore.PermanentDeleteAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.PermanentDeleteAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerSchemeStore) Save(scheme *model.Scheme) (*model.Scheme, error) {
	start := time.Now()

	result, err := s.SchemeStore.Save(scheme)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) AnalyticsSessionCount() (int64, error) {
	start := time.Now()

	result, err := s.SessionStore.AnalyticsSessionCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.AnalyticsSessionCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) Cleanup(expiryTime int64, batchSize int64) error {
	start := time.Now()

	err := s.SessionStore.Cleanup(expiryTime, batchSize)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Cleanup", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) Get(c request.CTX, sessionIDOrToken string) (*model.Session, error) {
	start := time.Now()

	result, err := s.SessionStore.Get(c, sessionIDOrToken)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetLRUSessions(c request.CTX, userID string, limit uint64, offset uint64) ([]*model.Session, error) {
	start := time.Now()

	result, err := s.SessionStore.GetLRUSessions(c, userID, limit, offset)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetLRUSessions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetMobileSessionMetadata() ([]*model.MobileSessionMetadata, error) {
	start := time.Now()

	result, err := s.SessionStore.GetMobileSessionMetadata()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetMobileSessionMetadata", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessions(c request.CTX, userID string) ([]*model.Session, error) {
	start := time.Now()

	result, err := s.SessionStore.GetSessions(c, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessionsExpired(thresholdMillis int64, mobileOnly bool, unnotifiedOnly bool) ([]*model.Session, error) {
	start := time.Now()

	result, err := s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessionsExpired", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessionsWithActiveDeviceIds(userID string) ([]*model.Session, error) {
	start := time.Now()

	result, err := s.SessionStore.GetSessionsWithActiveDeviceIds(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessionsWithActiveDeviceIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) PermanentDeleteSessionsByUser(teamID string) error {
	start := time.Now()

	err := s.SessionStore.PermanentDeleteSessionsByUser(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.PermanentDeleteSessionsByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) Remove(sessionIDOrToken string) error {
	start := time.Now()

	err := s.SessionStore.Remove(sessionIDOrToken)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Remove", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) RemoveAllSessions() error {
	start := time.Now()

	err := s.SessionStore.RemoveAllSessions()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.RemoveAllSessions", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) Save(c request.CTX, session *model.Session) (*model.Session, error) {
	start := time.Now()

	result, err := s.SessionStore.Save(c, session)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) UpdateDeviceId(id string, deviceID string, expiresAt int64) (string, error) {
	start := time.Now()

	result, err := s.SessionStore.UpdateDeviceId(id, deviceID, expiresAt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateDeviceId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) UpdateExpiredNotify(sessionid string, notified bool) error {
	start := time.Now()

	err := s.SessionStore.UpdateExpiredNotify(sessionid, notified)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateExpiredNotify", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateExpiresAt(sessionID string, timestamp int64) error {
	start := time.Now()

	err := s.SessionStore.UpdateExpiresAt(sessionID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateExpiresAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateLastActivityAt(sessionID string, timestamp int64) error {
	start := time.Now()

	err := s.SessionStore.UpdateLastActivityAt(sessionID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateLastActivityAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateProps(session *model.Session) error {
	start := time.Now()

	err := s.SessionStore.UpdateProps(session)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateProps", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateRoles(userID string, roles string) (string, error) {
	start := time.Now()

	result, err := s.SessionStore.UpdateRoles(userID, roles)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateRoles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) Delete(channelID string) (bool, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.Delete(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) DeleteRemote(remoteID string) (bool, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.DeleteRemote(remoteID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.DeleteRemote", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) Get(channelID string) (*model.SharedChannel, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.Get(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) GetAll(offset int, limit int, opts model.SharedChannelFilterOpts) ([]*model.SharedChannel, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetAll(offset, limit, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) GetAllCount(opts model.SharedChannelFilterOpts) (int64, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetAllCount(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.GetAllCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) GetAttachment(fileID string, remoteID string) (*model.SharedChannelAttachment, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetAttachment(fileID, remoteID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.GetAttachment", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) GetRemote(id string) (*model.SharedChannelRemote, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetRemote(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.GetRemote", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) GetRemoteByIds(channelID string, remoteID string) (*model.SharedChannelRemote, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetRemoteByIds(channelID, remoteID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.GetRemoteByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) GetRemoteForUser(remoteID string, userID string) (*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetRemoteForUser(remoteID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.GetRemoteForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) GetRemotes(offset int, limit int, opts model.SharedChannelRemoteFilterOpts) ([]*model.SharedChannelRemote, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetRemotes(offset, limit, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.GetRemotes", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) GetRemotesStatus(channelID string) ([]*model.SharedChannelRemoteStatus, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetRemotesStatus(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.GetRemotesStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) GetSingleUser(userID string, channelID string, remoteID string) (*model.SharedChannelUser, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetSingleUser(userID, channelID, remoteID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.GetSingleUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) GetUsersForSync(filter model.GetUsersForSyncFilter) ([]*model.User, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetUsersForSync(filter)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.GetUsersForSync", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) GetUsersForUser(userID string) ([]*model.SharedChannelUser, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetUsersForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.GetUsersForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) HasChannel(channelID string) (bool, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.HasChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.HasChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) HasRemote(channelID string, remoteID string) (bool, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.HasRemote(channelID, remoteID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.HasRemote", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) Save(sc *model.SharedChannel) (*model.SharedChannel, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.Save(sc)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) SaveAttachment(remote *model.SharedChannelAttachment) (*model.SharedChannelAttachment, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.SaveAttachment(remote)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.SaveAttachment", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) SaveRemote(remote *model.SharedChannelRemote) (*model.SharedChannelRemote, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.SaveRemote(remote)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.SaveRemote", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) SaveUser(remote *model.SharedChannelUser) (*model.SharedChannelUser, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.SaveUser(remote)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.SaveUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) Update(sc *model.SharedChannel) (*model.SharedChannel, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.Update(sc)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) UpdateAttachmentLastSyncAt(id string, syncTime int64) error {
	start := time.Now()

	err := s.SharedChannelStore.UpdateAttachmentLastSyncAt(id, syncTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.UpdateAttachmentLastSyncAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSharedChannelStore) UpdateRemote(remote *model.SharedChannelRemote) (*model.SharedChannelRemote, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.UpdateRemote(remote)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.UpdateRemote", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSharedChannelStore) UpdateRemoteCursor(id string, cursor model.GetPostsSinceForSyncCursor) error {
	start := time.Now()

	err := s.SharedChannelStore.UpdateRemoteCursor(id, cursor)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.UpdateRemoteCursor", success, elapsed)
	}
	return err
}

func (s *TimerLayerSharedChannelStore) UpdateUserLastSyncAt(userID string, channelID string, remoteID string) error {
	start := time.Now()

	err := s.SharedChannelStore.UpdateUserLastSyncAt(userID, channelID, remoteID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.UpdateUserLastSyncAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSharedChannelStore) UpsertAttachment(remote *model.SharedChannelAttachment) (string, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.UpsertAttachment(remote)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SharedChannelStore.UpsertAttachment", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) Get(userID string) (*model.Status, error) {
	start := time.Now()

	result, err := s.StatusStore.Get(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) GetByIds(userIds []string) ([]*model.Status, error) {
	start := time.Now()

	result, err := s.StatusStore.GetByIds(userIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) GetTotalActiveUsersCount() (int64, error) {
	start := time.Now()

	result, err := s.StatusStore.GetTotalActiveUsersCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetTotalActiveUsersCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) ResetAll() error {
	start := time.Now()

	err := s.StatusStore.ResetAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.ResetAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerStatusStore) SaveOrUpdate(status *model.Status) error {
	start := time.Now()

	err := s.StatusStore.SaveOrUpdate(status)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.SaveOrUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerStatusStore) UpdateExpiredDNDStatuses() ([]*model.Status, error) {
	start := time.Now()

	result, err := s.StatusStore.UpdateExpiredDNDStatuses()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.UpdateExpiredDNDStatuses", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) UpdateLastActivityAt(userID string, lastActivityAt int64) error {
	start := time.Now()

	err := s.StatusStore.UpdateLastActivityAt(userID, lastActivityAt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.UpdateLastActivityAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) Get() (model.StringMap, error) {
	start := time.Now()

	result, err := s.SystemStore.Get()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) GetByName(name string) (*model.System, error) {
	start := time.Now()

	result, err := s.SystemStore.GetByName(name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) InsertIfExists(system *model.System) (*model.System, error) {
	start := time.Now()

	result, err := s.SystemStore.InsertIfExists(system)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.InsertIfExists", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) PermanentDeleteByName(name string) (*model.System, error) {
	start := time.Now()

	result, err := s.SystemStore.PermanentDeleteByName(name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.PermanentDeleteByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) Save(system *model.System) error {
	start := time.Now()

	err := s.SystemStore.Save(system)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) SaveOrUpdate(system *model.System) error {
	start := time.Now()

	err := s.SystemStore.SaveOrUpdate(system)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.SaveOrUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) Update(system *model.System) error {
	start := time.Now()

	err := s.SystemStore.Update(system)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Update", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) AnalyticsGetTeamCountForScheme(schemeID string) (int64, error) {
	start := time.Now()

	result, err := s.TeamStore.AnalyticsGetTeamCountForScheme(schemeID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.AnalyticsGetTeamCountForScheme", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) AnalyticsTeamCount(opts *model.TeamSearch) (int64, error) {
	start := time.Now()

	result, err := s.TeamStore.AnalyticsTeamCount(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.AnalyticsTeamCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) ClearAllCustomRoleAssignments() error {
	start := time.Now()

	err := s.TeamStore.ClearAllCustomRoleAssignments()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.ClearAllCustomRoleAssignments", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) ClearCaches() {
	start := time.Now()

	s.TeamStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerTeamStore) Get(id string) (*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetActiveMemberCount(teamID string, restrictions *model.ViewUsersRestrictions) (int64, error) {
	start := time.Now()

	result, err := s.TeamStore.GetActiveMemberCount(teamID, restrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetActiveMemberCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAll() ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAllForExportAfter(limit int, afterID string) ([]*model.TeamForExport, error) {
	start := time.Now()

	result, err := s.TeamStore.GetAllForExportAfter(limit, afterID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAllForExportAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAllPage(offset int, limit int, opts *model.TeamSearch) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetAllPage(offset, limit, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAllPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAllPrivateTeamListing() ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetAllPrivateTeamListing()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAllPrivateTeamListing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAllTeamListing() ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetAllTeamListing()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAllTeamListing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetByEmptyInviteID() ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetByEmptyInviteID()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetByEmptyInviteID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetByInviteId(inviteID string) (*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetByInviteId(inviteID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetByInviteId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetByName(name string) (*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetByName(name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetByNames(name []string) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetByNames(name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetByNames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetChannelUnreadsForAllTeams(excludeTeamID string, userID string) ([]*model.ChannelUnread, error) {
	start := time.Now()

	result, err := s.TeamStore.GetChannelUnreadsForAllTeams(excludeTeamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetChannelUnreadsForAllTeams", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetChannelUnreadsForTeam(teamID string, userID string) ([]*model.ChannelUnread, error) {
	start := time.Now()

	result, err := s.TeamStore.GetChannelUnreadsForTeam(teamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetChannelUnreadsForTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetCommonTeamIDsForMultipleUsers(userIDs []string) ([]string, error) {
	start := time.Now()

	result, err := s.TeamStore.GetCommonTeamIDsForMultipleUsers(userIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetCommonTeamIDsForMultipleUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetCommonTeamIDsForTwoUsers(userID string, otherUserID string) ([]string, error) {
	start := time.Now()

	result, err := s.TeamStore.GetCommonTeamIDsForTwoUsers(userID, otherUserID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetCommonTeamIDsForTwoUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetMany(ids []string) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetMany(ids)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetMany", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetMember(c request.CTX, teamID string, userID string) (*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.GetMember(c, teamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetMembers(teamID string, offset int, limit int, teamMembersGetOptions *model.TeamMembersGetOptions) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.GetMembers(teamID, offset, limit, teamMembersGetOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetMembersByIds(teamID string, userIds []string, restrictions *model.ViewUsersRestrictions) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.GetMembersByIds(teamID, userIds, restrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetMembersByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTeamMembersForExport(userID string) ([]*model.TeamMemberForExport, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTeamMembersForExport(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTeamMembersForExport", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTeamsByScheme(schemeID string, offset int, limit int) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTeamsByScheme(schemeID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTeamsByScheme", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTeamsByUserId(userID string) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTeamsByUserId(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTeamsByUserId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTeamsForUser(c request.CTX, userID string, excludeTeamID string, includeDeleted bool) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTeamsForUser(c, userID, excludeTeamID, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTeamsForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTeamsForUserWithPagination(userID string, page int, perPage int) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTeamsForUserWithPagination(userID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTeamsForUserWithPagination", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTotalMemberCount(teamID string, restrictions *model.ViewUsersRestrictions) (int64, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTotalMemberCount(teamID, restrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTotalMemberCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetUserTeamIds(userID string, allowFromCache bool) ([]string, error) {
	start := time.Now()

	result, err := s.TeamStore.GetUserTeamIds(userID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetUserTeamIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GroupSyncedTeamCount() (int64, error) {
	start := time.Now()

	result, err := s.TeamStore.GroupSyncedTeamCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GroupSyncedTeamCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) InvalidateAllTeamIdsForUser(userID string) {
	start := time.Now()

	s.TeamStore.InvalidateAllTeamIdsForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.InvalidateAllTeamIdsForUser", success, elapsed)
	}
}

func (s *TimerLayerTeamStore) MigrateTeamMembers(fromTeamID string, fromUserID string) (map[string]string, error) {
	start := time.Now()

	result, err := s.TeamStore.MigrateTeamMembers(fromTeamID, fromUserID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.MigrateTeamMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) PermanentDelete(teamID string) error {
	start := time.Now()

	err := s.TeamStore.PermanentDelete(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) RemoveAllMembersByTeam(teamID string) error {
	start := time.Now()

	err := s.TeamStore.RemoveAllMembersByTeam(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.RemoveAllMembersByTeam", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) RemoveAllMembersByUser(ctx request.CTX, userID string) error {
	start := time.Now()

	err := s.TeamStore.RemoveAllMembersByUser(ctx, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.RemoveAllMembersByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) RemoveMember(rctx request.CTX, teamID string, userID string) error {
	start := time.Now()

	err := s.TeamStore.RemoveMember(rctx, teamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.RemoveMember", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) RemoveMembers(rctx request.CTX, teamID string, userIds []string) error {
	start := time.Now()

	err := s.TeamStore.RemoveMembers(rctx, teamID, userIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.RemoveMembers", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) ResetAllTeamSchemes() error {
	start := time.Now()

	err := s.TeamStore.ResetAllTeamSchemes()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.ResetAllTeamSchemes", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) Save(team *model.Team) (*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.Save(team)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) SaveMember(rctx request.CTX, member *model.TeamMember, maxUsersPerTeam int) (*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.SaveMember(rctx, member, maxUsersPerTeam)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SaveMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) SaveMultipleMembers(members []*model.TeamMember, maxUsersPerTeam int) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.SaveMultipleMembers(members, maxUsersPerTeam)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SaveMultipleMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) SearchAll(opts *model.TeamSearch) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.SearchAll(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SearchAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) SearchAllPaged(opts *model.TeamSearch) ([]*model.Team, int64, error) {
	start := time.Now()

	result, resultVar1, err := s.TeamStore.SearchAllPaged(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SearchAllPaged", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerTeamStore) SearchOpen(opts *model.TeamSearch) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.SearchOpen(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SearchOpen", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) SearchPrivate(opts *model.TeamSearch) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.SearchPrivate(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SearchPrivate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) Update(team *model.Team) (*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.Update(team)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) UpdateLastTeamIconUpdate(teamID string, curTime int64) error {
	start := time.Now()

	err := s.TeamStore.UpdateLastTeamIconUpdate(teamID, curTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.UpdateLastTeamIconUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) UpdateMember(rctx request.CTX, member *model.TeamMember) (*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.UpdateMember(rctx, member)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.UpdateMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) UpdateMembersRole(teamID string, adminIDs []string) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.UpdateMembersRole(teamID, adminIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.UpdateMembersRole", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) UpdateMultipleMembers(members []*model.TeamMember) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.UpdateMultipleMembers(members)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.UpdateMultipleMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) UserBelongsToTeams(userID string, teamIds []string) (bool, error) {
	start := time.Now()

	result, err := s.TeamStore.UserBelongsToTeams(userID, teamIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.UserBelongsToTeams", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) Get(id string, allowFromCache bool) (*model.TermsOfService, error) {
	start := time.Now()

	result, err := s.TermsOfServiceStore.Get(id, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) GetLatest(allowFromCache bool) (*model.TermsOfService, error) {
	start := time.Now()

	result, err := s.TermsOfServiceStore.GetLatest(allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.GetLatest", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) Save(termsOfService *model.TermsOfService) (*model.TermsOfService, error) {
	start := time.Now()

	result, err := s.TermsOfServiceStore.Save(termsOfService)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) DeleteMembershipForUser(userID string, postID string) error {
	start := time.Now()

	err := s.ThreadStore.DeleteMembershipForUser(userID, postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.DeleteMembershipForUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerThreadStore) DeleteMembershipsForChannel(userID string, channelID string) error {
	start := time.Now()

	err := s.ThreadStore.DeleteMembershipsForChannel(userID, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.DeleteMembershipsForChannel", success, elapsed)
	}
	return err
}

func (s *TimerLayerThreadStore) DeleteOrphanedRows(limit int) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.DeleteOrphanedRows(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.DeleteOrphanedRows", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) Get(id string) (*model.Thread, error) {
	start := time.Now()

	result, err := s.ThreadStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetMembershipForUser(userID string, postID string) (*model.ThreadMembership, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetMembershipForUser(userID, postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetMembershipForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetMembershipsForUser(userID string, teamID string) ([]*model.ThreadMembership, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetMembershipsForUser(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetMembershipsForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetTeamsUnreadForUser(userID string, teamIDs []string, includeUrgentMentionCount bool) (map[string]*model.TeamUnread, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTeamsUnreadForUser(userID, teamIDs, includeUrgentMentionCount)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetTeamsUnreadForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetThreadFollowers(threadID string, fetchOnlyActive bool) ([]string, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetThreadFollowers(threadID, fetchOnlyActive)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetThreadFollowers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetThreadForUser(threadMembership *model.ThreadMembership, extended bool, postPriorityIsEnabled bool) (*model.ThreadResponse, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetThreadForUser(threadMembership, extended, postPriorityIsEnabled)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetThreadForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetThreadMembershipsForExport(postID string) ([]*model.ThreadMembershipForExport, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetThreadMembershipsForExport(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetThreadMembershipsForExport", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetThreadUnreadReplyCount(threadMembership *model.ThreadMembership) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetThreadUnreadReplyCount(threadMembership)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetThreadUnreadReplyCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetThreadsForUser(userID string, teamID string, opts model.GetUserThreadsOpts) ([]*model.ThreadResponse, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetThreadsForUser(userID, teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetThreadsForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetTotalThreads(userID string, teamID string, opts model.GetUserThreadsOpts) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTotalThreads(userID, teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetTotalThreads", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetTotalUnreadMentions(userID string, teamID string, opts model.GetUserThreadsOpts) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTotalUnreadMentions(userID, teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetTotalUnreadMentions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetTotalUnreadThreads(userID string, teamID string, opts model.GetUserThreadsOpts) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTotalUnreadThreads(userID, teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetTotalUnreadThreads", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) GetTotalUnreadUrgentMentions(userID string, teamID string, opts model.GetUserThreadsOpts) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTotalUnreadUrgentMentions(userID, teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.GetTotalUnreadUrgentMentions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) MaintainMembership(userID string, postID string, opts store.ThreadMembershipOpts) (*model.ThreadMembership, error) {
	start := time.Now()

	result, err := s.ThreadStore.MaintainMembership(userID, postID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.MaintainMembership", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) MaintainMultipleFromImport(memberships []*model.ThreadMembership) ([]*model.ThreadMembership, error) {
	start := time.Now()

	result, err := s.ThreadStore.MaintainMultipleFromImport(memberships)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.MaintainMultipleFromImport", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) MarkAllAsRead(userID string, threadIds []string) error {
	start := time.Now()

	err := s.ThreadStore.MarkAllAsRead(userID, threadIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.MarkAllAsRead", success, elapsed)
	}
	return err
}

func (s *TimerLayerThreadStore) MarkAllAsReadByChannels(userID string, channelIDs []string) error {
	start := time.Now()

	err := s.ThreadStore.MarkAllAsReadByChannels(userID, channelIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.MarkAllAsReadByChannels", success, elapsed)
	}
	return err
}

func (s *TimerLayerThreadStore) MarkAllAsReadByTeam(userID string, teamID string) error {
	start := time.Now()

	err := s.ThreadStore.MarkAllAsReadByTeam(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.MarkAllAsReadByTeam", success, elapsed)
	}
	return err
}

func (s *TimerLayerThreadStore) MarkAsRead(userID string, threadID string, timestamp int64) error {
	start := time.Now()

	err := s.ThreadStore.MarkAsRead(userID, threadID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.MarkAsRead", success, elapsed)
	}
	return err
}

func (s *TimerLayerThreadStore) PermanentDeleteBatchForRetentionPolicies(now int64, globalPolicyEndTime int64, limit int64, cursor model.RetentionPolicyCursor) (int64, model.RetentionPolicyCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.ThreadStore.PermanentDeleteBatchForRetentionPolicies(now, globalPolicyEndTime, limit, cursor)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.PermanentDeleteBatchForRetentionPolicies", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerThreadStore) PermanentDeleteBatchThreadMembershipsForRetentionPolicies(now int64, globalPolicyEndTime int64, limit int64, cursor model.RetentionPolicyCursor) (int64, model.RetentionPolicyCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.ThreadStore.PermanentDeleteBatchThreadMembershipsForRetentionPolicies(now, globalPolicyEndTime, limit, cursor)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.PermanentDeleteBatchThreadMembershipsForRetentionPolicies", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerThreadStore) SaveMultipleMemberships(memberships []*model.ThreadMembership) ([]*model.ThreadMembership, error) {
	start := time.Now()

	result, err := s.ThreadStore.SaveMultipleMemberships(memberships)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.SaveMultipleMemberships", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) UpdateMembership(membership *model.ThreadMembership) (*model.ThreadMembership, error) {
	start := time.Now()

	result, err := s.ThreadStore.UpdateMembership(membership)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.UpdateMembership", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerThreadStore) UpdateTeamIdForChannelThreads(channelId string, teamId string) error {
	start := time.Now()

	err := s.ThreadStore.UpdateTeamIdForChannelThreads(channelId, teamId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ThreadStore.UpdateTeamIdForChannelThreads", success, elapsed)
	}
	return err
}

func (s *TimerLayerTokenStore) Cleanup(expiryTime int64) {
	start := time.Now()

	s.TokenStore.Cleanup(expiryTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerTokenStore) Delete(token string) error {
	start := time.Now()

	err := s.TokenStore.Delete(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerTokenStore) GetAllTokensByType(tokenType string) ([]*model.Token, error) {
	start := time.Now()

	result, err := s.TokenStore.GetAllTokensByType(tokenType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.GetAllTokensByType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) GetByToken(token string) (*model.Token, error) {
	start := time.Now()

	result, err := s.TokenStore.GetByToken(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.GetByToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) RemoveAllTokensByType(tokenType string) error {
	start := time.Now()

	err := s.TokenStore.RemoveAllTokensByType(tokenType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.RemoveAllTokensByType", success, elapsed)
	}
	return err
}

func (s *TimerLayerTokenStore) Save(recovery *model.Token) error {
	start := time.Now()

	err := s.TokenStore.Save(recovery)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerUploadSessionStore) Delete(id string) error {
	start := time.Now()

	err := s.UploadSessionStore.Delete(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUploadSessionStore) Get(c request.CTX, id string) (*model.UploadSession, error) {
	start := time.Now()

	result, err := s.UploadSessionStore.Get(c, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) GetForUser(userID string) ([]*model.UploadSession, error) {
	start := time.Now()

	result, err := s.UploadSessionStore.GetForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.GetForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) Save(session *model.UploadSession) (*model.UploadSession, error) {
	start := time.Now()

	result, err := s.UploadSessionStore.Save(session)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) Update(session *model.UploadSession) error {
	start := time.Now()

	err := s.UploadSessionStore.Update(session)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Update", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) AnalyticsActiveCount(timestamp int64, options model.UserCountOptions) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsActiveCount(timestamp, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsActiveCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsActiveCountForPeriod(startTime int64, endTime int64, options model.UserCountOptions) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsActiveCountForPeriod(startTime, endTime, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsActiveCountForPeriod", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetExternalUsers(hostDomain string) (bool, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsGetExternalUsers(hostDomain)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetExternalUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetGuestCount() (int64, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsGetGuestCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetGuestCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetInactiveUsersCount() (int64, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsGetInactiveUsersCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetInactiveUsersCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetSystemAdminCount() (int64, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsGetSystemAdminCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetSystemAdminCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AutocompleteUsersInChannel(rctx request.CTX, teamID string, channelID string, term string, options *model.UserSearchOptions) (*model.UserAutocompleteInChannel, error) {
	start := time.Now()

	result, err := s.UserStore.AutocompleteUsersInChannel(rctx, teamID, channelID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AutocompleteUsersInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) ClearAllCustomRoleAssignments() error {
	start := time.Now()

	err := s.UserStore.ClearAllCustomRoleAssignments()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearAllCustomRoleAssignments", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) ClearCaches() {
	start := time.Now()

	s.UserStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerUserStore) Count(options model.UserCountOptions) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.Count(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) DeactivateGuests() ([]string, error) {
	start := time.Now()

	result, err := s.UserStore.DeactivateGuests()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.DeactivateGuests", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) DemoteUserToGuest(userID string) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.DemoteUserToGuest(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.DemoteUserToGuest", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Get(ctx context.Context, id string) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.Get(ctx, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAll() ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllAfter(limit int, afterID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAllAfter(limit, afterID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllNotInAuthService(authServices []string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAllNotInAuthService(authServices)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllNotInAuthService", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllProfiles(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAllProfiles(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllProfilesInChannel(ctx context.Context, channelID string, allowFromCache bool) (map[string]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAllProfilesInChannel(ctx, channelID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllProfilesInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllUsingAuthService(authService string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAllUsingAuthService(authService)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllUsingAuthService", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAnyUnreadPostCountForChannel(userID string, channelID string) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.GetAnyUnreadPostCountForChannel(userID, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAnyUnreadPostCountForChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByAuth(authData *string, authService string) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetByAuth(authData, authService)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByAuth", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByEmail(email string) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetByEmail(email)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByEmail", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByRemoteID(remoteID string) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetByRemoteID(remoteID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByRemoteID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByUsername(username string) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetByUsername(username)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByUsername", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetChannelGroupUsers(channelID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetChannelGroupUsers(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetChannelGroupUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetEtagForAllProfiles() string {
	start := time.Now()

	result := s.UserStore.GetEtagForAllProfiles()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForAllProfiles", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetEtagForProfiles(teamID string) string {
	start := time.Now()

	result := s.UserStore.GetEtagForProfiles(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForProfiles", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetEtagForProfilesNotInTeam(teamID string) string {
	start := time.Now()

	result := s.UserStore.GetEtagForProfilesNotInTeam(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForProfilesNotInTeam", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetForLogin(loginID string, allowSignInWithUsername bool, allowSignInWithEmail bool) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetForLogin(loginID, allowSignInWithUsername, allowSignInWithEmail)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetForLogin", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetKnownUsers(userID string) ([]string, error) {
	start := time.Now()

	result, err := s.UserStore.GetKnownUsers(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetKnownUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetMany(ctx context.Context, ids []string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetMany(ctx, ids)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetMany", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetMfaUsedTimestamps(userID string) ([]int, error) {
	start := time.Now()

	result, err := s.UserStore.GetMfaUsedTimestamps(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetMfaUsedTimestamps", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetNewUsersForTeam(teamID string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetNewUsersForTeam(teamID, offset, limit, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetNewUsersForTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfileByGroupChannelIdsForUser(userID string, channelIds []string) (map[string][]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfileByGroupChannelIdsForUser(userID, channelIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfileByGroupChannelIdsForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfileByIds(ctx context.Context, userIds []string, options *store.UserGetByIdsOpts, allowFromCache bool) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfileByIds(ctx, userIds, options, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfileByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfiles(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfiles(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesByUsernames(usernames []string, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesByUsernames(usernames, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesByUsernames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesInChannel(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesInChannel(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesInChannelByAdmin(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesInChannelByAdmin(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesInChannelByAdmin", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesInChannelByStatus(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesInChannelByStatus(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesInChannelByStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesNotInChannel(teamID string, channelID string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesNotInChannel(teamID, channelID, groupConstrained, offset, limit, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesNotInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesNotInTeam(teamID string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesNotInTeam(teamID, groupConstrained, offset, limit, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesNotInTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesWithoutTeam(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesWithoutTeam(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesWithoutTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetRecentlyActiveUsersForTeam(teamID string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetRecentlyActiveUsersForTeam(teamID, offset, limit, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetRecentlyActiveUsersForTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetSystemAdminProfiles() (map[string]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetSystemAdminProfiles()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetSystemAdminProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetTeamGroupUsers(teamID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetTeamGroupUsers(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetTeamGroupUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUnreadCount(userID string, isCRTEnabled bool) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.GetUnreadCount(userID, isCRTEnabled)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUnreadCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUnreadCountForChannel(userID string, channelID string) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.GetUnreadCountForChannel(userID, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUnreadCountForChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUserCountForReport(filter *model.UserReportOptions) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.GetUserCountForReport(filter)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUserCountForReport", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUserReport(filter *model.UserReportOptions) ([]*model.UserReportQuery, error) {
	start := time.Now()

	result, err := s.UserStore.GetUserReport(filter)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUserReport", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUsersBatchForIndexing(startTime int64, startFileID string, limit int) ([]*model.UserForIndexing, error) {
	start := time.Now()

	result, err := s.UserStore.GetUsersBatchForIndexing(startTime, startFileID, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUsersBatchForIndexing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUsersWithInvalidEmails(page int, perPage int, restrictedDomains string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetUsersWithInvalidEmails(page, perPage, restrictedDomains)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUsersWithInvalidEmails", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) InferSystemInstallDate() (int64, error) {
	start := time.Now()

	result, err := s.UserStore.InferSystemInstallDate()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InferSystemInstallDate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) InsertUsers(users []*model.User) error {
	start := time.Now()

	err := s.UserStore.InsertUsers(users)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InsertUsers", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) InvalidateProfileCacheForUser(userID string) {
	start := time.Now()

	s.UserStore.InvalidateProfileCacheForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfileCacheForUser", success, elapsed)
	}
}

func (s *TimerLayerUserStore) InvalidateProfilesInChannelCache(channelID string) {
	start := time.Now()

	s.UserStore.InvalidateProfilesInChannelCache(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfilesInChannelCache", success, elapsed)
	}
}

func (s *TimerLayerUserStore) InvalidateProfilesInChannelCacheByUser(userID string) {
	start := time.Now()

	s.UserStore.InvalidateProfilesInChannelCacheByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfilesInChannelCacheByUser", success, elapsed)
	}
}

func (s *TimerLayerUserStore) IsEmpty(excludeBots bool) (bool, error) {
	start := time.Now()

	result, err := s.UserStore.IsEmpty(excludeBots)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.IsEmpty", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) PermanentDelete(rctx request.CTX, userID string) error {
	start := time.Now()

	err := s.UserStore.PermanentDelete(rctx, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) PromoteGuestToUser(userID string) error {
	start := time.Now()

	err := s.UserStore.PromoteGuestToUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.PromoteGuestToUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) RefreshPostStatsForUsers() error {
	start := time.Now()

	err := s.UserStore.RefreshPostStatsForUsers()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.RefreshPostStatsForUsers", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) ResetAuthDataToEmailForUsers(service string, userIDs []string, includeDeleted bool, dryRun bool) (int, error) {
	start := time.Now()

	result, err := s.UserStore.ResetAuthDataToEmailForUsers(service, userIDs, includeDeleted, dryRun)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ResetAuthDataToEmailForUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) ResetLastPictureUpdate(userID string) error {
	start := time.Now()

	err := s.UserStore.ResetLastPictureUpdate(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ResetLastPictureUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) Save(rctx request.CTX, user *model.User) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.Save(rctx, user)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Search(rctx request.CTX, teamID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.Search(rctx, teamID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) SearchInChannel(channelID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchInChannel(channelID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.SearchInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) SearchInGroup(groupID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchInGroup(groupID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.SearchInGroup", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) SearchNotInChannel(teamID string, channelID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchNotInChannel(teamID, channelID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.SearchNotInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) SearchNotInGroup(groupID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchNotInGroup(groupID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.SearchNotInGroup", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) SearchNotInTeam(notInTeamID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchNotInTeam(notInTeamID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.SearchNotInTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) SearchWithoutTeam(term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchWithoutTeam(term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.SearchWithoutTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) StoreMfaUsedTimestamps(userID string, ts []int) error {
	start := time.Now()

	err := s.UserStore.StoreMfaUsedTimestamps(userID, ts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.StoreMfaUsedTimestamps", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) Update(rctx request.CTX, user *model.User, allowRoleUpdate bool) (*model.UserUpdate, error) {
	start := time.Now()

	result, err := s.UserStore.Update(rctx, user, allowRoleUpdate)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) UpdateAuthData(userID string, service string, authData *string, email string, resetMfa bool) (string, error) {
	start := time.Now()

	result, err := s.UserStore.UpdateAuthData(userID, service, authData, email, resetMfa)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateAuthData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) UpdateFailedPasswordAttempts(userID string, attempts int) error {
	start := time.Now()

	err := s.UserStore.UpdateFailedPasswordAttempts(userID, attempts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateFailedPasswordAttempts", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateLastLogin(userID string, lastLogin int64) error {
	start := time.Now()

	err := s.UserStore.UpdateLastLogin(userID, lastLogin)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateLastLogin", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateLastPictureUpdate(userID string) error {
	start := time.Now()

	err := s.UserStore.UpdateLastPictureUpdate(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateLastPictureUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateMfaActive(userID string, active bool) error {
	start := time.Now()

	err := s.UserStore.UpdateMfaActive(userID, active)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaActive", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateMfaSecret(userID string, secret string) error {
	start := time.Now()

	err := s.UserStore.UpdateMfaSecret(userID, secret)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaSecret", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateNotifyProps(userID string, props map[string]string) error {
	start := time.Now()

	err := s.UserStore.UpdateNotifyProps(userID, props)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateNotifyProps", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdatePassword(userID string, newPassword string) error {
	start := time.Now()

	err := s.UserStore.UpdatePassword(userID, newPassword)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdatePassword", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateUpdateAt(userID string) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.UpdateUpdateAt(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateUpdateAt", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) VerifyEmail(userID string, email string) (string, error) {
	start := time.Now()

	result, err := s.UserStore.VerifyEmail(userID, email)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.VerifyEmail", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Delete(tokenID string) error {
	start := time.Now()

	err := s.UserAccessTokenStore.Delete(tokenID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) DeleteAllForUser(userID string) error {
	start := time.Now()

	err := s.UserAccessTokenStore.DeleteAllForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.DeleteAllForUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) Get(tokenID string) (*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.Get(tokenID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetAll(offset int, limit int) ([]*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.GetAll(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetByToken(tokenString string) (*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.GetByToken(tokenString)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetByToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetByUser(userID string, page int, perPage int) ([]*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.GetByUser(userID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Save(token *model.UserAccessToken) (*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.Save(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Search(term string) ([]*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.Search(term)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenDisable(tokenID string) error {
	start := time.Now()

	err := s.UserAccessTokenStore.UpdateTokenDisable(tokenID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenDisable", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenEnable(tokenID string) error {
	start := time.Now()

	err := s.UserAccessTokenStore.UpdateTokenEnable(tokenID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenEnable", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserTermsOfServiceStore) Delete(userID string, termsOfServiceID string) error {
	start := time.Now()

	err := s.UserTermsOfServiceStore.Delete(userID, termsOfServiceID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermsOfServiceStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserTermsOfServiceStore) GetByUser(userID string) (*model.UserTermsOfService, error) {
	start := time.Now()

	result, err := s.UserTermsOfServiceStore.GetByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermsOfServiceStore.GetByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserTermsOfServiceStore) Save(userTermsOfService *model.UserTermsOfService) (*model.UserTermsOfService, error) {
	start := time.Now()

	result, err := s.UserTermsOfServiceStore.Save(userTermsOfService)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermsOfServiceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) AnalyticsIncomingCount(teamID string, userID string) (int64, error) {
	start := time.Now()

	result, err := s.WebhookStore.AnalyticsIncomingCount(teamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.AnalyticsIncomingCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) AnalyticsOutgoingCount(teamID string) (int64, error) {
	start := time.Now()

	result, err := s.WebhookStore.AnalyticsOutgoingCount(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.AnalyticsOutgoingCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) ClearCaches() {
	start := time.Now()

	s.WebhookStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerWebhookStore) DeleteIncoming(webhookID string, timestamp int64) error {
	start := time.Now()

	err := s.WebhookStore.DeleteIncoming(webhookID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.DeleteIncoming", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) DeleteOutgoing(webhookID string, timestamp int64) error {
	start := time.Now()

	err := s.WebhookStore.DeleteOutgoing(webhookID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.DeleteOutgoing", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) GetIncoming(id string, allowFromCache bool) (*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncoming(id, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncoming", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetIncomingByChannel(channelID string) ([]*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncomingByChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingByChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetIncomingByTeam(teamID string, offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncomingByTeam(teamID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingByTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetIncomingByTeamByUser(teamID string, userID string, offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncomingByTeamByUser(teamID, userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingByTeamByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetIncomingList(offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncomingList(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingList", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetIncomingListByUser(userID string, offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncomingListByUser(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingListByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoing(id string) (*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoing(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingByChannel(channelID string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingByChannel(channelID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingByChannelByUser(channelID string, userID string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingByChannelByUser(channelID, userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByChannelByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingByTeam(teamID string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingByTeam(teamID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingByTeamByUser(teamID string, userID string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingByTeamByUser(teamID, userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByTeamByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingList(offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingList(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingList", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingListByUser(userID string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingListByUser(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingListByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) InvalidateWebhookCache(webhook string) {
	start := time.Now()

	s.WebhookStore.InvalidateWebhookCache(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.InvalidateWebhookCache", success, elapsed)
	}
}

func (s *TimerLayerWebhookStore) PermanentDeleteIncomingByChannel(channelID string) error {
	start := time.Now()

	err := s.WebhookStore.PermanentDeleteIncomingByChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteIncomingByChannel", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) PermanentDeleteIncomingByUser(userID string) error {
	start := time.Now()

	err := s.WebhookStore.PermanentDeleteIncomingByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteIncomingByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) PermanentDeleteOutgoingByChannel(channelID string) error {
	start := time.Now()

	err := s.WebhookStore.PermanentDeleteOutgoingByChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteOutgoingByChannel", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) PermanentDeleteOutgoingByUser(userID string) error {
	start := time.Now()

	err := s.WebhookStore.PermanentDeleteOutgoingByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteOutgoingByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) SaveIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.SaveIncoming(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.SaveIncoming", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) SaveOutgoing(webhook *model.OutgoingWebhook) (*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.SaveOutgoing(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.SaveOutgoing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) UpdateIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.UpdateIncoming(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.UpdateIncoming", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) UpdateOutgoing(hook *model.OutgoingWebhook) (*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.UpdateOutgoing(hook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.UpdateOutgoing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayer) Close() {
	s.Store.Close()
}

func (s *TimerLayer) DropAllTables() {
	s.Store.DropAllTables()
}

func (s *TimerLayer) LockToMaster() {
	s.Store.LockToMaster()
}

func (s *TimerLayer) MarkSystemRanUnitTests() {
	s.Store.MarkSystemRanUnitTests()
}

func (s *TimerLayer) SetContext(context context.Context) {
	s.Store.SetContext(context)
}

func (s *TimerLayer) TotalMasterDbConnections() int {
	return s.Store.TotalMasterDbConnections()
}

func (s *TimerLayer) TotalReadDbConnections() int {
	return s.Store.TotalReadDbConnections()
}

func (s *TimerLayer) TotalSearchDbConnections() int {
	return s.Store.TotalSearchDbConnections()
}

func (s *TimerLayer) UnlockFromMaster() {
	s.Store.UnlockFromMaster()
}

func New(childStore store.Store, metrics einterfaces.MetricsInterface) *TimerLayer {
	newStore := TimerLayer{
		Store:   childStore,
		Metrics: metrics,
	}

	newStore.AccessControlPolicyStore = &TimerLayerAccessControlPolicyStore{AccessControlPolicyStore: childStore.AccessControlPolicy(), Root: &newStore}
	newStore.AttributesStore = &TimerLayerAttributesStore{AttributesStore: childStore.Attributes(), Root: &newStore}
	newStore.AuditStore = &TimerLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
	newStore.BotStore = &TimerLayerBotStore{BotStore: childStore.Bot(), Root: &newStore}
	newStore.ChannelStore = &TimerLayerChannelStore{ChannelStore: childStore.Channel(), Root: &newStore}
	newStore.ChannelBookmarkStore = &TimerLayerChannelBookmarkStore{ChannelBookmarkStore: childStore.ChannelBookmark(), Root: &newStore}
	newStore.ChannelMemberHistoryStore = &TimerLayerChannelMemberHistoryStore{ChannelMemberHistoryStore: childStore.ChannelMemberHistory(), Root: &newStore}
	newStore.ClusterDiscoveryStore = &TimerLayerClusterDiscoveryStore{ClusterDiscoveryStore: childStore.ClusterDiscovery(), Root: &newStore}
	newStore.CommandStore = &TimerLayerCommandStore{CommandStore: childStore.Command(), Root: &newStore}
	newStore.CommandWebhookStore = &TimerLayerCommandWebhookStore{CommandWebhookStore: childStore.CommandWebhook(), Root: &newStore}
	newStore.ComplianceStore = &TimerLayerComplianceStore{ComplianceStore: childStore.Compliance(), Root: &newStore}
	newStore.DesktopTokensStore = &TimerLayerDesktopTokensStore{DesktopTokensStore: childStore.DesktopTokens(), Root: &newStore}
	newStore.DraftStore = &TimerLayerDraftStore{DraftStore: childStore.Draft(), Root: &newStore}
	newStore.EmojiStore = &TimerLayerEmojiStore{EmojiStore: childStore.Emoji(), Root: &newStore}
	newStore.FileInfoStore = &TimerLayerFileInfoStore{FileInfoStore: childStore.FileInfo(), Root: &newStore}
	newStore.GroupStore = &TimerLayerGroupStore{GroupStore: childStore.Group(), Root: &newStore}
	newStore.JobStore = &TimerLayerJobStore{JobStore: childStore.Job(), Root: &newStore}
	newStore.LicenseStore = &TimerLayerLicenseStore{LicenseStore: childStore.License(), Root: &newStore}
	newStore.LinkMetadataStore = &TimerLayerLinkMetadataStore{LinkMetadataStore: childStore.LinkMetadata(), Root: &newStore}
	newStore.NotifyAdminStore = &TimerLayerNotifyAdminStore{NotifyAdminStore: childStore.NotifyAdmin(), Root: &newStore}
	newStore.OAuthStore = &TimerLayerOAuthStore{OAuthStore: childStore.OAuth(), Root: &newStore}
	newStore.OutgoingOAuthConnectionStore = &TimerLayerOutgoingOAuthConnectionStore{OutgoingOAuthConnectionStore: childStore.OutgoingOAuthConnection(), Root: &newStore}
	newStore.PluginStore = &TimerLayerPluginStore{PluginStore: childStore.Plugin(), Root: &newStore}
	newStore.PostStore = &TimerLayerPostStore{PostStore: childStore.Post(), Root: &newStore}
	newStore.PostAcknowledgementStore = &TimerLayerPostAcknowledgementStore{PostAcknowledgementStore: childStore.PostAcknowledgement(), Root: &newStore}
	newStore.PostPersistentNotificationStore = &TimerLayerPostPersistentNotificationStore{PostPersistentNotificationStore: childStore.PostPersistentNotification(), Root: &newStore}
	newStore.PostPriorityStore = &TimerLayerPostPriorityStore{PostPriorityStore: childStore.PostPriority(), Root: &newStore}
	newStore.PreferenceStore = &TimerLayerPreferenceStore{PreferenceStore: childStore.Preference(), Root: &newStore}
	newStore.ProductNoticesStore = &TimerLayerProductNoticesStore{ProductNoticesStore: childStore.ProductNotices(), Root: &newStore}
	newStore.PropertyFieldStore = &TimerLayerPropertyFieldStore{PropertyFieldStore: childStore.PropertyField(), Root: &newStore}
	newStore.PropertyGroupStore = &TimerLayerPropertyGroupStore{PropertyGroupStore: childStore.PropertyGroup(), Root: &newStore}
	newStore.PropertyValueStore = &TimerLayerPropertyValueStore{PropertyValueStore: childStore.PropertyValue(), Root: &newStore}
	newStore.ReactionStore = &TimerLayerReactionStore{ReactionStore: childStore.Reaction(), Root: &newStore}
	newStore.RemoteClusterStore = &TimerLayerRemoteClusterStore{RemoteClusterStore: childStore.RemoteCluster(), Root: &newStore}
	newStore.RetentionPolicyStore = &TimerLayerRetentionPolicyStore{RetentionPolicyStore: childStore.RetentionPolicy(), Root: &newStore}
	newStore.RoleStore = &TimerLayerRoleStore{RoleStore: childStore.Role(), Root: &newStore}
	newStore.ScheduledPostStore = &TimerLayerScheduledPostStore{ScheduledPostStore: childStore.ScheduledPost(), Root: &newStore}
	newStore.SchemeStore = &TimerLayerSchemeStore{SchemeStore: childStore.Scheme(), Root: &newStore}
	newStore.SessionStore = &TimerLayerSessionStore{SessionStore: childStore.Session(), Root: &newStore}
	newStore.SharedChannelStore = &TimerLayerSharedChannelStore{SharedChannelStore: childStore.SharedChannel(), Root: &newStore}
	newStore.StatusStore = &TimerLayerStatusStore{StatusStore: childStore.Status(), Root: &newStore}
	newStore.SystemStore = &TimerLayerSystemStore{SystemStore: childStore.System(), Root: &newStore}
	newStore.TeamStore = &TimerLayerTeamStore{TeamStore: childStore.Team(), Root: &newStore}
	newStore.TermsOfServiceStore = &TimerLayerTermsOfServiceStore{TermsOfServiceStore: childStore.TermsOfService(), Root: &newStore}
	newStore.ThreadStore = &TimerLayerThreadStore{ThreadStore: childStore.Thread(), Root: &newStore}
	newStore.TokenStore = &TimerLayerTokenStore{TokenStore: childStore.Token(), Root: &newStore}
	newStore.UploadSessionStore = &TimerLayerUploadSessionStore{UploadSessionStore: childStore.UploadSession(), Root: &newStore}
	newStore.UserStore = &TimerLayerUserStore{UserStore: childStore.User(), Root: &newStore}
	newStore.UserAccessTokenStore = &TimerLayerUserAccessTokenStore{UserAccessTokenStore: childStore.UserAccessToken(), Root: &newStore}
	newStore.UserTermsOfServiceStore = &TimerLayerUserTermsOfServiceStore{UserTermsOfServiceStore: childStore.UserTermsOfService(), Root: &newStore}
	newStore.WebhookStore = &TimerLayerWebhookStore{WebhookStore: childStore.Webhook(), Root: &newStore}
	return &newStore
}
