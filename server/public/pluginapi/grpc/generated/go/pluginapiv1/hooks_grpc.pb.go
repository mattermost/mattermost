// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.4
// source: hooks.proto

package pluginapiv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PluginHooks_Implemented_FullMethodName                         = "/mattermost.pluginapi.v1.PluginHooks/Implemented"
	PluginHooks_OnActivate_FullMethodName                          = "/mattermost.pluginapi.v1.PluginHooks/OnActivate"
	PluginHooks_OnDeactivate_FullMethodName                        = "/mattermost.pluginapi.v1.PluginHooks/OnDeactivate"
	PluginHooks_OnConfigurationChange_FullMethodName               = "/mattermost.pluginapi.v1.PluginHooks/OnConfigurationChange"
	PluginHooks_OnInstall_FullMethodName                           = "/mattermost.pluginapi.v1.PluginHooks/OnInstall"
	PluginHooks_OnSendDailyTelemetry_FullMethodName                = "/mattermost.pluginapi.v1.PluginHooks/OnSendDailyTelemetry"
	PluginHooks_RunDataRetention_FullMethodName                    = "/mattermost.pluginapi.v1.PluginHooks/RunDataRetention"
	PluginHooks_OnCloudLimitsUpdated_FullMethodName                = "/mattermost.pluginapi.v1.PluginHooks/OnCloudLimitsUpdated"
	PluginHooks_ConfigurationWillBeSaved_FullMethodName            = "/mattermost.pluginapi.v1.PluginHooks/ConfigurationWillBeSaved"
	PluginHooks_MessageWillBePosted_FullMethodName                 = "/mattermost.pluginapi.v1.PluginHooks/MessageWillBePosted"
	PluginHooks_MessageWillBeUpdated_FullMethodName                = "/mattermost.pluginapi.v1.PluginHooks/MessageWillBeUpdated"
	PluginHooks_MessageHasBeenPosted_FullMethodName                = "/mattermost.pluginapi.v1.PluginHooks/MessageHasBeenPosted"
	PluginHooks_MessageHasBeenUpdated_FullMethodName               = "/mattermost.pluginapi.v1.PluginHooks/MessageHasBeenUpdated"
	PluginHooks_MessagesWillBeConsumed_FullMethodName              = "/mattermost.pluginapi.v1.PluginHooks/MessagesWillBeConsumed"
	PluginHooks_MessageHasBeenDeleted_FullMethodName               = "/mattermost.pluginapi.v1.PluginHooks/MessageHasBeenDeleted"
	PluginHooks_FileWillBeUploaded_FullMethodName                  = "/mattermost.pluginapi.v1.PluginHooks/FileWillBeUploaded"
	PluginHooks_ReactionHasBeenAdded_FullMethodName                = "/mattermost.pluginapi.v1.PluginHooks/ReactionHasBeenAdded"
	PluginHooks_ReactionHasBeenRemoved_FullMethodName              = "/mattermost.pluginapi.v1.PluginHooks/ReactionHasBeenRemoved"
	PluginHooks_NotificationWillBePushed_FullMethodName            = "/mattermost.pluginapi.v1.PluginHooks/NotificationWillBePushed"
	PluginHooks_EmailNotificationWillBeSent_FullMethodName         = "/mattermost.pluginapi.v1.PluginHooks/EmailNotificationWillBeSent"
	PluginHooks_PreferencesHaveChanged_FullMethodName              = "/mattermost.pluginapi.v1.PluginHooks/PreferencesHaveChanged"
	PluginHooks_UserHasBeenCreated_FullMethodName                  = "/mattermost.pluginapi.v1.PluginHooks/UserHasBeenCreated"
	PluginHooks_UserWillLogIn_FullMethodName                       = "/mattermost.pluginapi.v1.PluginHooks/UserWillLogIn"
	PluginHooks_UserHasLoggedIn_FullMethodName                     = "/mattermost.pluginapi.v1.PluginHooks/UserHasLoggedIn"
	PluginHooks_UserHasBeenDeactivated_FullMethodName              = "/mattermost.pluginapi.v1.PluginHooks/UserHasBeenDeactivated"
	PluginHooks_OnSAMLLogin_FullMethodName                         = "/mattermost.pluginapi.v1.PluginHooks/OnSAMLLogin"
	PluginHooks_ChannelHasBeenCreated_FullMethodName               = "/mattermost.pluginapi.v1.PluginHooks/ChannelHasBeenCreated"
	PluginHooks_UserHasJoinedChannel_FullMethodName                = "/mattermost.pluginapi.v1.PluginHooks/UserHasJoinedChannel"
	PluginHooks_UserHasLeftChannel_FullMethodName                  = "/mattermost.pluginapi.v1.PluginHooks/UserHasLeftChannel"
	PluginHooks_UserHasJoinedTeam_FullMethodName                   = "/mattermost.pluginapi.v1.PluginHooks/UserHasJoinedTeam"
	PluginHooks_UserHasLeftTeam_FullMethodName                     = "/mattermost.pluginapi.v1.PluginHooks/UserHasLeftTeam"
	PluginHooks_ExecuteCommand_FullMethodName                      = "/mattermost.pluginapi.v1.PluginHooks/ExecuteCommand"
	PluginHooks_OnWebSocketConnect_FullMethodName                  = "/mattermost.pluginapi.v1.PluginHooks/OnWebSocketConnect"
	PluginHooks_OnWebSocketDisconnect_FullMethodName               = "/mattermost.pluginapi.v1.PluginHooks/OnWebSocketDisconnect"
	PluginHooks_WebSocketMessageHasBeenPosted_FullMethodName       = "/mattermost.pluginapi.v1.PluginHooks/WebSocketMessageHasBeenPosted"
	PluginHooks_OnPluginClusterEvent_FullMethodName                = "/mattermost.pluginapi.v1.PluginHooks/OnPluginClusterEvent"
	PluginHooks_OnSharedChannelsSyncMsg_FullMethodName             = "/mattermost.pluginapi.v1.PluginHooks/OnSharedChannelsSyncMsg"
	PluginHooks_OnSharedChannelsPing_FullMethodName                = "/mattermost.pluginapi.v1.PluginHooks/OnSharedChannelsPing"
	PluginHooks_OnSharedChannelsAttachmentSyncMsg_FullMethodName   = "/mattermost.pluginapi.v1.PluginHooks/OnSharedChannelsAttachmentSyncMsg"
	PluginHooks_OnSharedChannelsProfileImageSyncMsg_FullMethodName = "/mattermost.pluginapi.v1.PluginHooks/OnSharedChannelsProfileImageSyncMsg"
	PluginHooks_GenerateSupportData_FullMethodName                 = "/mattermost.pluginapi.v1.PluginHooks/GenerateSupportData"
	PluginHooks_ServeHTTP_FullMethodName                           = "/mattermost.pluginapi.v1.PluginHooks/ServeHTTP"
)

// PluginHooksClient is the client API for PluginHooks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// PluginHooks is the gRPC service for invoking plugin hooks.
// The server acts as the gRPC client, calling into the plugin process.
// The plugin acts as the gRPC server, implementing the hook handlers.
type PluginHooksClient interface {
	// Implemented returns the list of hooks that the plugin implements.
	// Called during plugin startup to optimize hook dispatch.
	// Plugins that don't implement this are assumed to implement all hooks.
	//
	// Go signature: Implemented() ([]string, error)
	Implemented(ctx context.Context, in *ImplementedRequest, opts ...grpc.CallOption) (*ImplementedResponse, error)
	// OnActivate is invoked when the plugin is activated.
	// If an error is returned, the plugin will be terminated.
	// The plugin will not receive hooks until after OnActivate returns without error.
	// OnConfigurationChange will be called once before OnActivate.
	//
	// Go signature: OnActivate() error
	OnActivate(ctx context.Context, in *OnActivateRequest, opts ...grpc.CallOption) (*OnActivateResponse, error)
	// OnDeactivate is invoked when the plugin is deactivated.
	// This is the plugin's last chance to use the API.
	// The plugin will be terminated shortly after this invocation.
	//
	// Go signature: OnDeactivate() error
	OnDeactivate(ctx context.Context, in *OnDeactivateRequest, opts ...grpc.CallOption) (*OnDeactivateResponse, error)
	// OnConfigurationChange is invoked when configuration changes may have been made.
	// Any returned error is logged but does not stop the plugin.
	// It is called once before OnActivate.
	//
	// Go signature: OnConfigurationChange() error
	OnConfigurationChange(ctx context.Context, in *OnConfigurationChangeRequest, opts ...grpc.CallOption) (*OnConfigurationChangeResponse, error)
	// OnInstall is invoked after the installation of a plugin as part of onboarding.
	// It's called on every installation, not only once.
	//
	// Go signature: OnInstall(c *Context, event model.OnInstallEvent) error
	OnInstall(ctx context.Context, in *OnInstallRequest, opts ...grpc.CallOption) (*OnInstallResponse, error)
	// OnSendDailyTelemetry is invoked when the server sends daily telemetry data.
	// Plugins can use this to send their own telemetry metrics.
	//
	// Go signature: OnSendDailyTelemetry()
	OnSendDailyTelemetry(ctx context.Context, in *OnSendDailyTelemetryRequest, opts ...grpc.CallOption) (*OnSendDailyTelemetryResponse, error)
	// RunDataRetention is invoked during a DataRetentionJob.
	// Plugins should delete data older than their retention policy.
	//
	// Go signature: RunDataRetention(nowTime, batchSize int64) (int64, error)
	RunDataRetention(ctx context.Context, in *RunDataRetentionRequest, opts ...grpc.CallOption) (*RunDataRetentionResponse, error)
	// OnCloudLimitsUpdated is invoked when cloud product limits change.
	// For example, when plan tiers change affecting storage or message limits.
	//
	// Go signature: OnCloudLimitsUpdated(limits *model.ProductLimits)
	OnCloudLimitsUpdated(ctx context.Context, in *OnCloudLimitsUpdatedRequest, opts ...grpc.CallOption) (*OnCloudLimitsUpdatedResponse, error)
	// ConfigurationWillBeSaved is invoked before saving configuration to the backing store.
	// An error can be returned to reject the operation.
	// Additionally, a new config object can be returned to be stored in place of the provided one.
	//
	// Go signature: ConfigurationWillBeSaved(newCfg *model.Config) (*model.Config, error)
	ConfigurationWillBeSaved(ctx context.Context, in *ConfigurationWillBeSavedRequest, opts ...grpc.CallOption) (*ConfigurationWillBeSavedResponse, error)
	// MessageWillBePosted is invoked when a message is posted before it is committed
	// to the database. Use this to modify or reject posts before they are saved.
	//
	// Return values:
	// - To allow unchanged: return nil post and empty string
	// - To modify: return modified post and empty string
	// - To reject: return nil post and rejection reason string
	// - To dismiss silently: return nil post and "plugin.message_will_be_posted.dismiss_post"
	//
	// Go signature: MessageWillBePosted(c *Context, post *model.Post) (*model.Post, string)
	MessageWillBePosted(ctx context.Context, in *MessageWillBePostedRequest, opts ...grpc.CallOption) (*MessageWillBePostedResponse, error)
	// MessageWillBeUpdated is invoked when a message is updated before it is committed
	// to the database. Use this to modify or reject post updates.
	//
	// Return values:
	// - To allow unchanged: return nil post and empty string
	// - To modify: return modified post and empty string
	// - To reject: return nil post and rejection reason (post stays unchanged)
	//
	// Go signature: MessageWillBeUpdated(c *Context, newPost, oldPost *model.Post) (*model.Post, string)
	MessageWillBeUpdated(ctx context.Context, in *MessageWillBeUpdatedRequest, opts ...grpc.CallOption) (*MessageWillBeUpdatedResponse, error)
	// MessageHasBeenPosted is invoked after the message has been committed to the database.
	// This is a notification hook - you cannot modify or reject the post.
	// Use MessageWillBePosted if you need to modify or reject.
	//
	// Go signature: MessageHasBeenPosted(c *Context, post *model.Post)
	MessageHasBeenPosted(ctx context.Context, in *MessageHasBeenPostedRequest, opts ...grpc.CallOption) (*MessageHasBeenPostedResponse, error)
	// MessageHasBeenUpdated is invoked after a message update has been committed to the database.
	// This is a notification hook - you cannot modify or reject the update.
	// Use MessageWillBeUpdated if you need to modify or reject.
	//
	// Go signature: MessageHasBeenUpdated(c *Context, newPost, oldPost *model.Post)
	MessageHasBeenUpdated(ctx context.Context, in *MessageHasBeenUpdatedRequest, opts ...grpc.CallOption) (*MessageHasBeenUpdatedResponse, error)
	// MessagesWillBeConsumed is invoked when messages are requested by a client
	// before they are returned. Use this to filter or modify posts before delivery.
	//
	// Note: This hook has no Context parameter and no error return.
	//
	// Go signature: MessagesWillBeConsumed(posts []*model.Post) []*model.Post
	MessagesWillBeConsumed(ctx context.Context, in *MessagesWillBeConsumedRequest, opts ...grpc.CallOption) (*MessagesWillBeConsumedResponse, error)
	// MessageHasBeenDeleted is invoked after a message has been deleted from the database.
	// This is a notification hook - you cannot undo the deletion.
	//
	// Go signature: MessageHasBeenDeleted(c *Context, post *model.Post)
	MessageHasBeenDeleted(ctx context.Context, in *MessageHasBeenDeletedRequest, opts ...grpc.CallOption) (*MessageHasBeenDeletedResponse, error)
	// FileWillBeUploaded is invoked when a file is uploaded before it is committed
	// to storage. Use this to modify or reject file uploads.
	//
	// Note: Phase 8 will add streaming support. Currently uses bytes for file content.
	//
	// Return values:
	// - To allow unchanged: return nil FileInfo, empty bytes, empty string
	// - To modify: return modified FileInfo and/or content, empty string
	// - To reject: return nil FileInfo, empty bytes, and rejection reason
	//
	// Go signature: FileWillBeUploaded(c *Context, info *model.FileInfo, file io.Reader, output io.Writer) (*model.FileInfo, string)
	FileWillBeUploaded(ctx context.Context, in *FileWillBeUploadedRequest, opts ...grpc.CallOption) (*FileWillBeUploadedResponse, error)
	// ReactionHasBeenAdded is invoked after a reaction has been committed to the database.
	// This is a notification hook.
	//
	// Go signature: ReactionHasBeenAdded(c *Context, reaction *model.Reaction)
	ReactionHasBeenAdded(ctx context.Context, in *ReactionHasBeenAddedRequest, opts ...grpc.CallOption) (*ReactionHasBeenAddedResponse, error)
	// ReactionHasBeenRemoved is invoked after a reaction has been removed from the database.
	// This is a notification hook.
	//
	// Go signature: ReactionHasBeenRemoved(c *Context, reaction *model.Reaction)
	ReactionHasBeenRemoved(ctx context.Context, in *ReactionHasBeenRemovedRequest, opts ...grpc.CallOption) (*ReactionHasBeenRemovedResponse, error)
	// NotificationWillBePushed is invoked before a push notification is sent to
	// the push notification server. Use this to modify or reject push notifications.
	//
	// Note: This hook has no Context parameter.
	//
	// Return values:
	// - To allow unchanged: return nil notification and empty string
	// - To modify: return modified notification and empty string
	// - To reject: return nil notification and rejection reason
	//
	// Go signature: NotificationWillBePushed(pushNotification *model.PushNotification, userID string) (*model.PushNotification, string)
	NotificationWillBePushed(ctx context.Context, in *NotificationWillBePushedRequest, opts ...grpc.CallOption) (*NotificationWillBePushedResponse, error)
	// EmailNotificationWillBeSent is invoked before an email notification is sent.
	// Use this to customize email content or reject the notification.
	//
	// Note: Core identifiers (PostId, ChannelId, etc.) are immutable.
	// Only content fields (subject, title, message, etc.) can be modified.
	// Note: This hook has no Context parameter.
	//
	// Return values:
	// - To allow unchanged: return nil content and empty string
	// - To modify: return modified EmailNotificationContent and empty string
	// - To reject: return nil content and rejection reason
	//
	// Go signature: EmailNotificationWillBeSent(emailNotification *model.EmailNotification) (*model.EmailNotificationContent, string)
	EmailNotificationWillBeSent(ctx context.Context, in *EmailNotificationWillBeSentRequest, opts ...grpc.CallOption) (*EmailNotificationWillBeSentResponse, error)
	// PreferencesHaveChanged is invoked after one or more of a user's preferences
	// have changed. This is a notification hook.
	//
	// Go signature: PreferencesHaveChanged(c *Context, preferences []model.Preference)
	PreferencesHaveChanged(ctx context.Context, in *PreferencesHaveChangedRequest, opts ...grpc.CallOption) (*PreferencesHaveChangedResponse, error)
	// UserHasBeenCreated is invoked after a user was created.
	// This is a notification hook - you cannot modify or reject the creation.
	//
	// Go signature: UserHasBeenCreated(c *Context, user *model.User)
	UserHasBeenCreated(ctx context.Context, in *UserHasBeenCreatedRequest, opts ...grpc.CallOption) (*UserHasBeenCreatedResponse, error)
	// UserWillLogIn is invoked before the login of the user is returned.
	// Return a non-empty string to reject the login.
	// If you don't need to reject the login event, see UserHasLoggedIn.
	//
	// Go signature: UserWillLogIn(c *Context, user *model.User) string
	UserWillLogIn(ctx context.Context, in *UserWillLogInRequest, opts ...grpc.CallOption) (*UserWillLogInResponse, error)
	// UserHasLoggedIn is invoked after a user has logged in.
	// This is a notification hook - you cannot modify or reject the login.
	//
	// Go signature: UserHasLoggedIn(c *Context, user *model.User)
	UserHasLoggedIn(ctx context.Context, in *UserHasLoggedInRequest, opts ...grpc.CallOption) (*UserHasLoggedInResponse, error)
	// UserHasBeenDeactivated is invoked when a user is deactivated.
	// This is a notification hook.
	//
	// Go signature: UserHasBeenDeactivated(c *Context, user *model.User)
	UserHasBeenDeactivated(ctx context.Context, in *UserHasBeenDeactivatedRequest, opts ...grpc.CallOption) (*UserHasBeenDeactivatedResponse, error)
	// OnSAMLLogin is invoked after a successful SAML login.
	// Return an error to reject the login.
	//
	// Go signature: OnSAMLLogin(c *Context, user *model.User, assertion *saml2.AssertionInfo) error
	OnSAMLLogin(ctx context.Context, in *OnSAMLLoginRequest, opts ...grpc.CallOption) (*OnSAMLLoginResponse, error)
	// ChannelHasBeenCreated is invoked after a channel has been created.
	// This is a notification hook - you cannot modify or reject the creation.
	//
	// Go signature: ChannelHasBeenCreated(c *Context, channel *model.Channel)
	ChannelHasBeenCreated(ctx context.Context, in *ChannelHasBeenCreatedRequest, opts ...grpc.CallOption) (*ChannelHasBeenCreatedResponse, error)
	// UserHasJoinedChannel is invoked after a user has joined a channel.
	// This is a notification hook. The actor is optional (nil if self-join).
	//
	// Go signature: UserHasJoinedChannel(c *Context, channelMember *model.ChannelMember, actor *model.User)
	UserHasJoinedChannel(ctx context.Context, in *UserHasJoinedChannelRequest, opts ...grpc.CallOption) (*UserHasJoinedChannelResponse, error)
	// UserHasLeftChannel is invoked after a user has left a channel.
	// This is a notification hook. The actor is optional (nil if self-removal).
	//
	// Go signature: UserHasLeftChannel(c *Context, channelMember *model.ChannelMember, actor *model.User)
	UserHasLeftChannel(ctx context.Context, in *UserHasLeftChannelRequest, opts ...grpc.CallOption) (*UserHasLeftChannelResponse, error)
	// UserHasJoinedTeam is invoked after a user has joined a team.
	// This is a notification hook. The actor is optional (nil if self-join).
	//
	// Go signature: UserHasJoinedTeam(c *Context, teamMember *model.TeamMember, actor *model.User)
	UserHasJoinedTeam(ctx context.Context, in *UserHasJoinedTeamRequest, opts ...grpc.CallOption) (*UserHasJoinedTeamResponse, error)
	// UserHasLeftTeam is invoked after a user has left a team.
	// This is a notification hook. The actor is optional (nil if self-removal).
	//
	// Go signature: UserHasLeftTeam(c *Context, teamMember *model.TeamMember, actor *model.User)
	UserHasLeftTeam(ctx context.Context, in *UserHasLeftTeamRequest, opts ...grpc.CallOption) (*UserHasLeftTeamResponse, error)
	// ExecuteCommand executes a registered slash command.
	//
	// Go signature: ExecuteCommand(c *Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError)
	ExecuteCommand(ctx context.Context, in *ExecuteCommandRequest, opts ...grpc.CallOption) (*ExecuteCommandResponse, error)
	// OnWebSocketConnect is invoked when a new WebSocket connection is opened.
	// This is a notification hook with no Context parameter.
	//
	// Go signature: OnWebSocketConnect(webConnID, userID string)
	OnWebSocketConnect(ctx context.Context, in *OnWebSocketConnectRequest, opts ...grpc.CallOption) (*OnWebSocketConnectResponse, error)
	// OnWebSocketDisconnect is invoked when a WebSocket connection is closed.
	// This is a notification hook with no Context parameter.
	//
	// Go signature: OnWebSocketDisconnect(webConnID, userID string)
	OnWebSocketDisconnect(ctx context.Context, in *OnWebSocketDisconnectRequest, opts ...grpc.CallOption) (*OnWebSocketDisconnectResponse, error)
	// WebSocketMessageHasBeenPosted is invoked when a WebSocket message is received.
	// This is a notification hook with no Context parameter.
	//
	// Go signature: WebSocketMessageHasBeenPosted(webConnID, userID string, req *model.WebSocketRequest)
	WebSocketMessageHasBeenPosted(ctx context.Context, in *WebSocketMessageHasBeenPostedRequest, opts ...grpc.CallOption) (*WebSocketMessageHasBeenPostedResponse, error)
	// OnPluginClusterEvent is invoked when an intra-cluster plugin event is received.
	// Used for communication between plugin instances in a High-Availability cluster.
	// This is a notification hook.
	//
	// Go signature: OnPluginClusterEvent(c *Context, ev model.PluginClusterEvent)
	OnPluginClusterEvent(ctx context.Context, in *OnPluginClusterEventRequest, opts ...grpc.CallOption) (*OnPluginClusterEventResponse, error)
	// OnSharedChannelsSyncMsg is invoked when a shared channels sync message is received.
	// Plugins can use this to synchronize data with remote clusters.
	//
	// Go signature: OnSharedChannelsSyncMsg(msg *model.SyncMsg, rc *model.RemoteCluster) (model.SyncResponse, error)
	OnSharedChannelsSyncMsg(ctx context.Context, in *OnSharedChannelsSyncMsgRequest, opts ...grpc.CallOption) (*OnSharedChannelsSyncMsgResponse, error)
	// OnSharedChannelsPing is invoked to check the health of the shared channels plugin.
	// Return true if the plugin and upstream connections are healthy.
	//
	// Go signature: OnSharedChannelsPing(rc *model.RemoteCluster) bool
	OnSharedChannelsPing(ctx context.Context, in *OnSharedChannelsPingRequest, opts ...grpc.CallOption) (*OnSharedChannelsPingResponse, error)
	// OnSharedChannelsAttachmentSyncMsg is invoked when a file attachment sync message is received.
	// Used to synchronize file attachments between shared channel participants.
	//
	// Go signature: OnSharedChannelsAttachmentSyncMsg(fi *model.FileInfo, post *model.Post, rc *model.RemoteCluster) error
	OnSharedChannelsAttachmentSyncMsg(ctx context.Context, in *OnSharedChannelsAttachmentSyncMsgRequest, opts ...grpc.CallOption) (*OnSharedChannelsAttachmentSyncMsgResponse, error)
	// OnSharedChannelsProfileImageSyncMsg is invoked when a profile image sync message is received.
	// Used to synchronize user profile images between shared channel participants.
	//
	// Go signature: OnSharedChannelsProfileImageSyncMsg(user *model.User, rc *model.RemoteCluster) error
	OnSharedChannelsProfileImageSyncMsg(ctx context.Context, in *OnSharedChannelsProfileImageSyncMsgRequest, opts ...grpc.CallOption) (*OnSharedChannelsProfileImageSyncMsgResponse, error)
	// GenerateSupportData is invoked when a Support Packet is generated.
	// Plugins can include their own diagnostic data in the support packet.
	//
	// Go signature: GenerateSupportData(c *Context) ([]*model.FileData, error)
	GenerateSupportData(ctx context.Context, in *GenerateSupportDataRequest, opts ...grpc.CallOption) (*GenerateSupportDataResponse, error)
	// ServeHTTP handles HTTP requests to /plugins/{plugin_id}.
	// Uses bidirectional streaming for efficient large body transfer.
	//
	// Request flow (Go -> Python):
	// - First message: init metadata (method, URL, headers) + optional first body chunk
	// - Subsequent messages: body chunks until body_complete=true
	//
	// Response flow (Python -> Go):
	// - First message: init metadata (status, headers) + optional first body chunk
	// - Subsequent messages: body chunks until body_complete=true
	//
	// Cancellation: HTTP client disconnect propagates via gRPC context.
	// Body chunks are 64KB by default (configurable).
	//
	// Go signature: ServeHTTP(c *Context, w http.ResponseWriter, r *http.Request)
	ServeHTTP(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ServeHTTPRequest, ServeHTTPResponse], error)
}

type pluginHooksClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginHooksClient(cc grpc.ClientConnInterface) PluginHooksClient {
	return &pluginHooksClient{cc}
}

func (c *pluginHooksClient) Implemented(ctx context.Context, in *ImplementedRequest, opts ...grpc.CallOption) (*ImplementedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_Implemented_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnActivate(ctx context.Context, in *OnActivateRequest, opts ...grpc.CallOption) (*OnActivateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnActivateResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnActivate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnDeactivate(ctx context.Context, in *OnDeactivateRequest, opts ...grpc.CallOption) (*OnDeactivateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnDeactivateResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnDeactivate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnConfigurationChange(ctx context.Context, in *OnConfigurationChangeRequest, opts ...grpc.CallOption) (*OnConfigurationChangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnConfigurationChangeResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnConfigurationChange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnInstall(ctx context.Context, in *OnInstallRequest, opts ...grpc.CallOption) (*OnInstallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnInstallResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnInstall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnSendDailyTelemetry(ctx context.Context, in *OnSendDailyTelemetryRequest, opts ...grpc.CallOption) (*OnSendDailyTelemetryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnSendDailyTelemetryResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnSendDailyTelemetry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) RunDataRetention(ctx context.Context, in *RunDataRetentionRequest, opts ...grpc.CallOption) (*RunDataRetentionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunDataRetentionResponse)
	err := c.cc.Invoke(ctx, PluginHooks_RunDataRetention_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnCloudLimitsUpdated(ctx context.Context, in *OnCloudLimitsUpdatedRequest, opts ...grpc.CallOption) (*OnCloudLimitsUpdatedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnCloudLimitsUpdatedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnCloudLimitsUpdated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) ConfigurationWillBeSaved(ctx context.Context, in *ConfigurationWillBeSavedRequest, opts ...grpc.CallOption) (*ConfigurationWillBeSavedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigurationWillBeSavedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_ConfigurationWillBeSaved_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) MessageWillBePosted(ctx context.Context, in *MessageWillBePostedRequest, opts ...grpc.CallOption) (*MessageWillBePostedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageWillBePostedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_MessageWillBePosted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) MessageWillBeUpdated(ctx context.Context, in *MessageWillBeUpdatedRequest, opts ...grpc.CallOption) (*MessageWillBeUpdatedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageWillBeUpdatedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_MessageWillBeUpdated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) MessageHasBeenPosted(ctx context.Context, in *MessageHasBeenPostedRequest, opts ...grpc.CallOption) (*MessageHasBeenPostedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageHasBeenPostedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_MessageHasBeenPosted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) MessageHasBeenUpdated(ctx context.Context, in *MessageHasBeenUpdatedRequest, opts ...grpc.CallOption) (*MessageHasBeenUpdatedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageHasBeenUpdatedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_MessageHasBeenUpdated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) MessagesWillBeConsumed(ctx context.Context, in *MessagesWillBeConsumedRequest, opts ...grpc.CallOption) (*MessagesWillBeConsumedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessagesWillBeConsumedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_MessagesWillBeConsumed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) MessageHasBeenDeleted(ctx context.Context, in *MessageHasBeenDeletedRequest, opts ...grpc.CallOption) (*MessageHasBeenDeletedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageHasBeenDeletedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_MessageHasBeenDeleted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) FileWillBeUploaded(ctx context.Context, in *FileWillBeUploadedRequest, opts ...grpc.CallOption) (*FileWillBeUploadedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileWillBeUploadedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_FileWillBeUploaded_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) ReactionHasBeenAdded(ctx context.Context, in *ReactionHasBeenAddedRequest, opts ...grpc.CallOption) (*ReactionHasBeenAddedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReactionHasBeenAddedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_ReactionHasBeenAdded_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) ReactionHasBeenRemoved(ctx context.Context, in *ReactionHasBeenRemovedRequest, opts ...grpc.CallOption) (*ReactionHasBeenRemovedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReactionHasBeenRemovedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_ReactionHasBeenRemoved_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) NotificationWillBePushed(ctx context.Context, in *NotificationWillBePushedRequest, opts ...grpc.CallOption) (*NotificationWillBePushedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NotificationWillBePushedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_NotificationWillBePushed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) EmailNotificationWillBeSent(ctx context.Context, in *EmailNotificationWillBeSentRequest, opts ...grpc.CallOption) (*EmailNotificationWillBeSentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmailNotificationWillBeSentResponse)
	err := c.cc.Invoke(ctx, PluginHooks_EmailNotificationWillBeSent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) PreferencesHaveChanged(ctx context.Context, in *PreferencesHaveChangedRequest, opts ...grpc.CallOption) (*PreferencesHaveChangedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PreferencesHaveChangedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_PreferencesHaveChanged_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) UserHasBeenCreated(ctx context.Context, in *UserHasBeenCreatedRequest, opts ...grpc.CallOption) (*UserHasBeenCreatedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserHasBeenCreatedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_UserHasBeenCreated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) UserWillLogIn(ctx context.Context, in *UserWillLogInRequest, opts ...grpc.CallOption) (*UserWillLogInResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserWillLogInResponse)
	err := c.cc.Invoke(ctx, PluginHooks_UserWillLogIn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) UserHasLoggedIn(ctx context.Context, in *UserHasLoggedInRequest, opts ...grpc.CallOption) (*UserHasLoggedInResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserHasLoggedInResponse)
	err := c.cc.Invoke(ctx, PluginHooks_UserHasLoggedIn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) UserHasBeenDeactivated(ctx context.Context, in *UserHasBeenDeactivatedRequest, opts ...grpc.CallOption) (*UserHasBeenDeactivatedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserHasBeenDeactivatedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_UserHasBeenDeactivated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnSAMLLogin(ctx context.Context, in *OnSAMLLoginRequest, opts ...grpc.CallOption) (*OnSAMLLoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnSAMLLoginResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnSAMLLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) ChannelHasBeenCreated(ctx context.Context, in *ChannelHasBeenCreatedRequest, opts ...grpc.CallOption) (*ChannelHasBeenCreatedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChannelHasBeenCreatedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_ChannelHasBeenCreated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) UserHasJoinedChannel(ctx context.Context, in *UserHasJoinedChannelRequest, opts ...grpc.CallOption) (*UserHasJoinedChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserHasJoinedChannelResponse)
	err := c.cc.Invoke(ctx, PluginHooks_UserHasJoinedChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) UserHasLeftChannel(ctx context.Context, in *UserHasLeftChannelRequest, opts ...grpc.CallOption) (*UserHasLeftChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserHasLeftChannelResponse)
	err := c.cc.Invoke(ctx, PluginHooks_UserHasLeftChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) UserHasJoinedTeam(ctx context.Context, in *UserHasJoinedTeamRequest, opts ...grpc.CallOption) (*UserHasJoinedTeamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserHasJoinedTeamResponse)
	err := c.cc.Invoke(ctx, PluginHooks_UserHasJoinedTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) UserHasLeftTeam(ctx context.Context, in *UserHasLeftTeamRequest, opts ...grpc.CallOption) (*UserHasLeftTeamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserHasLeftTeamResponse)
	err := c.cc.Invoke(ctx, PluginHooks_UserHasLeftTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) ExecuteCommand(ctx context.Context, in *ExecuteCommandRequest, opts ...grpc.CallOption) (*ExecuteCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteCommandResponse)
	err := c.cc.Invoke(ctx, PluginHooks_ExecuteCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnWebSocketConnect(ctx context.Context, in *OnWebSocketConnectRequest, opts ...grpc.CallOption) (*OnWebSocketConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnWebSocketConnectResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnWebSocketConnect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnWebSocketDisconnect(ctx context.Context, in *OnWebSocketDisconnectRequest, opts ...grpc.CallOption) (*OnWebSocketDisconnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnWebSocketDisconnectResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnWebSocketDisconnect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) WebSocketMessageHasBeenPosted(ctx context.Context, in *WebSocketMessageHasBeenPostedRequest, opts ...grpc.CallOption) (*WebSocketMessageHasBeenPostedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebSocketMessageHasBeenPostedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_WebSocketMessageHasBeenPosted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnPluginClusterEvent(ctx context.Context, in *OnPluginClusterEventRequest, opts ...grpc.CallOption) (*OnPluginClusterEventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnPluginClusterEventResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnPluginClusterEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnSharedChannelsSyncMsg(ctx context.Context, in *OnSharedChannelsSyncMsgRequest, opts ...grpc.CallOption) (*OnSharedChannelsSyncMsgResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnSharedChannelsSyncMsgResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnSharedChannelsSyncMsg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnSharedChannelsPing(ctx context.Context, in *OnSharedChannelsPingRequest, opts ...grpc.CallOption) (*OnSharedChannelsPingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnSharedChannelsPingResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnSharedChannelsPing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnSharedChannelsAttachmentSyncMsg(ctx context.Context, in *OnSharedChannelsAttachmentSyncMsgRequest, opts ...grpc.CallOption) (*OnSharedChannelsAttachmentSyncMsgResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnSharedChannelsAttachmentSyncMsgResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnSharedChannelsAttachmentSyncMsg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnSharedChannelsProfileImageSyncMsg(ctx context.Context, in *OnSharedChannelsProfileImageSyncMsgRequest, opts ...grpc.CallOption) (*OnSharedChannelsProfileImageSyncMsgResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnSharedChannelsProfileImageSyncMsgResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnSharedChannelsProfileImageSyncMsg_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) GenerateSupportData(ctx context.Context, in *GenerateSupportDataRequest, opts ...grpc.CallOption) (*GenerateSupportDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateSupportDataResponse)
	err := c.cc.Invoke(ctx, PluginHooks_GenerateSupportData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) ServeHTTP(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ServeHTTPRequest, ServeHTTPResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PluginHooks_ServiceDesc.Streams[0], PluginHooks_ServeHTTP_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ServeHTTPRequest, ServeHTTPResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PluginHooks_ServeHTTPClient = grpc.BidiStreamingClient[ServeHTTPRequest, ServeHTTPResponse]

// PluginHooksServer is the server API for PluginHooks service.
// All implementations must embed UnimplementedPluginHooksServer
// for forward compatibility.
//
// PluginHooks is the gRPC service for invoking plugin hooks.
// The server acts as the gRPC client, calling into the plugin process.
// The plugin acts as the gRPC server, implementing the hook handlers.
type PluginHooksServer interface {
	// Implemented returns the list of hooks that the plugin implements.
	// Called during plugin startup to optimize hook dispatch.
	// Plugins that don't implement this are assumed to implement all hooks.
	//
	// Go signature: Implemented() ([]string, error)
	Implemented(context.Context, *ImplementedRequest) (*ImplementedResponse, error)
	// OnActivate is invoked when the plugin is activated.
	// If an error is returned, the plugin will be terminated.
	// The plugin will not receive hooks until after OnActivate returns without error.
	// OnConfigurationChange will be called once before OnActivate.
	//
	// Go signature: OnActivate() error
	OnActivate(context.Context, *OnActivateRequest) (*OnActivateResponse, error)
	// OnDeactivate is invoked when the plugin is deactivated.
	// This is the plugin's last chance to use the API.
	// The plugin will be terminated shortly after this invocation.
	//
	// Go signature: OnDeactivate() error
	OnDeactivate(context.Context, *OnDeactivateRequest) (*OnDeactivateResponse, error)
	// OnConfigurationChange is invoked when configuration changes may have been made.
	// Any returned error is logged but does not stop the plugin.
	// It is called once before OnActivate.
	//
	// Go signature: OnConfigurationChange() error
	OnConfigurationChange(context.Context, *OnConfigurationChangeRequest) (*OnConfigurationChangeResponse, error)
	// OnInstall is invoked after the installation of a plugin as part of onboarding.
	// It's called on every installation, not only once.
	//
	// Go signature: OnInstall(c *Context, event model.OnInstallEvent) error
	OnInstall(context.Context, *OnInstallRequest) (*OnInstallResponse, error)
	// OnSendDailyTelemetry is invoked when the server sends daily telemetry data.
	// Plugins can use this to send their own telemetry metrics.
	//
	// Go signature: OnSendDailyTelemetry()
	OnSendDailyTelemetry(context.Context, *OnSendDailyTelemetryRequest) (*OnSendDailyTelemetryResponse, error)
	// RunDataRetention is invoked during a DataRetentionJob.
	// Plugins should delete data older than their retention policy.
	//
	// Go signature: RunDataRetention(nowTime, batchSize int64) (int64, error)
	RunDataRetention(context.Context, *RunDataRetentionRequest) (*RunDataRetentionResponse, error)
	// OnCloudLimitsUpdated is invoked when cloud product limits change.
	// For example, when plan tiers change affecting storage or message limits.
	//
	// Go signature: OnCloudLimitsUpdated(limits *model.ProductLimits)
	OnCloudLimitsUpdated(context.Context, *OnCloudLimitsUpdatedRequest) (*OnCloudLimitsUpdatedResponse, error)
	// ConfigurationWillBeSaved is invoked before saving configuration to the backing store.
	// An error can be returned to reject the operation.
	// Additionally, a new config object can be returned to be stored in place of the provided one.
	//
	// Go signature: ConfigurationWillBeSaved(newCfg *model.Config) (*model.Config, error)
	ConfigurationWillBeSaved(context.Context, *ConfigurationWillBeSavedRequest) (*ConfigurationWillBeSavedResponse, error)
	// MessageWillBePosted is invoked when a message is posted before it is committed
	// to the database. Use this to modify or reject posts before they are saved.
	//
	// Return values:
	// - To allow unchanged: return nil post and empty string
	// - To modify: return modified post and empty string
	// - To reject: return nil post and rejection reason string
	// - To dismiss silently: return nil post and "plugin.message_will_be_posted.dismiss_post"
	//
	// Go signature: MessageWillBePosted(c *Context, post *model.Post) (*model.Post, string)
	MessageWillBePosted(context.Context, *MessageWillBePostedRequest) (*MessageWillBePostedResponse, error)
	// MessageWillBeUpdated is invoked when a message is updated before it is committed
	// to the database. Use this to modify or reject post updates.
	//
	// Return values:
	// - To allow unchanged: return nil post and empty string
	// - To modify: return modified post and empty string
	// - To reject: return nil post and rejection reason (post stays unchanged)
	//
	// Go signature: MessageWillBeUpdated(c *Context, newPost, oldPost *model.Post) (*model.Post, string)
	MessageWillBeUpdated(context.Context, *MessageWillBeUpdatedRequest) (*MessageWillBeUpdatedResponse, error)
	// MessageHasBeenPosted is invoked after the message has been committed to the database.
	// This is a notification hook - you cannot modify or reject the post.
	// Use MessageWillBePosted if you need to modify or reject.
	//
	// Go signature: MessageHasBeenPosted(c *Context, post *model.Post)
	MessageHasBeenPosted(context.Context, *MessageHasBeenPostedRequest) (*MessageHasBeenPostedResponse, error)
	// MessageHasBeenUpdated is invoked after a message update has been committed to the database.
	// This is a notification hook - you cannot modify or reject the update.
	// Use MessageWillBeUpdated if you need to modify or reject.
	//
	// Go signature: MessageHasBeenUpdated(c *Context, newPost, oldPost *model.Post)
	MessageHasBeenUpdated(context.Context, *MessageHasBeenUpdatedRequest) (*MessageHasBeenUpdatedResponse, error)
	// MessagesWillBeConsumed is invoked when messages are requested by a client
	// before they are returned. Use this to filter or modify posts before delivery.
	//
	// Note: This hook has no Context parameter and no error return.
	//
	// Go signature: MessagesWillBeConsumed(posts []*model.Post) []*model.Post
	MessagesWillBeConsumed(context.Context, *MessagesWillBeConsumedRequest) (*MessagesWillBeConsumedResponse, error)
	// MessageHasBeenDeleted is invoked after a message has been deleted from the database.
	// This is a notification hook - you cannot undo the deletion.
	//
	// Go signature: MessageHasBeenDeleted(c *Context, post *model.Post)
	MessageHasBeenDeleted(context.Context, *MessageHasBeenDeletedRequest) (*MessageHasBeenDeletedResponse, error)
	// FileWillBeUploaded is invoked when a file is uploaded before it is committed
	// to storage. Use this to modify or reject file uploads.
	//
	// Note: Phase 8 will add streaming support. Currently uses bytes for file content.
	//
	// Return values:
	// - To allow unchanged: return nil FileInfo, empty bytes, empty string
	// - To modify: return modified FileInfo and/or content, empty string
	// - To reject: return nil FileInfo, empty bytes, and rejection reason
	//
	// Go signature: FileWillBeUploaded(c *Context, info *model.FileInfo, file io.Reader, output io.Writer) (*model.FileInfo, string)
	FileWillBeUploaded(context.Context, *FileWillBeUploadedRequest) (*FileWillBeUploadedResponse, error)
	// ReactionHasBeenAdded is invoked after a reaction has been committed to the database.
	// This is a notification hook.
	//
	// Go signature: ReactionHasBeenAdded(c *Context, reaction *model.Reaction)
	ReactionHasBeenAdded(context.Context, *ReactionHasBeenAddedRequest) (*ReactionHasBeenAddedResponse, error)
	// ReactionHasBeenRemoved is invoked after a reaction has been removed from the database.
	// This is a notification hook.
	//
	// Go signature: ReactionHasBeenRemoved(c *Context, reaction *model.Reaction)
	ReactionHasBeenRemoved(context.Context, *ReactionHasBeenRemovedRequest) (*ReactionHasBeenRemovedResponse, error)
	// NotificationWillBePushed is invoked before a push notification is sent to
	// the push notification server. Use this to modify or reject push notifications.
	//
	// Note: This hook has no Context parameter.
	//
	// Return values:
	// - To allow unchanged: return nil notification and empty string
	// - To modify: return modified notification and empty string
	// - To reject: return nil notification and rejection reason
	//
	// Go signature: NotificationWillBePushed(pushNotification *model.PushNotification, userID string) (*model.PushNotification, string)
	NotificationWillBePushed(context.Context, *NotificationWillBePushedRequest) (*NotificationWillBePushedResponse, error)
	// EmailNotificationWillBeSent is invoked before an email notification is sent.
	// Use this to customize email content or reject the notification.
	//
	// Note: Core identifiers (PostId, ChannelId, etc.) are immutable.
	// Only content fields (subject, title, message, etc.) can be modified.
	// Note: This hook has no Context parameter.
	//
	// Return values:
	// - To allow unchanged: return nil content and empty string
	// - To modify: return modified EmailNotificationContent and empty string
	// - To reject: return nil content and rejection reason
	//
	// Go signature: EmailNotificationWillBeSent(emailNotification *model.EmailNotification) (*model.EmailNotificationContent, string)
	EmailNotificationWillBeSent(context.Context, *EmailNotificationWillBeSentRequest) (*EmailNotificationWillBeSentResponse, error)
	// PreferencesHaveChanged is invoked after one or more of a user's preferences
	// have changed. This is a notification hook.
	//
	// Go signature: PreferencesHaveChanged(c *Context, preferences []model.Preference)
	PreferencesHaveChanged(context.Context, *PreferencesHaveChangedRequest) (*PreferencesHaveChangedResponse, error)
	// UserHasBeenCreated is invoked after a user was created.
	// This is a notification hook - you cannot modify or reject the creation.
	//
	// Go signature: UserHasBeenCreated(c *Context, user *model.User)
	UserHasBeenCreated(context.Context, *UserHasBeenCreatedRequest) (*UserHasBeenCreatedResponse, error)
	// UserWillLogIn is invoked before the login of the user is returned.
	// Return a non-empty string to reject the login.
	// If you don't need to reject the login event, see UserHasLoggedIn.
	//
	// Go signature: UserWillLogIn(c *Context, user *model.User) string
	UserWillLogIn(context.Context, *UserWillLogInRequest) (*UserWillLogInResponse, error)
	// UserHasLoggedIn is invoked after a user has logged in.
	// This is a notification hook - you cannot modify or reject the login.
	//
	// Go signature: UserHasLoggedIn(c *Context, user *model.User)
	UserHasLoggedIn(context.Context, *UserHasLoggedInRequest) (*UserHasLoggedInResponse, error)
	// UserHasBeenDeactivated is invoked when a user is deactivated.
	// This is a notification hook.
	//
	// Go signature: UserHasBeenDeactivated(c *Context, user *model.User)
	UserHasBeenDeactivated(context.Context, *UserHasBeenDeactivatedRequest) (*UserHasBeenDeactivatedResponse, error)
	// OnSAMLLogin is invoked after a successful SAML login.
	// Return an error to reject the login.
	//
	// Go signature: OnSAMLLogin(c *Context, user *model.User, assertion *saml2.AssertionInfo) error
	OnSAMLLogin(context.Context, *OnSAMLLoginRequest) (*OnSAMLLoginResponse, error)
	// ChannelHasBeenCreated is invoked after a channel has been created.
	// This is a notification hook - you cannot modify or reject the creation.
	//
	// Go signature: ChannelHasBeenCreated(c *Context, channel *model.Channel)
	ChannelHasBeenCreated(context.Context, *ChannelHasBeenCreatedRequest) (*ChannelHasBeenCreatedResponse, error)
	// UserHasJoinedChannel is invoked after a user has joined a channel.
	// This is a notification hook. The actor is optional (nil if self-join).
	//
	// Go signature: UserHasJoinedChannel(c *Context, channelMember *model.ChannelMember, actor *model.User)
	UserHasJoinedChannel(context.Context, *UserHasJoinedChannelRequest) (*UserHasJoinedChannelResponse, error)
	// UserHasLeftChannel is invoked after a user has left a channel.
	// This is a notification hook. The actor is optional (nil if self-removal).
	//
	// Go signature: UserHasLeftChannel(c *Context, channelMember *model.ChannelMember, actor *model.User)
	UserHasLeftChannel(context.Context, *UserHasLeftChannelRequest) (*UserHasLeftChannelResponse, error)
	// UserHasJoinedTeam is invoked after a user has joined a team.
	// This is a notification hook. The actor is optional (nil if self-join).
	//
	// Go signature: UserHasJoinedTeam(c *Context, teamMember *model.TeamMember, actor *model.User)
	UserHasJoinedTeam(context.Context, *UserHasJoinedTeamRequest) (*UserHasJoinedTeamResponse, error)
	// UserHasLeftTeam is invoked after a user has left a team.
	// This is a notification hook. The actor is optional (nil if self-removal).
	//
	// Go signature: UserHasLeftTeam(c *Context, teamMember *model.TeamMember, actor *model.User)
	UserHasLeftTeam(context.Context, *UserHasLeftTeamRequest) (*UserHasLeftTeamResponse, error)
	// ExecuteCommand executes a registered slash command.
	//
	// Go signature: ExecuteCommand(c *Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError)
	ExecuteCommand(context.Context, *ExecuteCommandRequest) (*ExecuteCommandResponse, error)
	// OnWebSocketConnect is invoked when a new WebSocket connection is opened.
	// This is a notification hook with no Context parameter.
	//
	// Go signature: OnWebSocketConnect(webConnID, userID string)
	OnWebSocketConnect(context.Context, *OnWebSocketConnectRequest) (*OnWebSocketConnectResponse, error)
	// OnWebSocketDisconnect is invoked when a WebSocket connection is closed.
	// This is a notification hook with no Context parameter.
	//
	// Go signature: OnWebSocketDisconnect(webConnID, userID string)
	OnWebSocketDisconnect(context.Context, *OnWebSocketDisconnectRequest) (*OnWebSocketDisconnectResponse, error)
	// WebSocketMessageHasBeenPosted is invoked when a WebSocket message is received.
	// This is a notification hook with no Context parameter.
	//
	// Go signature: WebSocketMessageHasBeenPosted(webConnID, userID string, req *model.WebSocketRequest)
	WebSocketMessageHasBeenPosted(context.Context, *WebSocketMessageHasBeenPostedRequest) (*WebSocketMessageHasBeenPostedResponse, error)
	// OnPluginClusterEvent is invoked when an intra-cluster plugin event is received.
	// Used for communication between plugin instances in a High-Availability cluster.
	// This is a notification hook.
	//
	// Go signature: OnPluginClusterEvent(c *Context, ev model.PluginClusterEvent)
	OnPluginClusterEvent(context.Context, *OnPluginClusterEventRequest) (*OnPluginClusterEventResponse, error)
	// OnSharedChannelsSyncMsg is invoked when a shared channels sync message is received.
	// Plugins can use this to synchronize data with remote clusters.
	//
	// Go signature: OnSharedChannelsSyncMsg(msg *model.SyncMsg, rc *model.RemoteCluster) (model.SyncResponse, error)
	OnSharedChannelsSyncMsg(context.Context, *OnSharedChannelsSyncMsgRequest) (*OnSharedChannelsSyncMsgResponse, error)
	// OnSharedChannelsPing is invoked to check the health of the shared channels plugin.
	// Return true if the plugin and upstream connections are healthy.
	//
	// Go signature: OnSharedChannelsPing(rc *model.RemoteCluster) bool
	OnSharedChannelsPing(context.Context, *OnSharedChannelsPingRequest) (*OnSharedChannelsPingResponse, error)
	// OnSharedChannelsAttachmentSyncMsg is invoked when a file attachment sync message is received.
	// Used to synchronize file attachments between shared channel participants.
	//
	// Go signature: OnSharedChannelsAttachmentSyncMsg(fi *model.FileInfo, post *model.Post, rc *model.RemoteCluster) error
	OnSharedChannelsAttachmentSyncMsg(context.Context, *OnSharedChannelsAttachmentSyncMsgRequest) (*OnSharedChannelsAttachmentSyncMsgResponse, error)
	// OnSharedChannelsProfileImageSyncMsg is invoked when a profile image sync message is received.
	// Used to synchronize user profile images between shared channel participants.
	//
	// Go signature: OnSharedChannelsProfileImageSyncMsg(user *model.User, rc *model.RemoteCluster) error
	OnSharedChannelsProfileImageSyncMsg(context.Context, *OnSharedChannelsProfileImageSyncMsgRequest) (*OnSharedChannelsProfileImageSyncMsgResponse, error)
	// GenerateSupportData is invoked when a Support Packet is generated.
	// Plugins can include their own diagnostic data in the support packet.
	//
	// Go signature: GenerateSupportData(c *Context) ([]*model.FileData, error)
	GenerateSupportData(context.Context, *GenerateSupportDataRequest) (*GenerateSupportDataResponse, error)
	// ServeHTTP handles HTTP requests to /plugins/{plugin_id}.
	// Uses bidirectional streaming for efficient large body transfer.
	//
	// Request flow (Go -> Python):
	// - First message: init metadata (method, URL, headers) + optional first body chunk
	// - Subsequent messages: body chunks until body_complete=true
	//
	// Response flow (Python -> Go):
	// - First message: init metadata (status, headers) + optional first body chunk
	// - Subsequent messages: body chunks until body_complete=true
	//
	// Cancellation: HTTP client disconnect propagates via gRPC context.
	// Body chunks are 64KB by default (configurable).
	//
	// Go signature: ServeHTTP(c *Context, w http.ResponseWriter, r *http.Request)
	ServeHTTP(grpc.BidiStreamingServer[ServeHTTPRequest, ServeHTTPResponse]) error
	mustEmbedUnimplementedPluginHooksServer()
}

// UnimplementedPluginHooksServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPluginHooksServer struct{}

func (UnimplementedPluginHooksServer) Implemented(context.Context, *ImplementedRequest) (*ImplementedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Implemented not implemented")
}
func (UnimplementedPluginHooksServer) OnActivate(context.Context, *OnActivateRequest) (*OnActivateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnActivate not implemented")
}
func (UnimplementedPluginHooksServer) OnDeactivate(context.Context, *OnDeactivateRequest) (*OnDeactivateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnDeactivate not implemented")
}
func (UnimplementedPluginHooksServer) OnConfigurationChange(context.Context, *OnConfigurationChangeRequest) (*OnConfigurationChangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnConfigurationChange not implemented")
}
func (UnimplementedPluginHooksServer) OnInstall(context.Context, *OnInstallRequest) (*OnInstallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnInstall not implemented")
}
func (UnimplementedPluginHooksServer) OnSendDailyTelemetry(context.Context, *OnSendDailyTelemetryRequest) (*OnSendDailyTelemetryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnSendDailyTelemetry not implemented")
}
func (UnimplementedPluginHooksServer) RunDataRetention(context.Context, *RunDataRetentionRequest) (*RunDataRetentionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunDataRetention not implemented")
}
func (UnimplementedPluginHooksServer) OnCloudLimitsUpdated(context.Context, *OnCloudLimitsUpdatedRequest) (*OnCloudLimitsUpdatedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnCloudLimitsUpdated not implemented")
}
func (UnimplementedPluginHooksServer) ConfigurationWillBeSaved(context.Context, *ConfigurationWillBeSavedRequest) (*ConfigurationWillBeSavedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigurationWillBeSaved not implemented")
}
func (UnimplementedPluginHooksServer) MessageWillBePosted(context.Context, *MessageWillBePostedRequest) (*MessageWillBePostedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageWillBePosted not implemented")
}
func (UnimplementedPluginHooksServer) MessageWillBeUpdated(context.Context, *MessageWillBeUpdatedRequest) (*MessageWillBeUpdatedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageWillBeUpdated not implemented")
}
func (UnimplementedPluginHooksServer) MessageHasBeenPosted(context.Context, *MessageHasBeenPostedRequest) (*MessageHasBeenPostedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageHasBeenPosted not implemented")
}
func (UnimplementedPluginHooksServer) MessageHasBeenUpdated(context.Context, *MessageHasBeenUpdatedRequest) (*MessageHasBeenUpdatedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageHasBeenUpdated not implemented")
}
func (UnimplementedPluginHooksServer) MessagesWillBeConsumed(context.Context, *MessagesWillBeConsumedRequest) (*MessagesWillBeConsumedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessagesWillBeConsumed not implemented")
}
func (UnimplementedPluginHooksServer) MessageHasBeenDeleted(context.Context, *MessageHasBeenDeletedRequest) (*MessageHasBeenDeletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageHasBeenDeleted not implemented")
}
func (UnimplementedPluginHooksServer) FileWillBeUploaded(context.Context, *FileWillBeUploadedRequest) (*FileWillBeUploadedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileWillBeUploaded not implemented")
}
func (UnimplementedPluginHooksServer) ReactionHasBeenAdded(context.Context, *ReactionHasBeenAddedRequest) (*ReactionHasBeenAddedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReactionHasBeenAdded not implemented")
}
func (UnimplementedPluginHooksServer) ReactionHasBeenRemoved(context.Context, *ReactionHasBeenRemovedRequest) (*ReactionHasBeenRemovedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReactionHasBeenRemoved not implemented")
}
func (UnimplementedPluginHooksServer) NotificationWillBePushed(context.Context, *NotificationWillBePushedRequest) (*NotificationWillBePushedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotificationWillBePushed not implemented")
}
func (UnimplementedPluginHooksServer) EmailNotificationWillBeSent(context.Context, *EmailNotificationWillBeSentRequest) (*EmailNotificationWillBeSentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmailNotificationWillBeSent not implemented")
}
func (UnimplementedPluginHooksServer) PreferencesHaveChanged(context.Context, *PreferencesHaveChangedRequest) (*PreferencesHaveChangedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreferencesHaveChanged not implemented")
}
func (UnimplementedPluginHooksServer) UserHasBeenCreated(context.Context, *UserHasBeenCreatedRequest) (*UserHasBeenCreatedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserHasBeenCreated not implemented")
}
func (UnimplementedPluginHooksServer) UserWillLogIn(context.Context, *UserWillLogInRequest) (*UserWillLogInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserWillLogIn not implemented")
}
func (UnimplementedPluginHooksServer) UserHasLoggedIn(context.Context, *UserHasLoggedInRequest) (*UserHasLoggedInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserHasLoggedIn not implemented")
}
func (UnimplementedPluginHooksServer) UserHasBeenDeactivated(context.Context, *UserHasBeenDeactivatedRequest) (*UserHasBeenDeactivatedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserHasBeenDeactivated not implemented")
}
func (UnimplementedPluginHooksServer) OnSAMLLogin(context.Context, *OnSAMLLoginRequest) (*OnSAMLLoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnSAMLLogin not implemented")
}
func (UnimplementedPluginHooksServer) ChannelHasBeenCreated(context.Context, *ChannelHasBeenCreatedRequest) (*ChannelHasBeenCreatedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelHasBeenCreated not implemented")
}
func (UnimplementedPluginHooksServer) UserHasJoinedChannel(context.Context, *UserHasJoinedChannelRequest) (*UserHasJoinedChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserHasJoinedChannel not implemented")
}
func (UnimplementedPluginHooksServer) UserHasLeftChannel(context.Context, *UserHasLeftChannelRequest) (*UserHasLeftChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserHasLeftChannel not implemented")
}
func (UnimplementedPluginHooksServer) UserHasJoinedTeam(context.Context, *UserHasJoinedTeamRequest) (*UserHasJoinedTeamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserHasJoinedTeam not implemented")
}
func (UnimplementedPluginHooksServer) UserHasLeftTeam(context.Context, *UserHasLeftTeamRequest) (*UserHasLeftTeamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserHasLeftTeam not implemented")
}
func (UnimplementedPluginHooksServer) ExecuteCommand(context.Context, *ExecuteCommandRequest) (*ExecuteCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteCommand not implemented")
}
func (UnimplementedPluginHooksServer) OnWebSocketConnect(context.Context, *OnWebSocketConnectRequest) (*OnWebSocketConnectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnWebSocketConnect not implemented")
}
func (UnimplementedPluginHooksServer) OnWebSocketDisconnect(context.Context, *OnWebSocketDisconnectRequest) (*OnWebSocketDisconnectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnWebSocketDisconnect not implemented")
}
func (UnimplementedPluginHooksServer) WebSocketMessageHasBeenPosted(context.Context, *WebSocketMessageHasBeenPostedRequest) (*WebSocketMessageHasBeenPostedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WebSocketMessageHasBeenPosted not implemented")
}
func (UnimplementedPluginHooksServer) OnPluginClusterEvent(context.Context, *OnPluginClusterEventRequest) (*OnPluginClusterEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPluginClusterEvent not implemented")
}
func (UnimplementedPluginHooksServer) OnSharedChannelsSyncMsg(context.Context, *OnSharedChannelsSyncMsgRequest) (*OnSharedChannelsSyncMsgResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnSharedChannelsSyncMsg not implemented")
}
func (UnimplementedPluginHooksServer) OnSharedChannelsPing(context.Context, *OnSharedChannelsPingRequest) (*OnSharedChannelsPingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnSharedChannelsPing not implemented")
}
func (UnimplementedPluginHooksServer) OnSharedChannelsAttachmentSyncMsg(context.Context, *OnSharedChannelsAttachmentSyncMsgRequest) (*OnSharedChannelsAttachmentSyncMsgResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnSharedChannelsAttachmentSyncMsg not implemented")
}
func (UnimplementedPluginHooksServer) OnSharedChannelsProfileImageSyncMsg(context.Context, *OnSharedChannelsProfileImageSyncMsgRequest) (*OnSharedChannelsProfileImageSyncMsgResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnSharedChannelsProfileImageSyncMsg not implemented")
}
func (UnimplementedPluginHooksServer) GenerateSupportData(context.Context, *GenerateSupportDataRequest) (*GenerateSupportDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateSupportData not implemented")
}
func (UnimplementedPluginHooksServer) ServeHTTP(grpc.BidiStreamingServer[ServeHTTPRequest, ServeHTTPResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ServeHTTP not implemented")
}
func (UnimplementedPluginHooksServer) mustEmbedUnimplementedPluginHooksServer() {}
func (UnimplementedPluginHooksServer) testEmbeddedByValue()                     {}

// UnsafePluginHooksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginHooksServer will
// result in compilation errors.
type UnsafePluginHooksServer interface {
	mustEmbedUnimplementedPluginHooksServer()
}

func RegisterPluginHooksServer(s grpc.ServiceRegistrar, srv PluginHooksServer) {
	// If the following call pancis, it indicates UnimplementedPluginHooksServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PluginHooks_ServiceDesc, srv)
}

func _PluginHooks_Implemented_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImplementedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).Implemented(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_Implemented_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).Implemented(ctx, req.(*ImplementedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnActivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnActivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnActivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnActivate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnActivate(ctx, req.(*OnActivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnDeactivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnDeactivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnDeactivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnDeactivate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnDeactivate(ctx, req.(*OnDeactivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnConfigurationChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnConfigurationChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnConfigurationChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnConfigurationChange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnConfigurationChange(ctx, req.(*OnConfigurationChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnInstall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnInstallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnInstall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnInstall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnInstall(ctx, req.(*OnInstallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnSendDailyTelemetry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnSendDailyTelemetryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnSendDailyTelemetry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnSendDailyTelemetry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnSendDailyTelemetry(ctx, req.(*OnSendDailyTelemetryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_RunDataRetention_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunDataRetentionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).RunDataRetention(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_RunDataRetention_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).RunDataRetention(ctx, req.(*RunDataRetentionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnCloudLimitsUpdated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnCloudLimitsUpdatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnCloudLimitsUpdated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnCloudLimitsUpdated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnCloudLimitsUpdated(ctx, req.(*OnCloudLimitsUpdatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_ConfigurationWillBeSaved_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigurationWillBeSavedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).ConfigurationWillBeSaved(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_ConfigurationWillBeSaved_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).ConfigurationWillBeSaved(ctx, req.(*ConfigurationWillBeSavedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_MessageWillBePosted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageWillBePostedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).MessageWillBePosted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_MessageWillBePosted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).MessageWillBePosted(ctx, req.(*MessageWillBePostedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_MessageWillBeUpdated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageWillBeUpdatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).MessageWillBeUpdated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_MessageWillBeUpdated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).MessageWillBeUpdated(ctx, req.(*MessageWillBeUpdatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_MessageHasBeenPosted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageHasBeenPostedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).MessageHasBeenPosted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_MessageHasBeenPosted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).MessageHasBeenPosted(ctx, req.(*MessageHasBeenPostedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_MessageHasBeenUpdated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageHasBeenUpdatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).MessageHasBeenUpdated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_MessageHasBeenUpdated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).MessageHasBeenUpdated(ctx, req.(*MessageHasBeenUpdatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_MessagesWillBeConsumed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessagesWillBeConsumedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).MessagesWillBeConsumed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_MessagesWillBeConsumed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).MessagesWillBeConsumed(ctx, req.(*MessagesWillBeConsumedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_MessageHasBeenDeleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageHasBeenDeletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).MessageHasBeenDeleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_MessageHasBeenDeleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).MessageHasBeenDeleted(ctx, req.(*MessageHasBeenDeletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_FileWillBeUploaded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileWillBeUploadedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).FileWillBeUploaded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_FileWillBeUploaded_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).FileWillBeUploaded(ctx, req.(*FileWillBeUploadedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_ReactionHasBeenAdded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReactionHasBeenAddedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).ReactionHasBeenAdded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_ReactionHasBeenAdded_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).ReactionHasBeenAdded(ctx, req.(*ReactionHasBeenAddedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_ReactionHasBeenRemoved_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReactionHasBeenRemovedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).ReactionHasBeenRemoved(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_ReactionHasBeenRemoved_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).ReactionHasBeenRemoved(ctx, req.(*ReactionHasBeenRemovedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_NotificationWillBePushed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationWillBePushedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).NotificationWillBePushed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_NotificationWillBePushed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).NotificationWillBePushed(ctx, req.(*NotificationWillBePushedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_EmailNotificationWillBeSent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailNotificationWillBeSentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).EmailNotificationWillBeSent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_EmailNotificationWillBeSent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).EmailNotificationWillBeSent(ctx, req.(*EmailNotificationWillBeSentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_PreferencesHaveChanged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreferencesHaveChangedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).PreferencesHaveChanged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_PreferencesHaveChanged_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).PreferencesHaveChanged(ctx, req.(*PreferencesHaveChangedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_UserHasBeenCreated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserHasBeenCreatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).UserHasBeenCreated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_UserHasBeenCreated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).UserHasBeenCreated(ctx, req.(*UserHasBeenCreatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_UserWillLogIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserWillLogInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).UserWillLogIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_UserWillLogIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).UserWillLogIn(ctx, req.(*UserWillLogInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_UserHasLoggedIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserHasLoggedInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).UserHasLoggedIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_UserHasLoggedIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).UserHasLoggedIn(ctx, req.(*UserHasLoggedInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_UserHasBeenDeactivated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserHasBeenDeactivatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).UserHasBeenDeactivated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_UserHasBeenDeactivated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).UserHasBeenDeactivated(ctx, req.(*UserHasBeenDeactivatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnSAMLLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnSAMLLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnSAMLLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnSAMLLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnSAMLLogin(ctx, req.(*OnSAMLLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_ChannelHasBeenCreated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelHasBeenCreatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).ChannelHasBeenCreated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_ChannelHasBeenCreated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).ChannelHasBeenCreated(ctx, req.(*ChannelHasBeenCreatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_UserHasJoinedChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserHasJoinedChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).UserHasJoinedChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_UserHasJoinedChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).UserHasJoinedChannel(ctx, req.(*UserHasJoinedChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_UserHasLeftChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserHasLeftChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).UserHasLeftChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_UserHasLeftChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).UserHasLeftChannel(ctx, req.(*UserHasLeftChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_UserHasJoinedTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserHasJoinedTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).UserHasJoinedTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_UserHasJoinedTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).UserHasJoinedTeam(ctx, req.(*UserHasJoinedTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_UserHasLeftTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserHasLeftTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).UserHasLeftTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_UserHasLeftTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).UserHasLeftTeam(ctx, req.(*UserHasLeftTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_ExecuteCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).ExecuteCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_ExecuteCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).ExecuteCommand(ctx, req.(*ExecuteCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnWebSocketConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnWebSocketConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnWebSocketConnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnWebSocketConnect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnWebSocketConnect(ctx, req.(*OnWebSocketConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnWebSocketDisconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnWebSocketDisconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnWebSocketDisconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnWebSocketDisconnect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnWebSocketDisconnect(ctx, req.(*OnWebSocketDisconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_WebSocketMessageHasBeenPosted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebSocketMessageHasBeenPostedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).WebSocketMessageHasBeenPosted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_WebSocketMessageHasBeenPosted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).WebSocketMessageHasBeenPosted(ctx, req.(*WebSocketMessageHasBeenPostedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnPluginClusterEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnPluginClusterEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnPluginClusterEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnPluginClusterEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnPluginClusterEvent(ctx, req.(*OnPluginClusterEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnSharedChannelsSyncMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnSharedChannelsSyncMsgRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnSharedChannelsSyncMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnSharedChannelsSyncMsg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnSharedChannelsSyncMsg(ctx, req.(*OnSharedChannelsSyncMsgRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnSharedChannelsPing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnSharedChannelsPingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnSharedChannelsPing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnSharedChannelsPing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnSharedChannelsPing(ctx, req.(*OnSharedChannelsPingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnSharedChannelsAttachmentSyncMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnSharedChannelsAttachmentSyncMsgRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnSharedChannelsAttachmentSyncMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnSharedChannelsAttachmentSyncMsg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnSharedChannelsAttachmentSyncMsg(ctx, req.(*OnSharedChannelsAttachmentSyncMsgRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnSharedChannelsProfileImageSyncMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnSharedChannelsProfileImageSyncMsgRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnSharedChannelsProfileImageSyncMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnSharedChannelsProfileImageSyncMsg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnSharedChannelsProfileImageSyncMsg(ctx, req.(*OnSharedChannelsProfileImageSyncMsgRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_GenerateSupportData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateSupportDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).GenerateSupportData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_GenerateSupportData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).GenerateSupportData(ctx, req.(*GenerateSupportDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_ServeHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PluginHooksServer).ServeHTTP(&grpc.GenericServerStream[ServeHTTPRequest, ServeHTTPResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PluginHooks_ServeHTTPServer = grpc.BidiStreamingServer[ServeHTTPRequest, ServeHTTPResponse]

// PluginHooks_ServiceDesc is the grpc.ServiceDesc for PluginHooks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginHooks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mattermost.pluginapi.v1.PluginHooks",
	HandlerType: (*PluginHooksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Implemented",
			Handler:    _PluginHooks_Implemented_Handler,
		},
		{
			MethodName: "OnActivate",
			Handler:    _PluginHooks_OnActivate_Handler,
		},
		{
			MethodName: "OnDeactivate",
			Handler:    _PluginHooks_OnDeactivate_Handler,
		},
		{
			MethodName: "OnConfigurationChange",
			Handler:    _PluginHooks_OnConfigurationChange_Handler,
		},
		{
			MethodName: "OnInstall",
			Handler:    _PluginHooks_OnInstall_Handler,
		},
		{
			MethodName: "OnSendDailyTelemetry",
			Handler:    _PluginHooks_OnSendDailyTelemetry_Handler,
		},
		{
			MethodName: "RunDataRetention",
			Handler:    _PluginHooks_RunDataRetention_Handler,
		},
		{
			MethodName: "OnCloudLimitsUpdated",
			Handler:    _PluginHooks_OnCloudLimitsUpdated_Handler,
		},
		{
			MethodName: "ConfigurationWillBeSaved",
			Handler:    _PluginHooks_ConfigurationWillBeSaved_Handler,
		},
		{
			MethodName: "MessageWillBePosted",
			Handler:    _PluginHooks_MessageWillBePosted_Handler,
		},
		{
			MethodName: "MessageWillBeUpdated",
			Handler:    _PluginHooks_MessageWillBeUpdated_Handler,
		},
		{
			MethodName: "MessageHasBeenPosted",
			Handler:    _PluginHooks_MessageHasBeenPosted_Handler,
		},
		{
			MethodName: "MessageHasBeenUpdated",
			Handler:    _PluginHooks_MessageHasBeenUpdated_Handler,
		},
		{
			MethodName: "MessagesWillBeConsumed",
			Handler:    _PluginHooks_MessagesWillBeConsumed_Handler,
		},
		{
			MethodName: "MessageHasBeenDeleted",
			Handler:    _PluginHooks_MessageHasBeenDeleted_Handler,
		},
		{
			MethodName: "FileWillBeUploaded",
			Handler:    _PluginHooks_FileWillBeUploaded_Handler,
		},
		{
			MethodName: "ReactionHasBeenAdded",
			Handler:    _PluginHooks_ReactionHasBeenAdded_Handler,
		},
		{
			MethodName: "ReactionHasBeenRemoved",
			Handler:    _PluginHooks_ReactionHasBeenRemoved_Handler,
		},
		{
			MethodName: "NotificationWillBePushed",
			Handler:    _PluginHooks_NotificationWillBePushed_Handler,
		},
		{
			MethodName: "EmailNotificationWillBeSent",
			Handler:    _PluginHooks_EmailNotificationWillBeSent_Handler,
		},
		{
			MethodName: "PreferencesHaveChanged",
			Handler:    _PluginHooks_PreferencesHaveChanged_Handler,
		},
		{
			MethodName: "UserHasBeenCreated",
			Handler:    _PluginHooks_UserHasBeenCreated_Handler,
		},
		{
			MethodName: "UserWillLogIn",
			Handler:    _PluginHooks_UserWillLogIn_Handler,
		},
		{
			MethodName: "UserHasLoggedIn",
			Handler:    _PluginHooks_UserHasLoggedIn_Handler,
		},
		{
			MethodName: "UserHasBeenDeactivated",
			Handler:    _PluginHooks_UserHasBeenDeactivated_Handler,
		},
		{
			MethodName: "OnSAMLLogin",
			Handler:    _PluginHooks_OnSAMLLogin_Handler,
		},
		{
			MethodName: "ChannelHasBeenCreated",
			Handler:    _PluginHooks_ChannelHasBeenCreated_Handler,
		},
		{
			MethodName: "UserHasJoinedChannel",
			Handler:    _PluginHooks_UserHasJoinedChannel_Handler,
		},
		{
			MethodName: "UserHasLeftChannel",
			Handler:    _PluginHooks_UserHasLeftChannel_Handler,
		},
		{
			MethodName: "UserHasJoinedTeam",
			Handler:    _PluginHooks_UserHasJoinedTeam_Handler,
		},
		{
			MethodName: "UserHasLeftTeam",
			Handler:    _PluginHooks_UserHasLeftTeam_Handler,
		},
		{
			MethodName: "ExecuteCommand",
			Handler:    _PluginHooks_ExecuteCommand_Handler,
		},
		{
			MethodName: "OnWebSocketConnect",
			Handler:    _PluginHooks_OnWebSocketConnect_Handler,
		},
		{
			MethodName: "OnWebSocketDisconnect",
			Handler:    _PluginHooks_OnWebSocketDisconnect_Handler,
		},
		{
			MethodName: "WebSocketMessageHasBeenPosted",
			Handler:    _PluginHooks_WebSocketMessageHasBeenPosted_Handler,
		},
		{
			MethodName: "OnPluginClusterEvent",
			Handler:    _PluginHooks_OnPluginClusterEvent_Handler,
		},
		{
			MethodName: "OnSharedChannelsSyncMsg",
			Handler:    _PluginHooks_OnSharedChannelsSyncMsg_Handler,
		},
		{
			MethodName: "OnSharedChannelsPing",
			Handler:    _PluginHooks_OnSharedChannelsPing_Handler,
		},
		{
			MethodName: "OnSharedChannelsAttachmentSyncMsg",
			Handler:    _PluginHooks_OnSharedChannelsAttachmentSyncMsg_Handler,
		},
		{
			MethodName: "OnSharedChannelsProfileImageSyncMsg",
			Handler:    _PluginHooks_OnSharedChannelsProfileImageSyncMsg_Handler,
		},
		{
			MethodName: "GenerateSupportData",
			Handler:    _PluginHooks_GenerateSupportData_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ServeHTTP",
			Handler:       _PluginHooks_ServeHTTP_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "hooks.proto",
}
