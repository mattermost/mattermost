// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.4
// source: hooks.proto

package pluginapiv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PluginHooks_Implemented_FullMethodName              = "/mattermost.pluginapi.v1.PluginHooks/Implemented"
	PluginHooks_OnActivate_FullMethodName               = "/mattermost.pluginapi.v1.PluginHooks/OnActivate"
	PluginHooks_OnDeactivate_FullMethodName             = "/mattermost.pluginapi.v1.PluginHooks/OnDeactivate"
	PluginHooks_OnConfigurationChange_FullMethodName    = "/mattermost.pluginapi.v1.PluginHooks/OnConfigurationChange"
	PluginHooks_OnInstall_FullMethodName                = "/mattermost.pluginapi.v1.PluginHooks/OnInstall"
	PluginHooks_OnSendDailyTelemetry_FullMethodName     = "/mattermost.pluginapi.v1.PluginHooks/OnSendDailyTelemetry"
	PluginHooks_RunDataRetention_FullMethodName         = "/mattermost.pluginapi.v1.PluginHooks/RunDataRetention"
	PluginHooks_OnCloudLimitsUpdated_FullMethodName     = "/mattermost.pluginapi.v1.PluginHooks/OnCloudLimitsUpdated"
	PluginHooks_ConfigurationWillBeSaved_FullMethodName = "/mattermost.pluginapi.v1.PluginHooks/ConfigurationWillBeSaved"
)

// PluginHooksClient is the client API for PluginHooks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// PluginHooks is the gRPC service for invoking plugin hooks.
// The server acts as the gRPC client, calling into the plugin process.
// The plugin acts as the gRPC server, implementing the hook handlers.
type PluginHooksClient interface {
	// Implemented returns the list of hooks that the plugin implements.
	// Called during plugin startup to optimize hook dispatch.
	// Plugins that don't implement this are assumed to implement all hooks.
	//
	// Go signature: Implemented() ([]string, error)
	Implemented(ctx context.Context, in *ImplementedRequest, opts ...grpc.CallOption) (*ImplementedResponse, error)
	// OnActivate is invoked when the plugin is activated.
	// If an error is returned, the plugin will be terminated.
	// The plugin will not receive hooks until after OnActivate returns without error.
	// OnConfigurationChange will be called once before OnActivate.
	//
	// Go signature: OnActivate() error
	OnActivate(ctx context.Context, in *OnActivateRequest, opts ...grpc.CallOption) (*OnActivateResponse, error)
	// OnDeactivate is invoked when the plugin is deactivated.
	// This is the plugin's last chance to use the API.
	// The plugin will be terminated shortly after this invocation.
	//
	// Go signature: OnDeactivate() error
	OnDeactivate(ctx context.Context, in *OnDeactivateRequest, opts ...grpc.CallOption) (*OnDeactivateResponse, error)
	// OnConfigurationChange is invoked when configuration changes may have been made.
	// Any returned error is logged but does not stop the plugin.
	// It is called once before OnActivate.
	//
	// Go signature: OnConfigurationChange() error
	OnConfigurationChange(ctx context.Context, in *OnConfigurationChangeRequest, opts ...grpc.CallOption) (*OnConfigurationChangeResponse, error)
	// OnInstall is invoked after the installation of a plugin as part of onboarding.
	// It's called on every installation, not only once.
	//
	// Go signature: OnInstall(c *Context, event model.OnInstallEvent) error
	OnInstall(ctx context.Context, in *OnInstallRequest, opts ...grpc.CallOption) (*OnInstallResponse, error)
	// OnSendDailyTelemetry is invoked when the server sends daily telemetry data.
	// Plugins can use this to send their own telemetry metrics.
	//
	// Go signature: OnSendDailyTelemetry()
	OnSendDailyTelemetry(ctx context.Context, in *OnSendDailyTelemetryRequest, opts ...grpc.CallOption) (*OnSendDailyTelemetryResponse, error)
	// RunDataRetention is invoked during a DataRetentionJob.
	// Plugins should delete data older than their retention policy.
	//
	// Go signature: RunDataRetention(nowTime, batchSize int64) (int64, error)
	RunDataRetention(ctx context.Context, in *RunDataRetentionRequest, opts ...grpc.CallOption) (*RunDataRetentionResponse, error)
	// OnCloudLimitsUpdated is invoked when cloud product limits change.
	// For example, when plan tiers change affecting storage or message limits.
	//
	// Go signature: OnCloudLimitsUpdated(limits *model.ProductLimits)
	OnCloudLimitsUpdated(ctx context.Context, in *OnCloudLimitsUpdatedRequest, opts ...grpc.CallOption) (*OnCloudLimitsUpdatedResponse, error)
	// ConfigurationWillBeSaved is invoked before saving configuration to the backing store.
	// An error can be returned to reject the operation.
	// Additionally, a new config object can be returned to be stored in place of the provided one.
	//
	// Go signature: ConfigurationWillBeSaved(newCfg *model.Config) (*model.Config, error)
	ConfigurationWillBeSaved(ctx context.Context, in *ConfigurationWillBeSavedRequest, opts ...grpc.CallOption) (*ConfigurationWillBeSavedResponse, error)
}

type pluginHooksClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginHooksClient(cc grpc.ClientConnInterface) PluginHooksClient {
	return &pluginHooksClient{cc}
}

func (c *pluginHooksClient) Implemented(ctx context.Context, in *ImplementedRequest, opts ...grpc.CallOption) (*ImplementedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplementedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_Implemented_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnActivate(ctx context.Context, in *OnActivateRequest, opts ...grpc.CallOption) (*OnActivateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnActivateResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnActivate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnDeactivate(ctx context.Context, in *OnDeactivateRequest, opts ...grpc.CallOption) (*OnDeactivateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnDeactivateResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnDeactivate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnConfigurationChange(ctx context.Context, in *OnConfigurationChangeRequest, opts ...grpc.CallOption) (*OnConfigurationChangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnConfigurationChangeResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnConfigurationChange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnInstall(ctx context.Context, in *OnInstallRequest, opts ...grpc.CallOption) (*OnInstallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnInstallResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnInstall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnSendDailyTelemetry(ctx context.Context, in *OnSendDailyTelemetryRequest, opts ...grpc.CallOption) (*OnSendDailyTelemetryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnSendDailyTelemetryResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnSendDailyTelemetry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) RunDataRetention(ctx context.Context, in *RunDataRetentionRequest, opts ...grpc.CallOption) (*RunDataRetentionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunDataRetentionResponse)
	err := c.cc.Invoke(ctx, PluginHooks_RunDataRetention_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) OnCloudLimitsUpdated(ctx context.Context, in *OnCloudLimitsUpdatedRequest, opts ...grpc.CallOption) (*OnCloudLimitsUpdatedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnCloudLimitsUpdatedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_OnCloudLimitsUpdated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginHooksClient) ConfigurationWillBeSaved(ctx context.Context, in *ConfigurationWillBeSavedRequest, opts ...grpc.CallOption) (*ConfigurationWillBeSavedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigurationWillBeSavedResponse)
	err := c.cc.Invoke(ctx, PluginHooks_ConfigurationWillBeSaved_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginHooksServer is the server API for PluginHooks service.
// All implementations must embed UnimplementedPluginHooksServer
// for forward compatibility.
//
// PluginHooks is the gRPC service for invoking plugin hooks.
// The server acts as the gRPC client, calling into the plugin process.
// The plugin acts as the gRPC server, implementing the hook handlers.
type PluginHooksServer interface {
	// Implemented returns the list of hooks that the plugin implements.
	// Called during plugin startup to optimize hook dispatch.
	// Plugins that don't implement this are assumed to implement all hooks.
	//
	// Go signature: Implemented() ([]string, error)
	Implemented(context.Context, *ImplementedRequest) (*ImplementedResponse, error)
	// OnActivate is invoked when the plugin is activated.
	// If an error is returned, the plugin will be terminated.
	// The plugin will not receive hooks until after OnActivate returns without error.
	// OnConfigurationChange will be called once before OnActivate.
	//
	// Go signature: OnActivate() error
	OnActivate(context.Context, *OnActivateRequest) (*OnActivateResponse, error)
	// OnDeactivate is invoked when the plugin is deactivated.
	// This is the plugin's last chance to use the API.
	// The plugin will be terminated shortly after this invocation.
	//
	// Go signature: OnDeactivate() error
	OnDeactivate(context.Context, *OnDeactivateRequest) (*OnDeactivateResponse, error)
	// OnConfigurationChange is invoked when configuration changes may have been made.
	// Any returned error is logged but does not stop the plugin.
	// It is called once before OnActivate.
	//
	// Go signature: OnConfigurationChange() error
	OnConfigurationChange(context.Context, *OnConfigurationChangeRequest) (*OnConfigurationChangeResponse, error)
	// OnInstall is invoked after the installation of a plugin as part of onboarding.
	// It's called on every installation, not only once.
	//
	// Go signature: OnInstall(c *Context, event model.OnInstallEvent) error
	OnInstall(context.Context, *OnInstallRequest) (*OnInstallResponse, error)
	// OnSendDailyTelemetry is invoked when the server sends daily telemetry data.
	// Plugins can use this to send their own telemetry metrics.
	//
	// Go signature: OnSendDailyTelemetry()
	OnSendDailyTelemetry(context.Context, *OnSendDailyTelemetryRequest) (*OnSendDailyTelemetryResponse, error)
	// RunDataRetention is invoked during a DataRetentionJob.
	// Plugins should delete data older than their retention policy.
	//
	// Go signature: RunDataRetention(nowTime, batchSize int64) (int64, error)
	RunDataRetention(context.Context, *RunDataRetentionRequest) (*RunDataRetentionResponse, error)
	// OnCloudLimitsUpdated is invoked when cloud product limits change.
	// For example, when plan tiers change affecting storage or message limits.
	//
	// Go signature: OnCloudLimitsUpdated(limits *model.ProductLimits)
	OnCloudLimitsUpdated(context.Context, *OnCloudLimitsUpdatedRequest) (*OnCloudLimitsUpdatedResponse, error)
	// ConfigurationWillBeSaved is invoked before saving configuration to the backing store.
	// An error can be returned to reject the operation.
	// Additionally, a new config object can be returned to be stored in place of the provided one.
	//
	// Go signature: ConfigurationWillBeSaved(newCfg *model.Config) (*model.Config, error)
	ConfigurationWillBeSaved(context.Context, *ConfigurationWillBeSavedRequest) (*ConfigurationWillBeSavedResponse, error)
	mustEmbedUnimplementedPluginHooksServer()
}

// UnimplementedPluginHooksServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPluginHooksServer struct{}

func (UnimplementedPluginHooksServer) Implemented(context.Context, *ImplementedRequest) (*ImplementedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Implemented not implemented")
}
func (UnimplementedPluginHooksServer) OnActivate(context.Context, *OnActivateRequest) (*OnActivateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnActivate not implemented")
}
func (UnimplementedPluginHooksServer) OnDeactivate(context.Context, *OnDeactivateRequest) (*OnDeactivateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnDeactivate not implemented")
}
func (UnimplementedPluginHooksServer) OnConfigurationChange(context.Context, *OnConfigurationChangeRequest) (*OnConfigurationChangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnConfigurationChange not implemented")
}
func (UnimplementedPluginHooksServer) OnInstall(context.Context, *OnInstallRequest) (*OnInstallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnInstall not implemented")
}
func (UnimplementedPluginHooksServer) OnSendDailyTelemetry(context.Context, *OnSendDailyTelemetryRequest) (*OnSendDailyTelemetryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnSendDailyTelemetry not implemented")
}
func (UnimplementedPluginHooksServer) RunDataRetention(context.Context, *RunDataRetentionRequest) (*RunDataRetentionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunDataRetention not implemented")
}
func (UnimplementedPluginHooksServer) OnCloudLimitsUpdated(context.Context, *OnCloudLimitsUpdatedRequest) (*OnCloudLimitsUpdatedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnCloudLimitsUpdated not implemented")
}
func (UnimplementedPluginHooksServer) ConfigurationWillBeSaved(context.Context, *ConfigurationWillBeSavedRequest) (*ConfigurationWillBeSavedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigurationWillBeSaved not implemented")
}
func (UnimplementedPluginHooksServer) mustEmbedUnimplementedPluginHooksServer() {}
func (UnimplementedPluginHooksServer) testEmbeddedByValue()                     {}

// UnsafePluginHooksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginHooksServer will
// result in compilation errors.
type UnsafePluginHooksServer interface {
	mustEmbedUnimplementedPluginHooksServer()
}

func RegisterPluginHooksServer(s grpc.ServiceRegistrar, srv PluginHooksServer) {
	// If the following call pancis, it indicates UnimplementedPluginHooksServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PluginHooks_ServiceDesc, srv)
}

func _PluginHooks_Implemented_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImplementedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).Implemented(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_Implemented_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).Implemented(ctx, req.(*ImplementedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnActivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnActivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnActivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnActivate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnActivate(ctx, req.(*OnActivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnDeactivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnDeactivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnDeactivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnDeactivate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnDeactivate(ctx, req.(*OnDeactivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnConfigurationChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnConfigurationChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnConfigurationChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnConfigurationChange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnConfigurationChange(ctx, req.(*OnConfigurationChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnInstall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnInstallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnInstall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnInstall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnInstall(ctx, req.(*OnInstallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnSendDailyTelemetry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnSendDailyTelemetryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnSendDailyTelemetry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnSendDailyTelemetry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnSendDailyTelemetry(ctx, req.(*OnSendDailyTelemetryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_RunDataRetention_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunDataRetentionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).RunDataRetention(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_RunDataRetention_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).RunDataRetention(ctx, req.(*RunDataRetentionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_OnCloudLimitsUpdated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnCloudLimitsUpdatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).OnCloudLimitsUpdated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_OnCloudLimitsUpdated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).OnCloudLimitsUpdated(ctx, req.(*OnCloudLimitsUpdatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginHooks_ConfigurationWillBeSaved_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigurationWillBeSavedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginHooksServer).ConfigurationWillBeSaved(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginHooks_ConfigurationWillBeSaved_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginHooksServer).ConfigurationWillBeSaved(ctx, req.(*ConfigurationWillBeSavedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PluginHooks_ServiceDesc is the grpc.ServiceDesc for PluginHooks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginHooks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mattermost.pluginapi.v1.PluginHooks",
	HandlerType: (*PluginHooksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Implemented",
			Handler:    _PluginHooks_Implemented_Handler,
		},
		{
			MethodName: "OnActivate",
			Handler:    _PluginHooks_OnActivate_Handler,
		},
		{
			MethodName: "OnDeactivate",
			Handler:    _PluginHooks_OnDeactivate_Handler,
		},
		{
			MethodName: "OnConfigurationChange",
			Handler:    _PluginHooks_OnConfigurationChange_Handler,
		},
		{
			MethodName: "OnInstall",
			Handler:    _PluginHooks_OnInstall_Handler,
		},
		{
			MethodName: "OnSendDailyTelemetry",
			Handler:    _PluginHooks_OnSendDailyTelemetry_Handler,
		},
		{
			MethodName: "RunDataRetention",
			Handler:    _PluginHooks_RunDataRetention_Handler,
		},
		{
			MethodName: "OnCloudLimitsUpdated",
			Handler:    _PluginHooks_OnCloudLimitsUpdated_Handler,
		},
		{
			MethodName: "ConfigurationWillBeSaved",
			Handler:    _PluginHooks_ConfigurationWillBeSaved_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hooks.proto",
}
