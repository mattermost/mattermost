// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

package license

import (
	"regexp"
	"strings"

	"golang.org/x/tools/go/analysis"
)

var Analyzer = &analysis.Analyzer{
	Name: "license",
	Doc:  "check the license header.",
	Run:  run,
}

var EEAnalyzer = &analysis.Analyzer{
	Name: "enterpriseLicense",
	Doc:  "check the license header for enterprise code.",
	Run:  run,
}

var sourceAvailablePackagePrefixRe = regexp.MustCompile("^github.com/mattermost/mattermost/server/v[0-9]+/enterprise")

func run(pass *analysis.Pass) (interface{}, error) {
	const mockeryHeader = "// Code generated by mockery"
	const goGenerateHeader = "//go:generate"
	const bindataHeader = "by go-bindata DO NOT EDIT. (@generated)"
	const buildTag = "// +build"

	const licenseLine1 = "// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved."
	const defaultLicenseLine2 = "// See LICENSE.txt for license information."
	const enterpriseLicenseLine2 = "// See ENTERPRISE-LICENSE.txt and SOURCE-CODE-LICENSE.txt for license information."
	const sourceAvailableLicenseLine2 = "// See LICENSE.enterprise for license information."

	for _, file := range pass.Files {
		licenseLine2 := defaultLicenseLine2
		if pass.Analyzer.Name == "enterpriseLicense" {
			// Closed source enterprise license
			licenseLine2 = enterpriseLicenseLine2
		} else if sourceAvailablePackagePrefixRe.MatchString(pass.Pkg.Path()) {
			// Source available license
			licenseLine2 = sourceAvailableLicenseLine2
		}

		// Ignore file copied from enterprise
		fileObj := pass.Fset.File(file.Pos())
		if strings.HasSuffix(fileObj.Name(), "imports/imports.go") {
			continue
		}

		if len(file.Comments) == 0 {
			pass.Reportf(file.Pos(), "License not found")
			continue
		}

		if len(file.Comments[0].List) == 0 {
			pass.Reportf(file.Pos(), "License not found or wrong")
			continue
		}

		if strings.HasPrefix(file.Comments[0].List[0].Text, mockeryHeader) {
			continue
		}

		if strings.HasSuffix(file.Comments[0].List[0].Text, bindataHeader) {
			continue
		}

		commentGroup := 0
		if strings.HasPrefix(file.Comments[0].List[0].Text, goGenerateHeader) || strings.HasPrefix(file.Comments[0].List[0].Text, buildTag) {
			if len(file.Comments[0].List) > 1 {
				pass.Reportf(file.Pos(), "Must be an empty line between the build directive and the license")
				continue
			}
			commentGroup++
		}

		if len(file.Comments) < commentGroup+1 {
			pass.Reportf(file.Pos(), "License not found")
			continue
		}

		if len(file.Comments[commentGroup].List) < 2 {
			pass.Reportf(file.Pos(), "License not found or wrong")
			continue
		}

		if file.Comments[commentGroup].List[0].Text != licenseLine1 {
			pass.Reportf(file.Comments[0].List[0].Pos(), "License wrong:\n\tseen:\n\t%s\n\t%s\n\n\texpected:\n\t%s\n\t%s", file.Comments[0].List[0].Text, file.Comments[0].List[1].Text, licenseLine1, licenseLine2)
			continue
		}

		if file.Comments[commentGroup].List[1].Text != licenseLine2 {
			pass.Reportf(file.Comments[0].List[1].Pos(), "License wrong:\n\tseen:\n\t%s\n\t%s\n\n\texpected:\n\t%s\n\t%s", file.Comments[0].List[0].Text, file.Comments[0].List[1].Text, licenseLine1, licenseLine2)
			continue
		}
	}
	return nil, nil
}
