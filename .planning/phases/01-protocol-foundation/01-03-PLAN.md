## Phase 1 — Protocol Foundation
## Plan 01-03: Error handling + common RPC patterns

### Objective

Define **shared protobuf types and conventions** that every future Plugin API method and hook RPC will use:
- A protobuf representation of `model.AppError`
- A consistent request/response “envelope” pattern for RPCs (to apply in Phase 2 + 3)
- Common metadata types (request IDs, plugin IDs) for logging/debuggability

### Execution Context

- **Project state / roadmap / research**
  - `@.planning/STATE.md`
  - `@.planning/ROADMAP.md`
  - `@.planning/PROJECT.md`
  - `@.planning/phases/01-protocol-foundation/01-RESEARCH.md`
- **Canonical error + dynamic JSON types**
  - `@server/public/model/utils.go` (`AppError`, `StringInterface`)
- **Existing plugin RPC system (for behavior reference)**
  - `@server/public/plugin/client_rpc.go`
  - `@server/public/plugin/api.go`
  - `@server/public/plugin/hooks.go`
- **Prerequisite plans**
  - `@.planning/phases/01-protocol-foundation/01-01-PLAN.md`
  - `@.planning/phases/01-protocol-foundation/01-02-PLAN.md`

### Decision (make this explicit before coding)

Choose the error propagation strategy for the gRPC layer.

- **Option A — gRPC status only**: return non-OK gRPC status for business errors (clients handle exceptions)
  - Pros: idiomatic gRPC, middleware/interceptors can reason about failures
  - Cons: mapping Mattermost HTTP-ish errors → gRPC codes is lossy; Python parsing of rich details is extra work
- **Option B — Response-embedded `AppError` (recommended for v1)**: transport is OK; business errors are encoded in the response message
  - Pros: closest to current Go plugin API semantics (`(*T, *AppError)`), easiest cross-language
  - Cons: gRPC layer can’t distinguish success/failure without looking at payload

**Recommendation**: **Option B** for initial parity and simplicity. Reserve gRPC status errors for transport failures (timeouts, handshake, unavailable plugin).

### Mandatory Discovery (Levels 1–2)

- [ ] **L1 — Confirm current `AppError` fields**
  - Read `server/public/model/utils.go` and list the fields that must be represented:
    - `Id`, `Message`, `DetailedError`, `RequestId`, `StatusCode`, `Where`
    - `params` exists but is not serialized to JSON; decide whether to include it in protobuf for debugging or omit
- [ ] **L2 — Confirm how errors are used in plugin API**
  - Spot-check a handful of methods in `server/public/plugin/api.go` that return `*model.AppError`
  - Spot-check `client_rpc.go` for current error propagation patterns to ensure we don’t lose semantics unintentionally

### Tasks

- [ ] **Define `AppError` in protobuf**
  - [ ] Add (or update) a proto file under `server/public/pluginapi/grpc/proto/`:
    - Prefer `errors.proto` (or keep everything in `common.proto` if you’re keeping Phase 1 very small)
  - [ ] Define `AppError` with a close mapping to `model.AppError`:
    - `string id`
    - `string message`
    - `string detailed_error`
    - `string request_id`
    - `int32 status_code`
    - `string where`
  - [ ] Decide how to represent params:
    - If you need it: use `google.protobuf.Struct params = N;`
    - If you don’t: omit it (simpler)

- [ ] **Define request metadata types**
  - [ ] Add a `RequestContext` message (in `common.proto` or `context.proto`), intended to be embedded in every request message:
    - `string plugin_id` (logical plugin identifier, not process PID)
    - `string request_id` (correlate logs across Go server + Python plugin)
    - (optional) `string session_id` / `string user_id` if needed for auditing later

- [ ] **Lock in RPC envelope conventions (used in Phase 2 + 3)**
  - [ ] Document these conventions in comments inside the relevant proto file(s) (no new standalone Markdown docs):
    - Every RPC takes `FooRequest` and returns `FooResponse`
    - Every request has `RequestContext context = 1;` (reserve tag 1)
    - Every response has `AppError error = 1;` (or reserve a standard tag, e.g., `error = 999;` — pick one and be consistent)
    - If a method returns a value, put it in the response as a field (or `oneof result`)
  - [ ] If you choose `error = 1` in responses, ensure it doesn’t collide with the “context = 1” convention in requests.

- [ ] **Regenerate + compile**

```bash
cd server
make proto-gen
make test-public
```

### Verification

- `make proto-gen` succeeds and generates Go code for the new/updated proto files.
- `make test-public` succeeds.
- The conventions are clear enough that Phase 2/3 can implement dozens/hundreds of RPCs consistently without re-litigating patterns.

### Success Criteria

- A protobuf `AppError` exists and is ready to be referenced everywhere.
- A `RequestContext` exists for consistent request metadata.
- Clear, enforceable request/response conventions are defined (in proto comments + this plan), unblocking Phase 2 + Phase 3.

### Output

- **New/updated proto files** in `server/public/pluginapi/grpc/proto/`:
  - `errors.proto` (or `common.proto` updated)
  - `context.proto` (or `common.proto` updated)
- **Regenerated Go code** in `server/public/pluginapi/grpc/generated/go/`


