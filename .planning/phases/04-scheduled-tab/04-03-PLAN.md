---
phase: 04-scheduled-tab
plan: 03
type: execute
wave: 3
depends_on: [04-02]
files_modified:
  - webapp/channels/src/components/recaps/scheduled_recap_item.tsx
  - webapp/channels/src/components/recaps/scheduled_recap_item.scss
  - webapp/channels/src/components/recaps/schedule_display.tsx
  - webapp/channels/src/i18n/en.json
autonomous: true

must_haves:
  truths:
    - "ScheduledRecapItem component renders scheduled recap card"
    - "Schedule display shows smart day groupings and next run time"
    - "Pause/resume toggle is interactive"
    - "Run stats appear on hover"
    - "Kebab menu has Edit and Delete options"
  artifacts:
    - path: "webapp/channels/src/components/recaps/scheduled_recap_item.tsx"
      provides: "Scheduled recap card component"
      contains: "ScheduledRecapItem"
    - path: "webapp/channels/src/components/recaps/schedule_display.tsx"
      provides: "Schedule formatting utilities"
      contains: "formatScheduleDisplay"
    - path: "webapp/channels/src/i18n/en.json"
      provides: "i18n strings for scheduled recaps"
      contains: "recaps.scheduled"
  key_links:
    - from: "webapp/channels/src/components/recaps/scheduled_recap_item.tsx"
      to: "webapp/channels/src/packages/mattermost-redux/src/actions/recaps.ts"
      via: "useDispatch + pause/resume actions"
      pattern: "dispatch.*pauseScheduledRecap|resumeScheduledRecap"
---

<objective>
Create the ScheduledRecapItem component for displaying scheduled recap cards

Purpose: Provide the UI card that shows scheduled recap info with pause/resume toggle, run stats, and kebab menu
Output: Reusable component matching Figma collapsed recap card design
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-scheduled-tab/04-CONTEXT.md
@.planning/codebase/CONVENTIONS.md

# Reference existing recap item for patterns
@webapp/channels/src/components/recaps/recap_item.tsx
@webapp/channels/src/components/recaps/recap_menu.tsx
@webapp/channels/src/components/recaps/recaps.scss

# Reference Toggle component
@webapp/channels/src/components/toggle.tsx

# Reference ConfirmModal
@webapp/channels/src/components/confirm_modal.tsx

# Types
@webapp/platform/types/src/recaps.ts

# i18n patterns
@webapp/channels/src/i18n/en.json (search for "recaps.")
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add i18n strings for scheduled recaps</name>
  <files>webapp/channels/src/i18n/en.json</files>
  <action>
Add i18n strings for the scheduled recap UI. Add these after existing recap strings (around line 5540):

```json
"recaps.scheduled.tab": "Scheduled",
"recaps.scheduled.active": "Active",
"recaps.scheduled.paused": "Paused",
"recaps.scheduled.lastRun": "Last run: {date}",
"recaps.scheduled.runCount": "{count} {count, plural, one {run} other {runs}}",
"recaps.scheduled.neverRun": "Never run",
"recaps.scheduled.nextRun": "Next: {date}",
"recaps.scheduled.pauseToast": "Schedule paused",
"recaps.scheduled.resumeToast": "Schedule resumed",
"recaps.scheduled.deleteToast": "Schedule deleted",
"recaps.scheduled.menu.edit": "Edit",
"recaps.scheduled.menu.delete": "Delete",
"recaps.scheduled.delete.title": "Delete scheduled recap?",
"recaps.scheduled.delete.message": "Are you sure you want to delete <strong>{title}</strong>? This scheduled recap will stop running.",
"recaps.scheduled.delete.button": "Delete",
"recaps.scheduled.emptyState.title": "Set up your first recap",
"recaps.scheduled.emptyState.description": "Copilot recaps help you get caught up quickly on discussions that are most important to you with a summarized report.",
"recaps.scheduled.emptyState.cta": "Create a recap",
"recaps.scheduled.days.weekdays": "Weekdays",
"recaps.scheduled.days.weekend": "Weekends",
"recaps.scheduled.days.everyday": "Every day",
"recaps.scheduled.days.sun": "Sun",
"recaps.scheduled.days.mon": "Mon",
"recaps.scheduled.days.tue": "Tue",
"recaps.scheduled.days.wed": "Wed",
"recaps.scheduled.days.thu": "Thu",
"recaps.scheduled.days.fri": "Fri",
"recaps.scheduled.days.sat": "Sat",
"recaps.scheduled.scheduleFormat": "{days} at {time}",
```

Note: Keep JSON valid - add commas appropriately based on position.
  </action>
  <verify>JSON is valid: `cd webapp/channels/src/i18n && python3 -c "import json; json.load(open('en.json'))"`</verify>
  <done>All scheduled recap i18n strings added to en.json</done>
</task>

<task type="auto">
  <name>Task 2: Create schedule display utility component</name>
  <files>webapp/channels/src/components/recaps/schedule_display.tsx</files>
  <action>
Create a utility component/functions for formatting schedule display strings:

```typescript
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import {useIntl} from 'react-intl';

// Day-of-week bitmask constants (matching Go model)
const Sunday = 1 << 0;    // 1
const Monday = 1 << 1;    // 2
const Tuesday = 1 << 2;   // 4
const Wednesday = 1 << 3; // 8
const Thursday = 1 << 4;  // 16
const Friday = 1 << 5;    // 32
const Saturday = 1 << 6;  // 64

const Weekdays = Monday | Tuesday | Wednesday | Thursday | Friday; // 62
const Weekend = Saturday | Sunday; // 65
const EveryDay = Weekdays | Weekend; // 127

type DayInfo = {
    bit: number;
    key: string;
};

const DAYS: DayInfo[] = [
    {bit: Sunday, key: 'sun'},
    {bit: Monday, key: 'mon'},
    {bit: Tuesday, key: 'tue'},
    {bit: Wednesday, key: 'wed'},
    {bit: Thursday, key: 'thu'},
    {bit: Friday, key: 'fri'},
    {bit: Saturday, key: 'sat'},
];

export function useScheduleDisplay() {
    const {formatMessage, formatDate, formatTime} = useIntl();

    const formatDaysOfWeek = (daysOfWeek: number): string => {
        // Check for special groupings
        if (daysOfWeek === EveryDay) {
            return formatMessage({id: 'recaps.scheduled.days.everyday', defaultMessage: 'Every day'});
        }
        if (daysOfWeek === Weekdays) {
            return formatMessage({id: 'recaps.scheduled.days.weekdays', defaultMessage: 'Weekdays'});
        }
        if (daysOfWeek === Weekend) {
            return formatMessage({id: 'recaps.scheduled.days.weekend', defaultMessage: 'Weekends'});
        }

        // Build abbreviated day list
        const selectedDays = DAYS
            .filter((day) => (daysOfWeek & day.bit) !== 0)
            .map((day) => formatMessage({id: `recaps.scheduled.days.${day.key}`, defaultMessage: day.key.charAt(0).toUpperCase() + day.key.slice(1)}));

        return selectedDays.join(', ');
    };

    const formatTimeOfDay = (timeOfDay: string): string => {
        // timeOfDay is "HH:MM" format
        const [hours, minutes] = timeOfDay.split(':').map(Number);
        const date = new Date();
        date.setHours(hours, minutes, 0, 0);

        // Use locale-appropriate time format (12-hour by default)
        return formatTime(date, {hour: 'numeric', minute: '2-digit'});
    };

    const formatSchedule = (daysOfWeek: number, timeOfDay: string): string => {
        const days = formatDaysOfWeek(daysOfWeek);
        const time = formatTimeOfDay(timeOfDay);
        return formatMessage(
            {id: 'recaps.scheduled.scheduleFormat', defaultMessage: '{days} at {time}'},
            {days, time},
        );
    };

    const formatNextRun = (nextRunAt: number, enabled: boolean): string | null => {
        // Paused schedules hide next run
        if (!enabled || nextRunAt === 0) {
            return null;
        }

        const nextDate = new Date(nextRunAt);
        const now = new Date();
        const diffDays = Math.ceil((nextDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

        let dateStr: string;
        if (diffDays <= 0) {
            // Today
            dateStr = formatTime(nextDate, {hour: 'numeric', minute: '2-digit'});
        } else if (diffDays === 1) {
            // Tomorrow
            dateStr = `Tomorrow at ${formatTime(nextDate, {hour: 'numeric', minute: '2-digit'})}`;
        } else if (diffDays <= 7) {
            // Within a week - show day name
            dateStr = formatDate(nextDate, {weekday: 'long'}) + ' at ' + formatTime(nextDate, {hour: 'numeric', minute: '2-digit'});
        } else {
            // Beyond a week - show date
            dateStr = formatDate(nextDate, {month: 'short', day: 'numeric'}) + ' at ' + formatTime(nextDate, {hour: 'numeric', minute: '2-digit'});
        }

        return formatMessage(
            {id: 'recaps.scheduled.nextRun', defaultMessage: 'Next: {date}'},
            {date: dateStr},
        );
    };

    const formatLastRun = (lastRunAt: number): string => {
        if (lastRunAt === 0) {
            return formatMessage({id: 'recaps.scheduled.neverRun', defaultMessage: 'Never run'});
        }

        const date = new Date(lastRunAt);
        const dateStr = formatDate(date, {month: 'short', day: 'numeric', year: 'numeric'});
        return formatMessage(
            {id: 'recaps.scheduled.lastRun', defaultMessage: 'Last run: {date}'},
            {date: dateStr},
        );
    };

    const formatRunCount = (count: number): string => {
        return formatMessage(
            {id: 'recaps.scheduled.runCount', defaultMessage: '{count} {count, plural, one {run} other {runs}}'},
            {count},
        );
    };

    return {
        formatDaysOfWeek,
        formatTimeOfDay,
        formatSchedule,
        formatNextRun,
        formatLastRun,
        formatRunCount,
    };
}

export default useScheduleDisplay;
```
  </action>
  <verify>TypeScript compiles: `cd webapp && npm run check-types 2>&1 | head -20`</verify>
  <done>useScheduleDisplay hook exports formatting functions for days, time, schedule, next run, last run, run count</done>
</task>

<task type="auto">
  <name>Task 3: Create ScheduledRecapItem component</name>
  <files>webapp/channels/src/components/recaps/scheduled_recap_item.tsx</files>
  <action>
Create the scheduled recap card component:

```typescript
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useState, useCallback, useMemo} from 'react';
import {useIntl, FormattedMessage} from 'react-intl';
import {useDispatch} from 'react-redux';

import {DotsHorizontalIcon, PencilOutlineIcon, TrashCanOutlineIcon} from '@mattermost/compass-icons/components';
import type {ScheduledRecap} from '@mattermost/types/recaps';

import {pauseScheduledRecap, resumeScheduledRecap, deleteScheduledRecap} from 'mattermost-redux/actions/recaps';

import ConfirmModal from 'components/confirm_modal';
import * as Menu from 'components/menu';
import Toggle from 'components/toggle';

import {useScheduleDisplay} from './schedule_display';

type Props = {
    scheduledRecap: ScheduledRecap;
    onEdit: (id: string) => void;
};

const ScheduledRecapItem = ({scheduledRecap, onEdit}: Props) => {
    const {formatMessage} = useIntl();
    const dispatch = useDispatch();
    const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
    const [isHovered, setIsHovered] = useState(false);
    const [isToggling, setIsToggling] = useState(false);

    const {formatSchedule, formatNextRun, formatLastRun, formatRunCount} = useScheduleDisplay();

    const scheduleText = formatSchedule(scheduledRecap.days_of_week, scheduledRecap.time_of_day);
    const nextRunText = formatNextRun(scheduledRecap.next_run_at, scheduledRecap.enabled);
    const lastRunText = formatLastRun(scheduledRecap.last_run_at);
    const runCountText = formatRunCount(scheduledRecap.run_count);

    const handleToggle = useCallback(async () => {
        if (isToggling) {
            return;
        }
        setIsToggling(true);

        try {
            if (scheduledRecap.enabled) {
                await dispatch(pauseScheduledRecap(scheduledRecap.id));
                // TODO: Show toast "Schedule paused"
            } else {
                await dispatch(resumeScheduledRecap(scheduledRecap.id));
                // TODO: Show toast "Schedule resumed"
            }
        } finally {
            setIsToggling(false);
        }
    }, [dispatch, scheduledRecap.id, scheduledRecap.enabled, isToggling]);

    const handleDelete = useCallback(async () => {
        await dispatch(deleteScheduledRecap(scheduledRecap.id));
        setShowDeleteConfirm(false);
        // TODO: Show toast "Schedule deleted"
    }, [dispatch, scheduledRecap.id]);

    const handleEdit = useCallback(() => {
        onEdit(scheduledRecap.id);
    }, [onEdit, scheduledRecap.id]);

    const menuId = `scheduled-recap-menu-${scheduledRecap.id}`;
    const buttonId = `${menuId}-button`;

    return (
        <div
            className='scheduled-recap-item'
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
        >
            <div className='scheduled-recap-item-content'>
                <div className='scheduled-recap-item-main'>
                    <h3 className='scheduled-recap-item-title'>{scheduledRecap.title}</h3>
                    <div className='scheduled-recap-item-subtitle'>
                        <span className='schedule-pattern'>{scheduleText}</span>
                        {nextRunText && (
                            <>
                                <span className='metadata-separator'>{'·'}</span>
                                <span className='next-run'>{nextRunText}</span>
                            </>
                        )}
                    </div>
                </div>

                <div className='scheduled-recap-item-actions'>
                    {/* Run stats - visible on hover */}
                    <div className={`scheduled-recap-run-stats ${isHovered ? 'visible' : ''}`}>
                        <span className='run-stat'>{lastRunText}</span>
                        <span className='metadata-separator'>{'·'}</span>
                        <span className='run-stat'>{runCountText}</span>
                    </div>

                    {/* Active/Paused toggle */}
                    <div className='scheduled-recap-toggle'>
                        <Toggle
                            id={`toggle-${scheduledRecap.id}`}
                            toggled={scheduledRecap.enabled}
                            onToggle={handleToggle}
                            disabled={isToggling}
                            size='btn-sm'
                            onText={formatMessage({id: 'recaps.scheduled.active', defaultMessage: 'Active'})}
                            offText={formatMessage({id: 'recaps.scheduled.paused', defaultMessage: 'Paused'})}
                        />
                    </div>

                    {/* Kebab menu */}
                    <Menu.Container
                        menuButton={{
                            id: buttonId,
                            class: 'scheduled-recap-menu-button',
                            'aria-label': formatMessage({id: 'recaps.menu.ariaLabel', defaultMessage: 'Options for {title}'}, {title: scheduledRecap.title}),
                            children: <DotsHorizontalIcon size={16}/>,
                        }}
                        menu={{
                            id: menuId,
                            'aria-label': formatMessage({id: 'recaps.menu.ariaLabel', defaultMessage: 'Options for {title}'}, {title: scheduledRecap.title}),
                        }}
                        anchorOrigin={{
                            vertical: 'bottom',
                            horizontal: 'right',
                        }}
                        transformOrigin={{
                            vertical: 'top',
                            horizontal: 'right',
                        }}
                    >
                        <Menu.Item
                            leadingElement={<PencilOutlineIcon size={18}/>}
                            labels={<span>{formatMessage({id: 'recaps.scheduled.menu.edit', defaultMessage: 'Edit'})}</span>}
                            onClick={handleEdit}
                        />
                        <Menu.Item
                            leadingElement={<TrashCanOutlineIcon size={18}/>}
                            labels={<span>{formatMessage({id: 'recaps.scheduled.menu.delete', defaultMessage: 'Delete'})}</span>}
                            onClick={() => setShowDeleteConfirm(true)}
                            isDestructive={true}
                        />
                    </Menu.Container>
                </div>
            </div>

            {/* Delete confirmation modal */}
            <ConfirmModal
                show={showDeleteConfirm}
                title={formatMessage({id: 'recaps.scheduled.delete.title', defaultMessage: 'Delete scheduled recap?'})}
                message={
                    <FormattedMessage
                        id='recaps.scheduled.delete.message'
                        defaultMessage='Are you sure you want to delete <strong>{title}</strong>? This scheduled recap will stop running.'
                        values={{
                            title: scheduledRecap.title,
                            strong: (chunks: React.ReactNode) => <strong>{chunks}</strong>,
                        }}
                    />
                }
                confirmButtonText={formatMessage({id: 'recaps.scheduled.delete.button', defaultMessage: 'Delete'})}
                confirmButtonClass='btn btn-danger'
                onConfirm={handleDelete}
                onCancel={() => setShowDeleteConfirm(false)}
                onExited={() => setShowDeleteConfirm(false)}
            />
        </div>
    );
};

export default ScheduledRecapItem;
```
  </action>
  <verify>TypeScript compiles: `cd webapp && npm run check-types 2>&1 | head -20`</verify>
  <done>ScheduledRecapItem component renders card with title, schedule, toggle, run stats on hover, and kebab menu</done>
</task>

<task type="auto">
  <name>Task 4: Add ScheduledRecapItem styles</name>
  <files>webapp/channels/src/components/recaps/scheduled_recap_item.scss</files>
  <action>
Create SCSS file for the scheduled recap item component. Match existing recap card design:

```scss
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

.scheduled-recap-item {
    padding: 16px 24px;
    border: 1px solid rgba(var(--center-channel-color-rgb), 0.12);
    border-radius: var(--radius-s);
    background-color: var(--center-channel-bg);
    transition: all 0.2s;

    &:hover {
        background-color: rgba(var(--center-channel-color-rgb), 0.04);
    }

    .scheduled-recap-item-content {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
    }

    .scheduled-recap-item-main {
        min-width: 0;
        flex: 1;
    }

    .scheduled-recap-item-title {
        margin: 0 0 4px;
        color: var(--center-channel-color);
        font-family: 'Metropolis', sans-serif;
        font-size: 16px;
        font-weight: 600;
        line-height: 24px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .scheduled-recap-item-subtitle {
        display: flex;
        align-items: center;
        color: rgba(var(--center-channel-color-rgb), 0.64);
        font-size: 12px;
        gap: 6px;
        line-height: 16px;

        .metadata-separator {
            color: rgba(var(--center-channel-color-rgb), 0.40);
        }

        .next-run {
            color: rgba(var(--center-channel-color-rgb), 0.72);
        }
    }

    .scheduled-recap-item-actions {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .scheduled-recap-run-stats {
        display: flex;
        align-items: center;
        color: rgba(var(--center-channel-color-rgb), 0.56);
        font-size: 11px;
        gap: 6px;
        opacity: 0;
        transition: opacity 0.2s;

        &.visible {
            opacity: 1;
        }

        .metadata-separator {
            color: rgba(var(--center-channel-color-rgb), 0.32);
        }
    }

    .scheduled-recap-toggle {
        .btn-toggle {
            min-width: 72px;
        }
    }

    .scheduled-recap-menu-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        padding: 0;
        border: none;
        border-radius: var(--radius-s);
        background: none;
        color: rgba(var(--center-channel-color-rgb), 0.56);
        cursor: pointer;

        &:hover {
            background-color: rgba(var(--center-channel-color-rgb), 0.08);
            color: var(--center-channel-color);
        }
    }
}
```
  </action>
  <verify>File exists: `ls -la webapp/channels/src/components/recaps/scheduled_recap_item.scss`</verify>
  <done>SCSS file created with card, title, subtitle, actions, run stats hover, toggle, and menu button styles</done>
</task>

</tasks>

<verification>
- [ ] i18n strings added for all scheduled recap UI text
- [ ] useScheduleDisplay hook formats days, time, schedule, next run, last run, run count
- [ ] ScheduledRecapItem displays title, schedule pattern, next run time
- [ ] Toggle shows Active/Paused and calls pause/resume actions
- [ ] Run stats (last run, run count) appear on hover
- [ ] Kebab menu has Edit and Delete options
- [ ] Delete triggers confirmation modal
- [ ] TypeScript compiles successfully
</verification>

<success_criteria>
ScheduledRecapItem renders a card for a scheduled recap with all required UI elements. Toggle interaction calls Redux actions. Delete shows confirm modal.
</success_criteria>

<output>
After completion, create `.planning/phases/04-scheduled-tab/04-03-SUMMARY.md`
</output>
