# Phase 8 — ServeHTTP Streaming
# Plan 08-02 — HTTP response streaming + flush (Python → Go)

<objective>
Replace the temporary “buffered response” behavior from 08-01 with true, bounded-memory HTTP response streaming from Python plugins back to the Mattermost server (Go) over gRPC.

This plan focuses on:
- Streaming response body chunks to the client as they are produced (no full buffering)
- Correct header + status semantics (write-once behavior, default status, multi-value headers)
- Best-effort flush support (`http.Flusher` parity)
- Full-duplex behavior and early responses (plugin may respond before request body fully consumed)
- Robust error handling (invalid status codes, plugin aborts, cancellation)

Non-goals for this plan:
- Hijack/WebSocket upgrade tunneling (covered in 08-03)
</objective>

<execution_context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/PROJECT.md
@.planning/phases/08-servehttp-streaming/08-RESEARCH.md
@.planning/phases/08-servehttp-streaming/08-01-PLAN.md

@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md

Baseline semantics for response writing + flush:
@server/public/plugin/http.go
@server/public/plugin/http_test.go
</execution_context>

<context>
## What “correct” means (parity targets)

In the current Go plugin RPC implementation:
- Headers are mutable until the first write / writeHeader.
- Status code must be valid (100–999); invalid status codes are rejected to prevent panics (see `httpResponseWriterRPCServer.WriteHeader`).
- Flush is best-effort:
  - If the underlying response writer supports `http.Flusher`, it flushes.
  - Otherwise flush is a no-op (see `TestFlushGracefulDegradation`).

For gRPC ServeHTTP streaming, we must preserve these semantics while eliminating response-body buffering.

## Key design choices
- Prefer an explicit response-init message containing status + headers.
- Stream body as `bytes` chunks thereafter.
- Represent flush as an explicit control message (or a flag on body chunks) so the Python side can request it.
- Avoid using gRPC metadata for arbitrary HTTP headers unless there’s a shared, already-established header encoding in Phase 1.
</context>

<discovery>
### Level 0 (must)
- Confirm the exact ServeHTTP proto contract and Go/Python stream implementations produced by 08-01.
- Identify how the Go side currently writes the “temporary” buffered response and where to replace it with streaming.

### Level 1 (must)
- Identify how errors are surfaced in your gRPC hook layer:
  - How does the Go side map gRPC status codes to HTTP responses?
  - How do Python hook exceptions propagate to Go?

### Level 2 (recommended)
- Determine whether any existing plugin routes rely on:
  - Response trailers
  - 1xx informational responses (e.g., 100-continue)
  - Very large responses (downloads)
  - If unclear, design the proto to be forward-compatible, but keep v1 behavior strict and documented.
</discovery>

<tasks>
## 1) Protobuf contract extensions (response streaming + flush)
- [ ] **Extend/confirm response message shape** to support:
  - Response init (status_code + headers)
  - Response body chunk (bytes)
  - Response complete marker
  - Flush marker (best-effort)
- [ ] **Define invariants** in comments + docs:
  - Exactly one response-init must be sent (explicitly or implicitly on first body chunk)
  - Status defaults to 200 if not set before first body write
  - Headers are only accepted before the first body write / first response-init
  - Flush may be sent any time after response-init; Go ignores flush if underlying writer doesn’t support it

## 2) Go: stream response directly to `http.ResponseWriter`
- [ ] **Implement full-duplex stream handling**:
  - Send request body chunks in one goroutine
  - Receive response messages concurrently in another goroutine
  - Support early response:
    - If plugin completes response early, stop reading from request body and cancel sending
    - Ensure request body read loop terminates promptly when response path ends
- [ ] **Implement response-init application**:
  - Validate status code range (100–999) to avoid panic (match `http.go` semantics)
  - Apply headers before calling `WriteHeader`
  - Apply default status code (200) if plugin never sends an explicit status and writes body
- [ ] **Stream body chunks**:
  - Write each incoming chunk to `http.ResponseWriter` as received
  - Do not buffer entire response in memory
  - Surface write errors (client disconnect, broken pipe) by cancelling the gRPC stream
- [ ] **Flush support**:
  - On flush message: if `w` implements `http.Flusher`, call `Flush()`, else no-op
  - Never panic if flush unsupported (explicit parity with `TestFlushGracefulDegradation`)
- [ ] **Error handling**:
  - If plugin aborts before sending response-init: return `500` (or a well-defined default) and log with context
  - If invalid status code received: log error and return `500`
  - Ensure errors do not leave streams/goroutines running

## 3) Python: streaming response writer abstraction
- [ ] **Implement a Python response writer** (SDK-level) that can:
  - Set headers (multi-value)
  - Set status code
  - Write body chunks (bytes)
  - Flush (best-effort signal)
  - Close / complete
- [ ] **Send response-init deterministically**:
  - On explicit `write_header(status)` or first `write(body)`:
    - Emit response-init exactly once
    - Lock headers thereafter
- [ ] **Stream bytes without buffering**:
  - Allow plugin to yield chunks from an async generator
  - Enforce max chunk size guidance (<= 64KB recommended) but do not require exact sizes
- [ ] **Cancellation & error propagation**:
  - If Go cancels the stream, ensure Python stops producing chunks promptly
  - If plugin raises, abort with structured gRPC error so Go can map to `500`

## 4) Tests
- [ ] **Go unit test: response streaming writes incrementally**
  - Use a custom `http.ResponseWriter` that records writes and flush calls
  - Fake plugin gRPC server sends:
    - response-init (status + headers)
    - multiple body chunks
    - flush markers interleaved
  - Assert:
    - headers/status applied once
    - body writes happen in chunk order
    - flush invoked when supported, and ignored safely when not supported
- [ ] **Go unit test: invalid status codes don’t panic**
  - Fake plugin sends status 42 or 1000
  - Assert Go returns `500` and logs error
- [ ] **Go unit test: early response cancels request send**
  - Create a request body reader that blocks unless read
  - Plugin responds immediately and completes
  - Assert request send loop stops (no deadlock / leak)
- [ ] **Python unit tests (if available)**
  - Validate response writer behavior (header locking, implicit init, flush messaging)
</tasks>

<checkpoints>
- Checkpoint A: Proto supports response-init/body/complete/flush messages
- Checkpoint B: Go streams response chunks to client without buffering
- Checkpoint C: Flush semantics match current Go plugin behavior (best-effort, no panics)
- Checkpoint D: Full-duplex works and early responses terminate request streaming cleanly
</checkpoints>

<verification>
- Run Go tests for the ServeHTTP gRPC bridge package(s)
- Run existing plugin HTTP tests to ensure no regressions in the Go net/rpc path:
  - `go test ./server/public/plugin/...`

Optional targeted runs (depending on where new tests land):
- `go test ./server/channels/app -run TestPluginHTTPUpgradeWebSocket` (should remain unchanged and pass)
</verification>

<success_criteria>
- HTTP responses from Python plugins are streamed to clients in bounded memory (no full buffering).
- Status code + header semantics match Go plugin behavior (including invalid status protection).
- Flush is best-effort and never panics when unsupported.
- Implementation supports full-duplex streaming and early responses without goroutine leaks.
</success_criteria>

<output>
Expected outputs (exact paths depend on Phase 1–7 decisions; discovery step must confirm):
- Updated ServeHTTP proto contract supporting response streaming + flush
- Go implementation streaming response chunks directly to `http.ResponseWriter`
- Python SDK response-writer implementation for streaming + flush
- Go tests for streaming, flush behavior, invalid status handling, and early-response flow
</output>


