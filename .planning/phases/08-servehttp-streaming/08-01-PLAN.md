# Phase 8 — ServeHTTP Streaming
# Plan 08-01 — HTTP request streaming (Go → Python)

<objective>
Implement streaming transport for the ServeHTTP hook request path from the Mattermost server (Go) to Python plugins over gRPC, without buffering entire request bodies in memory.

This plan focuses on:
- Request metadata marshaling (method, URL, headers, remote addr, etc.)
- Request body streaming in bounded chunks (default 64KB)
- Cancellation propagation (HTTP client disconnect → gRPC cancellation)

Non-goals for this plan:
- Fully streaming responses to the HTTP client (covered in 08-02)
- Hijack/WebSocket upgrade support (covered in 08-03)
</objective>

<execution_context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/PROJECT.md
@.planning/phases/08-servehttp-streaming/08-RESEARCH.md

@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STRUCTURE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md
@.planning/codebase/CONCERNS.md

Baseline (current Go plugin RPC implementation):
@server/public/plugin/hooks.go
@server/public/plugin/client_rpc.go
@server/public/plugin/http.go
@server/public/plugin/hijack.go

Reference tests illustrating current ServeHTTP capabilities:
@server/channels/app/plugin_api_test.go
@server/channels/app/plugin_api_tests/manual.test_http_hijack_plugin/main.go
@server/channels/app/plugin_api_tests/manual.test_http_upgrade_websocket_plugin/main.go
</execution_context>

<context>
## Why this exists

Mattermost’s existing Go plugin system proxies ServeHTTP via `net/rpc` and `MuxBroker`:
- Request metadata is forwarded via `HTTPRequestSubset` (see `server/public/plugin/client_rpc.go`).
- Request bodies are streamed over a separate `MuxBroker` connection (see `ServeHTTP` implementation in `hooksRPCClient` / `hooksRPCServer`).
- Response writing (and hijack) is proxied via additional RPC plumbing (see `server/public/plugin/http.go` and `server/public/plugin/hijack.go`).

For Python plugins, we need a language-agnostic transport. gRPC streaming replaces the “extra connections” pattern and allows bounded-memory body transfer.

## Constraints
- Backward compatibility: existing Go plugins must remain unchanged and continue using the current `net/rpc` path.
- Full parity is the end goal, but this plan only tackles request streaming; response streaming and hijack are handled in later plans.
- Body transfer must be chunked (start with 64KB as per Phase 8 research) to avoid OOM on large uploads.
- HTTP cancellation must propagate: if the client disconnects, server-side request context is cancelled and the gRPC stream must terminate promptly.

## Key semantics to preserve
- Forward all HTTP request headers (including `Mattermost-User-Id` when present).
- Preserve multi-value headers (e.g., `Set-Cookie`) and binary-safe values.
- Preserve key request identity fields: method, URL, host, remote addr, request URI, proto version.
</context>

<discovery>
Perform the following before implementing:

### Level 0 (must)
- Locate where earlier phases defined the gRPC hook service and protobuf codegen outputs:
  - Search for existing `.proto` packages/services that correspond to hooks (especially `ServeHTTP`).
  - Identify the Go package(s) where the gRPC hook client is/will be implemented.
  - Identify the Python SDK/server package and how hook handlers are registered (Phase 7 output).

### Level 1 (must)
- Confirm how plugin HTTP routing works today:
  - Find where requests to `/plugins/{id}` are routed and how `Hooks.ServeHTTP` is invoked.
  - Identify the abstraction boundary where protocol-specific dispatch can occur (Go plugin vs Python plugin).

### Level 2 (recommended)
- Confirm header handling requirements:
  - Identify any server-side middleware that injects headers for plugin routes (e.g., auth).
  - Verify whether any headers are intentionally stripped/rewritten.

### Level 3 (optional spike)
- Prototype a minimal bidi stream handler in Go + Python that:
  - Streams a 1–5MB request body in chunks
  - Verifies chunk boundaries and ordering
  - Cancels mid-stream and confirms both sides exit promptly
</discovery>

<tasks>
## 1) Protobuf contract (request-focused, forward-compatible)
- [ ] **Locate existing hook proto definitions** created in Phases 1–3; if a ServeHTTP RPC already exists, reuse/extend it rather than adding a parallel endpoint.
- [ ] **Define/confirm message types** that can support request streaming now and response streaming later.
  - Minimum fields for request init:
    - method
    - url (string form; avoid custom URL type unless already standardized)
    - proto / proto_major / proto_minor (or just proto string)
    - host
    - remote_addr
    - request_uri
    - headers (must support multi-value)
  - Body chunk message:
    - bytes body_chunk
    - bool body_complete (or an explicit end-of-stream message)
  - Decide and document how headers are encoded:
    - Prefer a repeated header message type like: `{ key, repeated values }` (or reuse a shared header type if Phase 1 already introduced one).
    - Avoid gRPC metadata for arbitrary HTTP headers unless you explicitly handle key collisions and size limits.
- [ ] **Specify chunking**: default 64KB; document where this constant lives and how (if at all) it’s configured.
- [ ] **Specify cancellation behavior**: the gRPC stream context must be derived from `*http.Request.Context()`.

## 2) Go: stream request body to the Python plugin
- [ ] **Add protocol dispatch point** (if not already present from earlier phases) so that:
  - Go plugins continue using existing `net/rpc` ServeHTTP path
  - Python plugins use the gRPC ServeHTTP path
- [ ] **Implement request init mapping** from `*http.Request` to the proto request-init message:
  - Include request headers (including `Mattermost-User-Id` when present)
  - Include method, URL, host, remote addr, request URI, protocol
- [ ] **Implement bounded streaming of `r.Body`**:
  - Read via `io.Reader` with a reusable buffer of size 64KB
  - Send each chunk on the stream; never `io.ReadAll`
  - Handle `nil` body as empty
  - Ensure `r.Body.Close()` behavior matches current server expectations
- [ ] **Propagate cancellation**:
  - Use `ctx := r.Context()` for the stream
  - Abort send loop promptly when `ctx.Done()` fires
- [ ] **Minimal end-to-end response handling (temporary)**:
  - Receive the plugin response but it may be buffered in-memory in this plan
  - Write a simple HTTP response to `http.ResponseWriter` sufficient to validate the request path
  - Put explicit TODO notes for 08-02 to replace buffering with streaming writes

## 3) Python: reconstruct request and expose a streaming body interface
- [ ] **Implement the gRPC hook server method** for ServeHTTP (async, using `grpc.aio`) consistent with Phase 7 patterns.
- [ ] **Parse the request-init message** into a Python request object:
  - method, url, headers, remote_addr, host, request_uri, proto
- [ ] **Expose body as an async iterator** (or equivalent) over bytes:
  - The Python hook implementation must be able to consume chunks incrementally
  - Provide a helper to buffer fully only when the plugin explicitly requests it (e.g., `.read_all()`), not by default
- [ ] **Handle cancellation**:
  - Ensure the async iterator exits if `context.cancelled()` / stream termination occurs
  - Ensure server doesn’t leak tasks/generators on client disconnect
- [ ] **Return a minimal response** compatible with Go’s temporary buffering behavior in this plan (e.g., status + headers + body as a single chunk).

## 4) Tests (Go unit/integration at the protocol boundary)
- [ ] **Go unit test: request chunking**:
  - Use an `httptest.NewRequest` with a large body (>= 1MB)
  - Use a fake Python gRPC server that asserts:
    - Receives the init message first
    - Receives body chunks <= 64KB
    - Reconstructs the full body correctly
- [ ] **Go unit test: cancellation**:
  - Cancel the request context mid-stream and assert:
    - Sender stops reading from body
    - gRPC stream terminates
    - No goroutine leaks (use timeouts / leak detectors if available in repo)
- [ ] **Python unit test (if Python test harness exists by Phase 6/7)**:
  - Validate request parsing and body iterator behavior
</tasks>

<checkpoints>
- Checkpoint A: Protobuf contract exists and is code-generated in Go + Python
- Checkpoint B: Go can stream request init + body chunks to a fake plugin server without buffering
- Checkpoint C: Python can reconstruct request and expose body as streaming iterator
- Checkpoint D: Cancellation stops streaming promptly on both sides
</checkpoints>

<verification>
Minimum verification (expected to be runnable during execution of this plan):
- Run Go unit tests for the new gRPC ServeHTTP request-streaming bridge package(s)
- Run targeted plugin package tests:
  - `go test ./server/public/plugin/...`

Notes:
- Existing websocket/hijack tests (e.g. `TestPluginHTTPUpgradeWebSocket`) validate the Go net/rpc path and should remain unaffected.
- End-to-end Python plugin ServeHTTP integration tests may require Phase 5/6 infrastructure (supervisor + SDK) to be in place; if so, keep the new tests at the protocol boundary.
</verification>

<success_criteria>
- Go streams HTTP request bodies to Python over gRPC in bounded chunks (default 64KB), without `io.ReadAll`.
- Multi-value headers and required request fields are preserved.
- Cancelling the HTTP request context cancels the gRPC stream and does not leak goroutines/tasks.
- A minimal response path exists to validate end-to-end request delivery (even if response is buffered for now).
</success_criteria>

<output>
Expected outputs (exact paths depend on Phase 1–7 decisions; discovery step must confirm):
- Updated/added hook `.proto` definitions for ServeHTTP request streaming
- Go implementation for streaming request → plugin over gRPC (plus minimal response handling)
- Python gRPC hook server implementation for ServeHTTP that can consume streaming request bodies
- Go tests validating chunking + cancellation
</output>


