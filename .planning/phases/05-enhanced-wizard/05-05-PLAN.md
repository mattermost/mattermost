---
phase: 05-enhanced-wizard
plan: 05
type: execute
wave: 3
depends_on: [05-01, 05-03, 05-04]
files_modified:
  - webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx
  - webapp/channels/src/components/create_recap_modal/index.ts
autonomous: true

must_haves:
  truths:
    - "User can complete wizard from Step 1 to Step 3 (or Step 2 if run once)"
    - "Run once skips Step 3 and creates immediate recap"
    - "Scheduled flow shows Step 3 and creates scheduled recap"
    - "Edit mode pre-fills all fields from existing scheduled recap"
    - "Edit mode title shows 'Edit your recap'"
    - "Validation blocks navigation on invalid fields"
    - "New scheduled recap appears in list after creation"
  artifacts:
    - path: "webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx"
      provides: "Complete wizard with edit mode and schedule step"
      min_lines: 300
      contains: "editScheduledRecap"
    - path: "webapp/channels/src/components/create_recap_modal/index.ts"
      provides: "Module exports"
  key_links:
    - from: "create_recap_modal.tsx"
      to: "createScheduledRecap action"
      via: "dispatch"
      pattern: "dispatch.*createScheduledRecap"
    - from: "create_recap_modal.tsx"
      to: "updateScheduledRecap action"
      via: "dispatch"
      pattern: "dispatch.*updateScheduledRecap"
    - from: "create_recap_modal.tsx"
      to: "ScheduleConfiguration component"
      via: "import and render"
      pattern: "ScheduleConfiguration"
---

<objective>
Integrate all wizard components into CreateRecapModal with edit mode and run once flow

Purpose: This is the main integration plan that ties together all the new components (DayOfWeekSelector, ScheduleConfiguration) with the existing modal, adds edit mode support, run once flow, validation, and API submission.

Output: Fully functional wizard that can create/edit scheduled recaps
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-enhanced-wizard/05-CONTEXT.md
@.planning/phases/05-enhanced-wizard/05-RESEARCH.md

Reference files:
@webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx (current implementation)
@webapp/channels/src/components/create_recap_modal/schedule_configuration.tsx (created in 05-03)
@webapp/channels/src/components/create_recap_modal/recap_configuration.tsx (updated in 05-04)
@webapp/channels/src/packages/mattermost-redux/src/actions/recaps.ts (actions from 05-01)
@webapp/channels/src/packages/mattermost-redux/src/selectors/entities/timezone.ts (getCurrentTimezone)
@webapp/platform/types/src/recaps.ts (ScheduledRecap, ScheduledRecapInput types)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schedule state and edit mode props to modal</name>
  <files>webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx</files>
  <action>
Update the modal component to support scheduled recap creation and edit mode:

1. Update imports to add:
```typescript
import type {ScheduledRecap, ScheduledRecapInput} from '@mattermost/types/recaps';
import {createScheduledRecap, updateScheduledRecap} from 'mattermost-redux/actions/recaps';
import {getCurrentTimezone} from 'mattermost-redux/selectors/entities/timezone';
import ScheduleConfiguration from './schedule_configuration';
```

2. Update Props type:
```typescript
type Props = {
    onExited: () => void;
    editScheduledRecap?: ScheduledRecap;  // When present, modal is in edit mode
};
```

3. Add new state variables after existing state declarations:
```typescript
// Schedule state
const [runOnce, setRunOnce] = useState(false);
const [daysOfWeek, setDaysOfWeek] = useState<number>(0);
const [timeOfDay, setTimeOfDay] = useState<string>('09:00');
const [timePeriod, setTimePeriod] = useState<string>('last_24h');
const [customInstructions, setCustomInstructions] = useState<string>('');

// Validation state
const [daysError, setDaysError] = useState(false);
const [timeError, setTimeError] = useState(false);

// Get user timezone
const userTimezone = useSelector(getCurrentTimezone);

// Edit mode detection
const isEditMode = Boolean(editScheduledRecap);
```

4. Add useEffect to pre-fill values in edit mode (add after existing useEffects):
```typescript
// Pre-fill form for edit mode
useEffect(() => {
    if (editScheduledRecap) {
        setRecapName(editScheduledRecap.title);
        setRecapType(editScheduledRecap.channel_mode === 'all_unreads' ? 'all_unreads' : 'selected');
        setSelectedChannelIds(editScheduledRecap.channel_ids || []);
        setDaysOfWeek(editScheduledRecap.days_of_week);
        setTimeOfDay(editScheduledRecap.time_of_day);
        setTimePeriod(editScheduledRecap.time_period);
        setCustomInstructions(editScheduledRecap.custom_instructions || '');
        setSelectedBotId(editScheduledRecap.agent_id);
        // Don't set runOnce in edit mode - it's always a scheduled recap
    }
}, [editScheduledRecap]);
```

This task adds the state foundation. Subsequent tasks wire up the logic.
  </action>
  <verify>grep -q "editScheduledRecap" webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx && grep -q "daysOfWeek" webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx</verify>
  <done>Modal has schedule state, edit mode prop, and pre-fill useEffect</done>
</task>

<task type="auto">
  <name>Task 2: Update step navigation logic for run once and schedule flows</name>
  <files>webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx</files>
  <action>
Update the navigation logic to handle both run once and scheduled flows:

1. Update getTotalSteps():
```typescript
const getTotalSteps = () => {
    if (runOnce) {
        // Run once: Step 1 (config) -> Step 2 (channels or summary)
        return 2;
    }
    // Scheduled: Step 1 (config) -> Step 2 (channels or summary) -> Step 3 (schedule)
    return recapType === 'all_unreads' ? 2 : 3;  // all_unreads skips channel selector in scheduled mode too
};
```

Wait - this logic needs to be clearer. Let me provide the complete flow:

**Run once flow:**
- Step 1: Name + Type + Run once toggle
- Step 2: Channels (if selected) OR Summary (if all_unreads)
- Submit creates immediate recap (existing behavior)

**Scheduled flow:**
- Step 1: Name + Type (run once toggle unchecked)
- Step 2: Channels (if selected) OR nothing if all_unreads (channels resolved at run time)
- Step 3: Schedule configuration
- Submit creates scheduled recap

Actually, looking at CONTEXT.md: "All unreads" shows confirmation text only, no channel selector — channels determined at generation time. So for scheduled recaps:

Update getTotalSteps():
```typescript
const getTotalSteps = () => {
    if (runOnce) {
        // Run once: same as current behavior
        return recapType === 'all_unreads' ? 2 : 3;
    }
    // Scheduled: always 3 steps (config -> channels/confirmation -> schedule)
    return 3;
};
```

Update getActualStep() to map internal step to display step:
```typescript
const getActualStep = () => {
    if (runOnce) {
        // Run once uses existing step mapping
        if (recapType === 'all_unreads') {
            return currentStep === 1 ? 1 : 2;
        }
        return currentStep;
    }
    // Scheduled always shows 3 steps
    return currentStep;
};
```

2. Update handleNext() to handle the schedule step:
```typescript
const handleNext = useCallback(() => {
    // Clear validation errors
    setDaysError(false);
    setTimeError(false);
    
    if (currentStep === 1) {
        if (recapType === 'all_unreads') {
            // For all unreads, set channels and go to step 2 (summary for run once, schedule for scheduled)
            setSelectedChannelIds(unreadChannels.map((c: Channel) => c.id));
            setCurrentStep(runOnce ? 3 : 2);  // run once goes to summary (step 3), scheduled goes to step 2
        } else {
            // For selected channels, go to channel selector
            setCurrentStep(2);
        }
    } else if (currentStep === 2) {
        // From step 2, go to step 3 (summary for run once, schedule for scheduled)
        setCurrentStep(3);
    }
}, [currentStep, recapType, unreadChannels, runOnce]);
```

Wait, this is getting complex. Let me reconsider the step mapping:

**For clarity, let's use these internal steps:**
- Step 1: Configuration (name, type, run once)
- Step 2: Channels (only for "selected" type)
- Step 3: Summary (for run once) OR Schedule (for scheduled)
- Step 4: Schedule configuration (only for scheduled + selected channels)

Actually this is overcomplicating. Let me follow CONTEXT.md more closely:

From CONTEXT.md:
- "Run once" toggle on Step 1
- When checked: Skip Step 3 (schedule config) entirely
- Step 2 (channels) becomes the final step for run once

So the step flow should be:
- **Run once + selected:** 1 (config) → 2 (channels) → submit
- **Run once + all_unreads:** 1 (config) → 2 (summary) → submit  
- **Scheduled + selected:** 1 (config) → 2 (channels) → 3 (schedule) → submit
- **Scheduled + all_unreads:** 1 (config) → 2 (confirmation) → 3 (schedule) → submit

Let me simplify handleNext:

```typescript
const handleNext = useCallback(() => {
    if (currentStep === 1) {
        if (recapType === 'all_unreads') {
            // For all unreads, skip channel selector
            setSelectedChannelIds(unreadChannels.map((c: Channel) => c.id));
            if (runOnce) {
                // Run once: go to summary (final step for run once)
                setCurrentStep(3);
            } else {
                // Scheduled: go to step 2 showing confirmation, then step 3 for schedule
                setCurrentStep(2);
            }
        } else {
            // For selected channels, always go to channel selector
            setCurrentStep(2);
        }
    } else if (currentStep === 2) {
        // From channel selector/confirmation
        if (runOnce && recapType === 'selected') {
            // Run once with selected channels: go to summary
            setCurrentStep(3);
        } else if (!runOnce) {
            // Scheduled: go to schedule configuration
            setCurrentStep(3);
        }
        // Note: run once + all_unreads never hits step 2 (goes 1->3)
    }
}, [currentStep, recapType, unreadChannels, runOnce]);
```

Actually wait - for all_unreads in scheduled mode, step 2 should show a confirmation (not channel selector). Let me re-read channel_summary.tsx - it shows the selected channels list. For scheduled all_unreads, we don't know the channels yet.

Let me simplify: For scheduled + all_unreads, step 2 can show ChannelSummary with a message that channels will be determined at run time, OR we can skip directly to schedule config.

Decision: For scheduled + all_unreads, go directly from step 1 to step 3 (schedule config). The "all unreads" selection itself is the confirmation.

Final handleNext:
```typescript
const handleNext = useCallback(() => {
    if (currentStep === 1) {
        if (recapType === 'all_unreads') {
            setSelectedChannelIds(unreadChannels.map((c: Channel) => c.id));
            setCurrentStep(3); // Skip to step 3 (summary for run once, schedule for scheduled)
        } else {
            setCurrentStep(2); // Go to channel selector
        }
    } else if (currentStep === 2) {
        setCurrentStep(3); // Go to step 3
    }
}, [currentStep, recapType, unreadChannels]);
```

This matches the existing logic! The difference is what step 3 shows:
- Run once: ChannelSummary (submit button)
- Scheduled: ScheduleConfiguration (submit button)
  </action>
  <verify>grep -q "handleNext" webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx</verify>
  <done>Navigation handles run once vs scheduled flows correctly</done>
</task>

<task type="auto">
  <name>Task 3: Update renderStep to show ScheduleConfiguration for scheduled flow</name>
  <files>webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx</files>
  <action>
Update the renderStep function to conditionally show ScheduleConfiguration or ChannelSummary for step 3:

1. Update the RecapConfiguration call to pass new props:
```typescript
case 1:
    return (
        <RecapConfiguration
            recapName={recapName}
            setRecapName={setRecapName}
            recapType={recapType}
            setRecapType={setRecapType}
            unreadChannels={unreadChannels}
            runOnce={runOnce}
            setRunOnce={setRunOnce}
            isEditMode={isEditMode}
        />
    );
```

2. Update case 3 to conditionally render based on runOnce:
```typescript
case 3:
    if (runOnce) {
        // Run once: show summary
        return (
            <ChannelSummary
                selectedChannelIds={selectedChannelIds}
                myChannels={myChannels}
            />
        );
    }
    // Scheduled: show schedule configuration
    return (
        <ScheduleConfiguration
            daysOfWeek={daysOfWeek}
            setDaysOfWeek={setDaysOfWeek}
            timeOfDay={timeOfDay}
            setTimeOfDay={setTimeOfDay}
            timePeriod={timePeriod}
            setTimePeriod={setTimePeriod}
            customInstructions={customInstructions}
            setCustomInstructions={setCustomInstructions}
            daysError={daysError}
            timeError={timeError}
        />
    );
```
  </action>
  <verify>grep -q "ScheduleConfiguration" webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx && grep -q "runOnce" webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx</verify>
  <done>renderStep shows ScheduleConfiguration for scheduled flow, ChannelSummary for run once</done>
</task>

<task type="auto">
  <name>Task 4: Update handleSubmit for both immediate and scheduled recaps</name>
  <files>webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx</files>
  <action>
Update handleSubmit to dispatch appropriate action based on mode:

```typescript
const handleSubmit = useCallback(async () => {
    // Validation
    if (selectedChannelIds.length === 0 && recapType === 'selected') {
        setError(formatMessage({id: 'recaps.modal.error.noChannels', defaultMessage: 'Please select at least one channel.'}));
        return;
    }

    if (!currentUserId) {
        return;
    }

    if (!selectedBotId) {
        setError(formatMessage({id: 'recaps.modal.error.noBot', defaultMessage: 'Please select an AI agent.'}));
        return;
    }

    // For scheduled recaps, validate schedule fields
    if (!runOnce && !isEditMode) {
        if (daysOfWeek === 0) {
            setDaysError(true);
            setError(formatMessage({id: 'recaps.modal.error.noDays', defaultMessage: 'Please select at least one day.'}));
            return;
        }
        if (!timeOfDay) {
            setTimeError(true);
            setError(formatMessage({id: 'recaps.modal.error.noTime', defaultMessage: 'Please select a time.'}));
            return;
        }
    }

    // For edit mode, validate schedule fields
    if (isEditMode) {
        if (daysOfWeek === 0) {
            setDaysError(true);
            setError(formatMessage({id: 'recaps.modal.error.noDays', defaultMessage: 'Please select at least one day.'}));
            return;
        }
        if (!timeOfDay) {
            setTimeError(true);
            setError(formatMessage({id: 'recaps.modal.error.noTime', defaultMessage: 'Please select a time.'}));
            return;
        }
    }

    setIsSubmitting(true);
    setError(null);

    try {
        if (runOnce) {
            // Run once: create immediate recap (existing behavior)
            await dispatch(createRecap(recapName, selectedChannelIds, selectedBotId));
        } else if (isEditMode && editScheduledRecap) {
            // Edit mode: update existing scheduled recap
            const input: ScheduledRecapInput = {
                title: recapName,
                days_of_week: daysOfWeek,
                time_of_day: timeOfDay,
                timezone: userTimezone || 'UTC',
                time_period: timePeriod,
                channel_mode: recapType === 'all_unreads' ? 'all_unreads' : 'specific',
                channel_ids: recapType === 'selected' ? selectedChannelIds : undefined,
                custom_instructions: customInstructions || undefined,
                agent_id: selectedBotId,
                is_recurring: true,
            };
            await dispatch(updateScheduledRecap(editScheduledRecap.id, input));
        } else {
            // Create new scheduled recap
            const input: ScheduledRecapInput = {
                title: recapName,
                days_of_week: daysOfWeek,
                time_of_day: timeOfDay,
                timezone: userTimezone || 'UTC',
                time_period: timePeriod,
                channel_mode: recapType === 'all_unreads' ? 'all_unreads' : 'specific',
                channel_ids: recapType === 'selected' ? selectedChannelIds : undefined,
                custom_instructions: customInstructions || undefined,
                agent_id: selectedBotId,
                is_recurring: true,
            };
            await dispatch(createScheduledRecap(input));
        }
        
        onExited();
        
        // Navigate to appropriate page
        if (runOnce) {
            history.push(`${url}/recaps`);  // Immediate recap list
        } else {
            history.push(`${url}/recaps?tab=scheduled`);  // Scheduled tab
        }
    } catch (err) {
        const errorMsg = runOnce 
            ? formatMessage({id: 'recaps.modal.error.createFailed', defaultMessage: 'Failed to create recap. Please try again.'})
            : formatMessage({id: 'recaps.modal.error.scheduleFailed', defaultMessage: 'Failed to save scheduled recap. Please try again.'});
        setError(errorMsg);
        setIsSubmitting(false);
    }
}, [
    selectedChannelIds, 
    currentUserId, 
    selectedBotId, 
    runOnce, 
    isEditMode, 
    editScheduledRecap,
    daysOfWeek, 
    timeOfDay, 
    timePeriod, 
    customInstructions, 
    userTimezone, 
    recapName, 
    recapType,
    dispatch, 
    onExited, 
    history, 
    url, 
    formatMessage,
]);
```

Note: Import ScheduledRecapInput from types at the top of the file.
  </action>
  <verify>grep -q "createScheduledRecap" webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx && grep -q "updateScheduledRecap" webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx</verify>
  <done>handleSubmit dispatches createScheduledRecap for new schedules, updateScheduledRecap for edits, createRecap for run once</done>
</task>

<task type="auto">
  <name>Task 5: Update modal header and button text for edit mode</name>
  <files>webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx</files>
  <action>
Update the header and button text to reflect edit mode:

1. Update headerText to show different title in edit mode:
```typescript
const headerText = (
    <div className='create-recap-modal-header'>
        <span>
            {isEditMode 
                ? formatMessage({id: 'recaps.modal.titleEdit', defaultMessage: 'Edit your recap'})
                : formatMessage({id: 'recaps.modal.title', defaultMessage: 'Set up your recap'})
            }
        </span>
        <div className='create-recap-modal-header-actions'>
            <AgentDropdown
                showLabel={true}
                selectedBotId={selectedBotId}
                onBotSelect={handleBotSelect}
                bots={agents}
                defaultBotId={agents.length > 0 ? agents[0].id : undefined}
                disabled={isSubmitting}
                onMenuToggle={handleAgentMenuToggle}
            />
        </div>
    </div>
);
```

2. Update confirmButtonText to show appropriate text:
```typescript
const getConfirmButtonText = () => {
    const isFinalStep = currentStep === 3;
    
    if (!isFinalStep) {
        return formatMessage({id: 'generic_modal.next', defaultMessage: 'Next'});
    }
    
    if (runOnce) {
        return formatMessage({id: 'recaps.modal.startRecap', defaultMessage: 'Start recap'});
    }
    
    if (isEditMode) {
        return formatMessage({id: 'recaps.modal.saveChanges', defaultMessage: 'Save changes'});
    }
    
    return formatMessage({id: 'recaps.modal.createSchedule', defaultMessage: 'Create schedule'});
};

const confirmButtonText = getConfirmButtonText();
```

3. Update canProceed() to validate schedule step:
```typescript
const canProceed = () => {
    if (currentStep === 1) {
        return recapName.trim().length > 0 && recapType !== null && selectedBotId.length > 0;
    } else if (currentStep === 2) {
        return selectedChannelIds.length > 0;
    } else if (currentStep === 3) {
        if (runOnce) {
            // Run once summary step
            return selectedChannelIds.length > 0 && selectedBotId.length > 0;
        }
        // Schedule configuration step
        return daysOfWeek > 0 && timeOfDay.length > 0 && timePeriod.length > 0;
    }
    return false;
};
```
  </action>
  <verify>grep -q "titleEdit" webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx && grep -q "createSchedule" webapp/channels/src/components/create_recap_modal/create_recap_modal.tsx</verify>
  <done>Modal shows "Edit your recap" title in edit mode, appropriate button text for each state</done>
</task>

</tasks>

<verification>
All tasks complete when:
1. Modal accepts editScheduledRecap prop and pre-fills form in edit mode
2. Schedule state (daysOfWeek, timeOfDay, etc.) is managed
3. Run once flow skips schedule step and creates immediate recap
4. Scheduled flow shows schedule step and creates scheduled recap
5. Edit mode updates existing scheduled recap
6. Title changes to "Edit your recap" in edit mode
7. Button text appropriate for each state
8. Validation works for schedule fields
</verification>

<success_criteria>
- editScheduledRecap prop accepted and triggers pre-fill
- createScheduledRecap dispatched for new scheduled recaps
- updateScheduledRecap dispatched in edit mode
- createRecap dispatched for run once
- Navigation redirects to ?tab=scheduled after creating schedule
- All i18n message IDs used for text
</success_criteria>

<output>
After completion, create `.planning/phases/05-enhanced-wizard/05-05-SUMMARY.md`
</output>
