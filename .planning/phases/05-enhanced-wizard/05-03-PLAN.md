---
phase: 05-enhanced-wizard
plan: 03
type: execute
wave: 2
depends_on: [05-02]
files_modified:
  - webapp/channels/src/components/create_recap_modal/schedule_configuration.tsx
  - webapp/channels/src/components/create_recap_modal/create_recap_modal.scss
autonomous: true

must_haves:
  truths:
    - "User can select days of week using day buttons"
    - "User can select time of day from dropdown"
    - "User can select time period (previous day, last 3 days, last 7 days)"
    - "User can enter custom instructions in textarea"
    - "User sees next run preview after selecting days and time"
    - "Next run preview includes timezone"
  artifacts:
    - path: "webapp/channels/src/components/create_recap_modal/schedule_configuration.tsx"
      provides: "Step 3 schedule configuration UI"
      exports: ["ScheduleConfiguration"]
    - path: "webapp/channels/src/components/create_recap_modal/create_recap_modal.scss"
      provides: "Styles for schedule configuration step"
      contains: "step-three"
  key_links:
    - from: "schedule_configuration.tsx"
      to: "day_of_week_selector.tsx"
      via: "component import"
      pattern: "import DayOfWeekSelector"
    - from: "schedule_configuration.tsx"
      to: "timezone selector"
      via: "useSelector(getCurrentTimezone)"
      pattern: "getCurrentTimezone"
---

<objective>
Create ScheduleConfiguration component for Step 3

Purpose: Step 3 of the wizard shows schedule configuration: day selection, time picker, time period dropdown, custom instructions, and next run preview. This is the core of the scheduling feature.

Output: Complete schedule configuration step component with all form fields and real-time next run preview
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-enhanced-wizard/05-RESEARCH.md
@.planning/phases/05-enhanced-wizard/05-CONTEXT.md

Reference files:
@webapp/channels/src/components/create_recap_modal/day_of_week_selector.tsx (created in 05-02)
@webapp/channels/src/components/create_recap_modal/recap_configuration.tsx (existing step 1 pattern)
@webapp/channels/src/components/dropdown_input.tsx (for time period dropdown)
@webapp/channels/src/components/widgets/inputs/input/input.tsx (for textarea)
@webapp/channels/src/packages/mattermost-redux/src/selectors/entities/timezone.ts (getCurrentTimezone)
@webapp/channels/src/components/recaps/schedule_display.tsx (formatTimeOfDay pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScheduleConfiguration component</name>
  <files>webapp/channels/src/components/create_recap_modal/schedule_configuration.tsx</files>
  <action>
Create the Step 3 schedule configuration component:

```typescript
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import React, {useMemo} from 'react';
import {useIntl, FormattedMessage} from 'react-intl';
import {useSelector} from 'react-redux';

import {getCurrentTimezone, getCurrentTimezoneLabel} from 'mattermost-redux/selectors/entities/timezone';

import DropdownInput from 'components/dropdown_input';
import Input from 'components/widgets/inputs/input/input';

import DayOfWeekSelector from './day_of_week_selector';

type Props = {
    daysOfWeek: number;
    setDaysOfWeek: (days: number) => void;
    timeOfDay: string;
    setTimeOfDay: (time: string) => void;
    timePeriod: string;
    setTimePeriod: (period: string) => void;
    customInstructions: string;
    setCustomInstructions: (instructions: string) => void;
    daysError?: boolean;
    timeError?: boolean;
};

// Generate time options in 30-minute intervals
const generateTimeOptions = () => {
    const options = [];
    for (let hour = 0; hour < 24; hour++) {
        for (let minute = 0; minute < 60; minute += 30) {
            const h = hour.toString().padStart(2, '0');
            const m = minute.toString().padStart(2, '0');
            options.push(`${h}:${m}`);
        }
    }
    return options;
};

const TIME_OPTIONS = generateTimeOptions();

const ScheduleConfiguration = ({
    daysOfWeek,
    setDaysOfWeek,
    timeOfDay,
    setTimeOfDay,
    timePeriod,
    setTimePeriod,
    customInstructions,
    setCustomInstructions,
    daysError,
    timeError,
}: Props) => {
    const {formatMessage, formatTime, formatDate} = useIntl();
    const userTimezone = useSelector(getCurrentTimezone);
    const timezoneLabel = useSelector(getCurrentTimezoneLabel);

    // Time period options
    const timePeriodOptions = useMemo(() => [
        {value: 'last_24h', label: formatMessage({id: 'recaps.timePeriod.last24h', defaultMessage: 'Previous day'})},
        {value: 'last_3_days', label: formatMessage({id: 'recaps.timePeriod.last3days', defaultMessage: 'Last 3 days'})},
        {value: 'last_7_days', label: formatMessage({id: 'recaps.timePeriod.last7days', defaultMessage: 'Last 7 days'})},
    ], [formatMessage]);

    // Time dropdown options with locale-aware labels
    const timeOptions = useMemo(() => {
        return TIME_OPTIONS.map((time) => {
            const [hours, minutes] = time.split(':').map(Number);
            const date = new Date();
            date.setHours(hours, minutes, 0, 0);
            return {
                value: time,
                label: formatTime(date, {hour: 'numeric', minute: '2-digit'}),
            };
        });
    }, [formatTime]);

    // Calculate next run preview
    const nextRunPreview = useMemo(() => {
        if (daysOfWeek === 0 || !timeOfDay) {
            return null;
        }

        const [hours, minutes] = timeOfDay.split(':').map(Number);
        const now = new Date();
        
        // Find the next occurrence
        // Start from today and check each day
        for (let daysAhead = 0; daysAhead < 8; daysAhead++) {
            const checkDate = new Date(now);
            checkDate.setDate(now.getDate() + daysAhead);
            checkDate.setHours(hours, minutes, 0, 0);
            
            // Get day of week (0 = Sunday, 1 = Monday, etc.)
            const dayOfWeek = checkDate.getDay();
            const dayBit = 1 << dayOfWeek;
            
            // Check if this day is selected
            if ((daysOfWeek & dayBit) !== 0) {
                // Check if the time hasn't passed yet (or it's a future day)
                if (daysAhead > 0 || checkDate > now) {
                    // Format the preview
                    const diffDays = daysAhead;
                    let dateStr: string;
                    
                    if (diffDays === 0) {
                        dateStr = formatMessage(
                            {id: 'recaps.nextRun.today', defaultMessage: 'Today at {time}'},
                            {time: formatTime(checkDate, {hour: 'numeric', minute: '2-digit'})}
                        );
                    } else if (diffDays === 1) {
                        dateStr = formatMessage(
                            {id: 'recaps.nextRun.tomorrow', defaultMessage: 'Tomorrow at {time}'},
                            {time: formatTime(checkDate, {hour: 'numeric', minute: '2-digit'})}
                        );
                    } else if (diffDays <= 7) {
                        dateStr = formatMessage(
                            {id: 'recaps.nextRun.dayAt', defaultMessage: '{day} at {time}'},
                            {
                                day: formatDate(checkDate, {weekday: 'long'}),
                                time: formatTime(checkDate, {hour: 'numeric', minute: '2-digit'}),
                            }
                        );
                    } else {
                        dateStr = formatMessage(
                            {id: 'recaps.nextRun.dateAt', defaultMessage: '{date} at {time}'},
                            {
                                date: formatDate(checkDate, {month: 'short', day: 'numeric'}),
                                time: formatTime(checkDate, {hour: 'numeric', minute: '2-digit'}),
                            }
                        );
                    }
                    
                    // Add timezone
                    const tzAbbrev = timezoneLabel || userTimezone || '';
                    if (tzAbbrev) {
                        return `${dateStr} (${tzAbbrev})`;
                    }
                    return dateStr;
                }
            }
        }
        
        return null;
    }, [daysOfWeek, timeOfDay, formatMessage, formatTime, formatDate, userTimezone, timezoneLabel]);

    return (
        <div className='step-three'>
            {/* Days of week selection */}
            <div className='form-group'>
                <label className='form-label'>
                    <FormattedMessage
                        id='recaps.modal.selectDays'
                        defaultMessage='Select days'
                    />
                </label>
                <DayOfWeekSelector
                    value={daysOfWeek}
                    onChange={setDaysOfWeek}
                    error={daysError}
                />
                {daysError && (
                    <div className='form-error'>
                        <FormattedMessage
                            id='recaps.modal.selectDaysRequired'
                            defaultMessage='Please select at least one day'
                        />
                    </div>
                )}
            </div>

            {/* Time of day selection */}
            <div className='form-group'>
                <DropdownInput
                    name='timeOfDay'
                    legend={formatMessage({id: 'recaps.modal.selectTime', defaultMessage: 'Select time'})}
                    value={timeOptions.find((o) => o.value === timeOfDay)}
                    options={timeOptions}
                    onChange={(val) => setTimeOfDay(val.value)}
                    required={true}
                    error={timeError ? formatMessage({id: 'recaps.modal.selectTimeRequired', defaultMessage: 'Please select a time'}) : undefined}
                />
            </div>

            {/* Next run preview */}
            {nextRunPreview && (
                <div className='next-run-preview'>
                    <FormattedMessage
                        id='recaps.modal.nextRunPreview'
                        defaultMessage='Next recap: {preview}'
                        values={{preview: nextRunPreview}}
                    />
                </div>
            )}

            {/* Time period selection */}
            <div className='form-group'>
                <DropdownInput
                    name='timePeriod'
                    legend={formatMessage({id: 'recaps.modal.timePeriod', defaultMessage: 'Time period to cover'})}
                    value={timePeriodOptions.find((o) => o.value === timePeriod)}
                    options={timePeriodOptions}
                    onChange={(val) => setTimePeriod(val.value)}
                    required={true}
                />
            </div>

            {/* Custom instructions */}
            <div className='form-group'>
                <Input
                    type='textarea'
                    name='customInstructions'
                    label={formatMessage({id: 'recaps.modal.customInstructions', defaultMessage: 'Custom instructions (optional)'})}
                    placeholder={formatMessage({id: 'recaps.modal.customInstructionsPlaceholder', defaultMessage: 'Add any specific instructions for the AI...'})}
                    value={customInstructions}
                    onChange={(e) => setCustomInstructions(e.target.value)}
                    rows={3}
                    limit={500}
                />
            </div>
        </div>
    );
};

export default ScheduleConfiguration;
```

Key design decisions:
- Time picker uses 30-minute intervals (matching existing DateTimeInput pattern)
- Next run preview calculates client-side for real-time feedback
- Timezone from user settings, label from selector
- Error props for validation feedback from parent
- Uses existing DropdownInput and Input components
  </action>
  <verify>test -f webapp/channels/src/components/create_recap_modal/schedule_configuration.tsx && grep -q "ScheduleConfiguration" webapp/channels/src/components/create_recap_modal/schedule_configuration.tsx</verify>
  <done>ScheduleConfiguration component exists with day selector, time picker, time period dropdown, custom instructions, and next run preview</done>
</task>

<task type="auto">
  <name>Task 2: Add Step 3 styles to SCSS</name>
  <files>webapp/channels/src/components/create_recap_modal/create_recap_modal.scss</files>
  <action>
Add styles for Step 3 inside the `.create-recap-modal` block, after the day-of-week-selector styles:

```scss
    // Step Three Schedule Configuration Styles
    .step-three {
        display: flex;
        flex-direction: column;
        gap: 20px;

        .form-group {
            display: flex;
            flex-direction: column;

            .form-label {
                margin-bottom: 8px;
                color: var(--center-channel-color);
                font-size: 14px;
                font-weight: 600;
            }

            .form-error {
                margin-top: 4px;
                color: var(--error-text);
                font-size: 12px;
            }
        }

        .next-run-preview {
            padding: 12px 16px;
            border-radius: 4px;
            margin-top: -8px;
            background-color: rgba(var(--center-channel-color-rgb), 0.04);
            color: rgba(var(--center-channel-color-rgb), 0.72);
            font-size: 13px;
        }

        // Override Input widget styles for textarea
        .Input_container {
            .Input_fieldset {
                textarea.Input {
                    min-height: 80px;
                    resize: vertical;
                }
            }
        }
    }
```

Place these after the `.day-of-week-selector` styles and before the closing brace.
  </action>
  <verify>grep -q "step-three" webapp/channels/src/components/create_recap_modal/create_recap_modal.scss</verify>
  <done>Step 3 styles exist including next run preview styling and form layout</done>
</task>

</tasks>

<verification>
All tasks complete when:
1. schedule_configuration.tsx exists and exports ScheduleConfiguration
2. Component imports and uses DayOfWeekSelector
3. Component uses getCurrentTimezone selector for timezone
4. Next run preview appears when days and time are selected
5. SCSS includes .step-three and .next-run-preview styles
</verification>

<success_criteria>
- ScheduleConfiguration component exports correctly
- Uses DayOfWeekSelector for day selection
- Time picker has 30-minute interval options
- Time period dropdown has 3 options (last_24h, last_3_days, last_7_days)
- Custom instructions textarea with 500 char limit
- Next run preview calculates and shows timezone
- All styles render correctly
</success_criteria>

<output>
After completion, create `.planning/phases/05-enhanced-wizard/05-03-SUMMARY.md`
</output>
