---
phase: 01-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/public/model/scheduled_recap.go
  - server/channels/db/migrations/postgres/000150_create_scheduled_recaps.up.sql
  - server/channels/db/migrations/postgres/000150_create_scheduled_recaps.down.sql
autonomous: true

must_haves:
  truths:
    - "ScheduledRecap struct exists with all required fields for schedule configuration"
    - "Day-of-week bitmask constants allow expressing any combination of days"
    - "ComputeNextRunAt returns correct UTC milliseconds for timezone-aware scheduling"
    - "Database migration creates ScheduledRecaps table with proper indexes"
  artifacts:
    - path: "server/public/model/scheduled_recap.go"
      provides: "ScheduledRecap model, constants, NextRunAt computation"
      min_lines: 150
      exports: ["ScheduledRecap", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Weekdays", "Weekend", "EveryDay", "ChannelModeSpecific", "ChannelModeAllUnreads", "TimePeriodLast24h", "TimePeriodLastWeek", "TimePeriodSinceLastRead"]
    - path: "server/channels/db/migrations/postgres/000150_create_scheduled_recaps.up.sql"
      provides: "ScheduledRecaps table creation with indexes"
      contains: "CREATE TABLE IF NOT EXISTS ScheduledRecaps"
    - path: "server/channels/db/migrations/postgres/000150_create_scheduled_recaps.down.sql"
      provides: "ScheduledRecaps table drop for migration rollback"
      contains: "DROP TABLE IF EXISTS ScheduledRecaps"
  key_links:
    - from: "server/public/model/scheduled_recap.go"
      to: "time.LoadLocation"
      via: "IANA timezone string in ComputeNextRunAt"
      pattern: "time\\.LoadLocation\\(sr\\.Timezone\\)"
---

<objective>
Create the ScheduledRecap model and database migration for scheduled recap configuration.

Purpose: Establish the data structures that correctly store user schedule intent (days, time, timezone) and execution state (NextRunAt, LastRunAt, RunCount). This is the foundation that the store layer will persist and query.

Output: 
- `server/public/model/scheduled_recap.go` - Model struct with constants and NextRunAt computation method
- `server/channels/db/migrations/postgres/000150_create_scheduled_recaps.up.sql` - Table creation
- `server/channels/db/migrations/postgres/000150_create_scheduled_recaps.down.sql` - Rollback migration
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-foundation/01-RESEARCH.md

# Reference existing patterns
@server/public/model/recap.go
@server/channels/db/migrations/postgres/000149_create_recaps.up.sql
@server/public/shared/timezones/timezones.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScheduledRecap model with constants and NextRunAt computation</name>
  <files>server/public/model/scheduled_recap.go</files>
  <action>
Create `server/public/model/scheduled_recap.go` with:

1. Copyright header (required - see existing model files)

2. Day-of-week bitmask constants following Go's time.Weekday (Sunday=0):
   - Sunday = 1 << 0 (1)
   - Monday = 1 << 1 (2)
   - Tuesday = 1 << 2 (4)
   - Wednesday = 1 << 3 (8)
   - Thursday = 1 << 4 (16)
   - Friday = 1 << 5 (32)
   - Saturday = 1 << 6 (64)
   - Weekdays = Monday | Tuesday | Wednesday | Thursday | Friday (62)
   - Weekend = Saturday | Sunday (65)
   - EveryDay = Weekdays | Weekend (127)

3. Channel mode constants:
   - ChannelModeSpecific = "specific"
   - ChannelModeAllUnreads = "all_unreads"

4. Time period constants:
   - TimePeriodLast24h = "last_24h"
   - TimePeriodLastWeek = "last_week"
   - TimePeriodSinceLastRead = "since_last_read"

5. ScheduledRecap struct with JSON tags:
   - Id string `json:"id"`
   - UserId string `json:"user_id"`
   - Title string `json:"title"`
   - DaysOfWeek int `json:"days_of_week"` (bitmask)
   - TimeOfDay string `json:"time_of_day"` (HH:MM format)
   - Timezone string `json:"timezone"` (IANA timezone)
   - TimePeriod string `json:"time_period"`
   - NextRunAt int64 `json:"next_run_at"` (UTC millis)
   - LastRunAt int64 `json:"last_run_at"` (UTC millis)
   - RunCount int `json:"run_count"`
   - ChannelMode string `json:"channel_mode"`
   - ChannelIds []string `json:"channel_ids,omitempty"` (JSON array)
   - CustomInstructions string `json:"custom_instructions,omitempty"`
   - AgentId string `json:"agent_id"`
   - IsRecurring bool `json:"is_recurring"`
   - Enabled bool `json:"enabled"`
   - CreateAt int64 `json:"create_at"`
   - UpdateAt int64 `json:"update_at"`
   - DeleteAt int64 `json:"delete_at"`

6. ComputeNextRunAt(fromTime time.Time) (int64, error) method:
   - Load timezone with time.LoadLocation(sr.Timezone)
   - Parse TimeOfDay (split on ":" to get hour/minute)
   - Convert fromTime to user's local timezone
   - Create candidate time.Date in user's timezone with target hour/minute
   - If candidate is before or equal to localNow, add one day
   - Loop up to 7 times to find matching day of week using bitmask
   - Return GetMillis() equivalent (candidate.UnixMilli()) for the matching day
   - Return error if no valid day found or invalid timezone

7. IsValid() *AppError method for validation:
   - Id must be valid (len 26)
   - UserId must be valid (len 26)
   - Title not empty, max 255 chars
   - DaysOfWeek must be 1-127 (at least one day selected)
   - TimeOfDay must match HH:MM format (00:00 to 23:59)
   - Timezone must be loadable with time.LoadLocation
   - TimePeriod must be one of the valid constants
   - ChannelMode must be "specific" or "all_unreads"
   - If ChannelMode is "specific", ChannelIds must not be empty

8. PreSave() method:
   - Generate Id if empty using model.NewId()
   - Set CreateAt and UpdateAt to GetMillis() if zero

9. PreUpdate() method:
   - Set UpdateAt to GetMillis()

10. Auditable() map[string]any method (for audit logging, follow recap.go pattern)

IMPORTANT: Use Go stdlib time package for timezone handling. The time.LoadLocation with IANA timezone strings handles DST automatically.
  </action>
  <verify>
Run `go build ./server/public/model/...` to verify the model compiles without errors.
Run `go vet ./server/public/model/...` to check for issues.
  </verify>
  <done>
ScheduledRecap model exists with all fields, constants, ComputeNextRunAt method that uses time.LoadLocation for DST-aware scheduling, IsValid method for input validation, and PreSave/PreUpdate lifecycle methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database migration for ScheduledRecaps table</name>
  <files>
    server/channels/db/migrations/postgres/000150_create_scheduled_recaps.up.sql
    server/channels/db/migrations/postgres/000150_create_scheduled_recaps.down.sql
  </files>
  <action>
Create migration files following existing patterns (see 000149_create_recaps.up.sql):

**000150_create_scheduled_recaps.up.sql:**

```sql
-- ScheduledRecaps table: stores scheduled recap configuration
CREATE TABLE IF NOT EXISTS ScheduledRecaps (
    Id VARCHAR(26) PRIMARY KEY,
    UserId VARCHAR(26) NOT NULL,
    Title VARCHAR(255) NOT NULL,
    
    -- Schedule configuration (user intent)
    DaysOfWeek INT NOT NULL,
    TimeOfDay VARCHAR(5) NOT NULL,
    Timezone VARCHAR(64) NOT NULL,
    TimePeriod VARCHAR(32) NOT NULL,
    
    -- Schedule state (computed)
    NextRunAt BIGINT NOT NULL,
    LastRunAt BIGINT DEFAULT 0 NOT NULL,
    RunCount INT DEFAULT 0 NOT NULL,
    
    -- Channel configuration
    ChannelMode VARCHAR(32) NOT NULL,
    ChannelIds TEXT,
    
    -- AI configuration
    CustomInstructions TEXT,
    AgentId VARCHAR(26) DEFAULT '' NOT NULL,
    
    -- Schedule type and state
    IsRecurring BOOLEAN DEFAULT true NOT NULL,
    Enabled BOOLEAN DEFAULT true NOT NULL,
    
    -- Standard timestamps
    CreateAt BIGINT NOT NULL,
    UpdateAt BIGINT NOT NULL,
    DeleteAt BIGINT DEFAULT 0 NOT NULL
);

-- Index for user queries (list user's scheduled recaps)
CREATE INDEX IF NOT EXISTS idx_scheduled_recaps_user_id ON ScheduledRecaps(UserId);

-- Index for scheduler polling (find due recaps)
CREATE INDEX IF NOT EXISTS idx_scheduled_recaps_next_run_at ON ScheduledRecaps(NextRunAt);

-- Composite index for efficient scheduler query (enabled, not deleted, due before timestamp)
CREATE INDEX IF NOT EXISTS idx_scheduled_recaps_enabled_next_run ON ScheduledRecaps(Enabled, DeleteAt, NextRunAt);

-- Index for user + soft delete queries
CREATE INDEX IF NOT EXISTS idx_scheduled_recaps_user_delete ON ScheduledRecaps(UserId, DeleteAt);
```

**000150_create_scheduled_recaps.down.sql:**

```sql
DROP INDEX IF EXISTS idx_scheduled_recaps_user_delete;
DROP INDEX IF EXISTS idx_scheduled_recaps_enabled_next_run;
DROP INDEX IF EXISTS idx_scheduled_recaps_next_run_at;
DROP INDEX IF EXISTS idx_scheduled_recaps_user_id;
DROP TABLE IF EXISTS ScheduledRecaps;
```

Key design decisions:
- VARCHAR(5) for TimeOfDay - stores "HH:MM" format
- VARCHAR(64) for Timezone - enough for longest IANA timezone
- TEXT for ChannelIds - stores JSON array of channel IDs
- Composite index (Enabled, DeleteAt, NextRunAt) optimizes scheduler polling query
- Follow existing patterns: VARCHAR(26) for IDs, BIGINT for timestamps
  </action>
  <verify>
Verify migration file syntax:
- Check SQL syntax by reviewing against existing migrations
- Ensure both up and down migrations are consistent (down drops everything up creates)
  </verify>
  <done>
Migration files exist at the correct path with proper table schema, indexes for efficient querying, and matching down migration for rollback.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for ComputeNextRunAt with DST edge cases</name>
  <files>server/public/model/scheduled_recap_test.go</files>
  <action>
Create `server/public/model/scheduled_recap_test.go` with comprehensive tests:

1. Copyright header

2. Test ComputeNextRunAt basic functionality:
   - Monday only schedule at 9:00 AM - verify next Monday is returned
   - Weekday schedule - verify skips weekend
   - Every day schedule - verify next day is returned

3. Test DST transition edge cases (these are critical):
   - Spring forward (March): Schedule for 2:30 AM in America/New_York
     - On March 10, 2024, 2:00 AM becomes 3:00 AM
     - Time 2:30 AM doesn't exist - Go adjusts forward to 3:00 AM
     - Test that computation handles this gracefully
   
   - Fall back (November): Schedule for 1:30 AM in America/New_York
     - On November 3, 2024, 1:30 AM occurs twice
     - Go's time.Date picks the first occurrence (before DST ends)
     - Test that computation is consistent

4. Test timezone handling:
   - Same time in different timezones produces different UTC millis
   - Pacific time schedule vs Eastern time schedule

5. Test day-of-week bitmask:
   - Single day (Monday = 2)
   - Multiple days (Mon+Wed+Fri = 2+8+32 = 42)
   - Weekdays constant (62)
   - Weekend constant (65)
   - EveryDay constant (127)

6. Test error cases:
   - Invalid timezone returns error
   - Invalid TimeOfDay format returns error
   - DaysOfWeek = 0 returns error (no days selected)

7. Test IsValid() method:
   - Valid scheduled recap passes
   - Missing required fields fail
   - Invalid timezone fails
   - Invalid time format fails

Use table-driven tests where appropriate. Use fixed times (not time.Now()) for deterministic tests.
  </action>
  <verify>
Run `go test -v ./server/public/model/... -run TestScheduledRecap` to verify tests pass.
  </verify>
  <done>
Test file exists with comprehensive coverage for ComputeNextRunAt including DST edge cases, timezone handling, bitmask operations, and validation.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./server/public/model/...` compiles successfully
2. `go test -v ./server/public/model/... -run TestScheduledRecap` passes all tests
3. Migration files exist at correct paths
4. Model struct has all fields from research spec
</verification>

<success_criteria>
- ScheduledRecap model compiles and has all required fields
- ComputeNextRunAt correctly handles DST transitions
- Day-of-week bitmask constants match Go's time.Weekday convention
- Migration creates table with proper indexes for scheduler queries
- Tests verify DST handling with March/November edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-01-SUMMARY.md`
</output>
