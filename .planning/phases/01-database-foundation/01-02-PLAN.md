---
phase: 01-database-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - server/channels/store/store.go
  - server/channels/store/sqlstore/scheduled_recap_store.go
  - server/channels/store/sqlstore/store.go
  - server/channels/store/sqlstore/scheduled_recap_store_test.go
autonomous: true

must_haves:
  truths:
    - "Developer can create a scheduled recap record with day-of-week, time, timezone, and time period"
    - "Developer can query for all scheduled recaps due before a given timestamp"
    - "Store layer has full test coverage for CRUD operations"
    - "ScheduledRecapStore interface is registered in main Store interface"
  artifacts:
    - path: "server/channels/store/store.go"
      provides: "ScheduledRecapStore interface definition"
      contains: "ScheduledRecapStore interface"
    - path: "server/channels/store/sqlstore/scheduled_recap_store.go"
      provides: "SQL implementation of ScheduledRecapStore"
      min_lines: 200
    - path: "server/channels/store/sqlstore/store.go"
      provides: "Store registration for ScheduledRecapStore"
      contains: "scheduledRecap"
    - path: "server/channels/store/sqlstore/scheduled_recap_store_test.go"
      provides: "Store tests for CRUD operations"
      min_lines: 150
  key_links:
    - from: "server/channels/store/sqlstore/scheduled_recap_store.go"
      to: "server/public/model/scheduled_recap.go"
      via: "model.ScheduledRecap type usage"
      pattern: "model\\.ScheduledRecap"
    - from: "server/channels/store/sqlstore/store.go"
      to: "server/channels/store/sqlstore/scheduled_recap_store.go"
      via: "newSqlScheduledRecapStore initialization"
      pattern: "newSqlScheduledRecapStore"
---

<objective>
Create the ScheduledRecapStore interface and SQL implementation with full test coverage.

Purpose: Enable persistence and querying of scheduled recap records. The store layer provides CRUD operations plus specialized queries for the scheduler (GetDueBefore) and user management (GetForUser).

Output:
- `server/channels/store/store.go` - ScheduledRecapStore interface added
- `server/channels/store/sqlstore/scheduled_recap_store.go` - SQL implementation
- `server/channels/store/sqlstore/store.go` - Store registration
- `server/channels/store/sqlstore/scheduled_recap_store_test.go` - Comprehensive tests
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-foundation/01-RESEARCH.md

# Reference Plan 01 outputs (will exist after Plan 01 completes)
@server/public/model/scheduled_recap.go

# Reference existing store patterns
@server/channels/store/store.go
@server/channels/store/sqlstore/recap_store.go
@server/channels/store/sqlstore/scheduled_post_store.go
@server/channels/store/sqlstore/recap_store_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ScheduledRecapStore interface to store.go</name>
  <files>server/channels/store/store.go</files>
  <action>
Add ScheduledRecapStore interface definition to `server/channels/store/store.go`:

1. Add `ScheduledRecap() ScheduledRecapStore` method to the main `Store` interface (around line 101-104, near the Recap() method)

2. Add the ScheduledRecapStore interface definition (add after RecapStore interface, around line 1307):

```go
type ScheduledRecapStore interface {
    // CRUD operations
    Save(scheduledRecap *model.ScheduledRecap) (*model.ScheduledRecap, error)
    Get(id string) (*model.ScheduledRecap, error)
    Update(scheduledRecap *model.ScheduledRecap) (*model.ScheduledRecap, error)
    Delete(id string) error  // Soft delete (sets DeleteAt)
    
    // Query operations
    GetForUser(userId string, page, perPage int) ([]*model.ScheduledRecap, error)
    GetDueBefore(timestamp int64, limit int) ([]*model.ScheduledRecap, error)
    
    // State updates (efficient single-field updates)
    UpdateNextRunAt(id string, nextRunAt int64) error
    MarkExecuted(id string, lastRunAt int64, nextRunAt int64) error
    SetEnabled(id string, enabled bool) error
}
```

Interface design rationale:
- Save/Get/Update/Delete - Standard CRUD following existing patterns
- GetForUser - Paginated list for user's scheduled tab
- GetDueBefore - Scheduler polling query (finds due recaps)
- UpdateNextRunAt - After schedule config changes
- MarkExecuted - After successful run (updates LastRunAt, NextRunAt, RunCount)
- SetEnabled - Pause/resume functionality
  </action>
  <verify>
Run `go build ./server/channels/store/...` to verify interface compiles.
  </verify>
  <done>
ScheduledRecapStore interface is defined in store.go with all required methods for CRUD, querying, and state updates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SQL implementation of ScheduledRecapStore</name>
  <files>server/channels/store/sqlstore/scheduled_recap_store.go</files>
  <action>
Create `server/channels/store/sqlstore/scheduled_recap_store.go` following existing patterns from recap_store.go and scheduled_post_store.go:

1. Copyright header

2. Package and imports:
```go
package sqlstore

import (
    "database/sql"
    "encoding/json"
    
    "github.com/mattermost/mattermost/server/public/model"
    "github.com/mattermost/mattermost/server/v8/channels/store"
    sq "github.com/mattermost/squirrel"
    "github.com/pkg/errors"
)
```

3. Column list for SELECT queries:
```go
var scheduledRecapColumns = []string{
    "Id", "UserId", "Title",
    "DaysOfWeek", "TimeOfDay", "Timezone", "TimePeriod",
    "NextRunAt", "LastRunAt", "RunCount",
    "ChannelMode", "ChannelIds",
    "CustomInstructions", "AgentId",
    "IsRecurring", "Enabled",
    "CreateAt", "UpdateAt", "DeleteAt",
}
```

4. SqlScheduledRecapStore struct:
```go
type SqlScheduledRecapStore struct {
    *SqlStore
    selectQuery sq.SelectBuilder
}

func newSqlScheduledRecapStore(sqlStore *SqlStore) store.ScheduledRecapStore {
    s := &SqlScheduledRecapStore{
        SqlStore: sqlStore,
    }
    s.selectQuery = s.getQueryBuilder().
        Select(scheduledRecapColumns...).
        From("ScheduledRecaps")
    return s
}
```

5. Helper to convert model to map for INSERT/UPDATE (handles JSON array for ChannelIds):
```go
func (s *SqlScheduledRecapStore) toMap(sr *model.ScheduledRecap) map[string]any {
    channelIdsJSON, _ := json.Marshal(sr.ChannelIds)
    return map[string]any{
        "Id":                 sr.Id,
        "UserId":             sr.UserId,
        "Title":              sr.Title,
        "DaysOfWeek":         sr.DaysOfWeek,
        "TimeOfDay":          sr.TimeOfDay,
        "Timezone":           sr.Timezone,
        "TimePeriod":         sr.TimePeriod,
        "NextRunAt":          sr.NextRunAt,
        "LastRunAt":          sr.LastRunAt,
        "RunCount":           sr.RunCount,
        "ChannelMode":        sr.ChannelMode,
        "ChannelIds":         string(channelIdsJSON),
        "CustomInstructions": sr.CustomInstructions,
        "AgentId":            sr.AgentId,
        "IsRecurring":        sr.IsRecurring,
        "Enabled":            sr.Enabled,
        "CreateAt":           sr.CreateAt,
        "UpdateAt":           sr.UpdateAt,
        "DeleteAt":           sr.DeleteAt,
    }
}
```

6. Helper to scan row into model (handles JSON unmarshal for ChannelIds):
```go
// Use intermediate struct for scanning TEXT fields that need JSON unmarshal
type dbScheduledRecap struct {
    Id                 string
    UserId             string
    Title              string
    DaysOfWeek         int
    TimeOfDay          string
    Timezone           string
    TimePeriod         string
    NextRunAt          int64
    LastRunAt          int64
    RunCount           int
    ChannelMode        string
    ChannelIds         string  // JSON string in DB
    CustomInstructions string
    AgentId            string
    IsRecurring        bool
    Enabled            bool
    CreateAt           int64
    UpdateAt           int64
    DeleteAt           int64
}

func (s *SqlScheduledRecapStore) fromDB(dbSR *dbScheduledRecap) (*model.ScheduledRecap, error) {
    sr := &model.ScheduledRecap{
        Id:                 dbSR.Id,
        UserId:             dbSR.UserId,
        Title:              dbSR.Title,
        DaysOfWeek:         dbSR.DaysOfWeek,
        TimeOfDay:          dbSR.TimeOfDay,
        Timezone:           dbSR.Timezone,
        TimePeriod:         dbSR.TimePeriod,
        NextRunAt:          dbSR.NextRunAt,
        LastRunAt:          dbSR.LastRunAt,
        RunCount:           dbSR.RunCount,
        ChannelMode:        dbSR.ChannelMode,
        CustomInstructions: dbSR.CustomInstructions,
        AgentId:            dbSR.AgentId,
        IsRecurring:        dbSR.IsRecurring,
        Enabled:            dbSR.Enabled,
        CreateAt:           dbSR.CreateAt,
        UpdateAt:           dbSR.UpdateAt,
        DeleteAt:           dbSR.DeleteAt,
    }
    if dbSR.ChannelIds != "" {
        if err := json.Unmarshal([]byte(dbSR.ChannelIds), &sr.ChannelIds); err != nil {
            return nil, errors.Wrap(err, "failed to unmarshal ChannelIds")
        }
    }
    return sr, nil
}
```

7. Implement all interface methods:

**Save:** Insert new record, call PreSave() first
**Get:** Select by ID, return ErrNotFound if not found
**Update:** Update all fields except Id/CreateAt, call PreUpdate() first
**Delete:** Soft delete (set DeleteAt = GetMillis())
**GetForUser:** Paginated query with WHERE UserId=? AND DeleteAt=0 ORDER BY CreateAt DESC
**GetDueBefore:** WHERE Enabled=true AND DeleteAt=0 AND NextRunAt <= ? ORDER BY NextRunAt ASC LIMIT ?
**UpdateNextRunAt:** UPDATE SET NextRunAt=?, UpdateAt=? WHERE Id=?
**MarkExecuted:** UPDATE SET LastRunAt=?, NextRunAt=?, RunCount=RunCount+1, UpdateAt=? WHERE Id=?
**SetEnabled:** UPDATE SET Enabled=?, UpdateAt=? WHERE Id=?

Follow error handling patterns from recap_store.go:
- Use sql.ErrNoRows check for store.NewErrNotFound
- Wrap all other errors with errors.Wrapf including context
  </action>
  <verify>
Run `go build ./server/channels/store/sqlstore/...` to verify implementation compiles.
  </verify>
  <done>
SqlScheduledRecapStore implements all ScheduledRecapStore interface methods with proper error handling, JSON serialization for ChannelIds, and follows existing codebase patterns.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register ScheduledRecapStore in SqlStore</name>
  <files>server/channels/store/sqlstore/store.go</files>
  <action>
Update `server/channels/store/sqlstore/store.go` to register the new store:

1. Add field to SqlStoreStores struct (around line 117, near the recap field):
```go
scheduledRecap store.ScheduledRecapStore
```

2. Add ScheduledRecap() method to SqlStore (find where Recap() is defined, add nearby):
```go
func (ss *SqlStore) ScheduledRecap() store.ScheduledRecapStore {
    return ss.stores.scheduledRecap
}
```

3. Initialize the store in NewSqlStore function (find where recap store is initialized):
```go
ss.stores.scheduledRecap = newSqlScheduledRecapStore(ss)
```

Search for existing patterns - look for where `recap` store is registered and follow the same pattern.
  </action>
  <verify>
Run `go build ./server/channels/store/sqlstore/...` to verify registration compiles.
Verify the Store interface is satisfied by checking for compile errors.
  </verify>
  <done>
ScheduledRecapStore is registered in SqlStoreStores, accessible via SqlStore.ScheduledRecap() method, and initialized in NewSqlStore.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create store tests for ScheduledRecapStore</name>
  <files>server/channels/store/sqlstore/scheduled_recap_store_test.go</files>
  <action>
Create `server/channels/store/sqlstore/scheduled_recap_store_test.go` following patterns from recap_store_test.go:

1. Copyright header

2. Package and imports:
```go
package sqlstore

import (
    "testing"
    "time"
    
    "github.com/mattermost/mattermost/server/public/model"
    "github.com/mattermost/mattermost/server/public/shared/request"
    "github.com/mattermost/mattermost/server/v8/channels/store"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)
```

3. TestScheduledRecapStore function using StoreTest wrapper:
```go
func TestScheduledRecapStore(t *testing.T) {
    StoreTest(t, func(t *testing.T, rctx request.CTX, ss store.Store) {
        // All subtests go here
    })
}
```

4. Test cases (as subtests):

**SaveAndGet:**
- Create valid ScheduledRecap with all fields populated
- Save, verify no error
- Get by ID, verify all fields match

**GetForUser:**
- Create 3 scheduled recaps for same user
- Create 1 for different user
- GetForUser returns only 3 for first user
- Test pagination (page 0, perPage 2 returns 2)

**Update:**
- Save a scheduled recap
- Modify Title, DaysOfWeek, TimeOfDay
- Update, verify no error
- Get, verify changes persisted

**Delete (soft delete):**
- Save a scheduled recap
- Delete, verify no error
- GetForUser returns 0 (soft deleted)
- Direct Get still returns the record (with DeleteAt set)

**GetDueBefore:**
- Create 3 scheduled recaps with different NextRunAt values
  - One due in past (should be returned)
  - One due now (should be returned)
  - One due in future (should not be returned)
- Create one that's disabled (should not be returned)
- Create one that's deleted (should not be returned)
- Call GetDueBefore(now, 10)
- Verify only enabled, non-deleted, due recaps returned
- Verify ordered by NextRunAt ASC

**UpdateNextRunAt:**
- Save a scheduled recap
- UpdateNextRunAt to new value
- Get, verify NextRunAt changed and UpdateAt updated

**MarkExecuted:**
- Save a scheduled recap with RunCount=0
- MarkExecuted with new LastRunAt and NextRunAt
- Get, verify LastRunAt set, NextRunAt updated, RunCount=1
- MarkExecuted again
- Get, verify RunCount=2

**SetEnabled:**
- Save enabled scheduled recap
- SetEnabled(false)
- Get, verify Enabled=false
- SetEnabled(true)
- Get, verify Enabled=true

**ChannelIdsJsonSerialization:**
- Save scheduled recap with ChannelIds = ["ch1", "ch2", "ch3"]
- Get, verify ChannelIds slice correctly deserialized

Use helper function to create valid ScheduledRecap:
```go
func createTestScheduledRecap(userId string) *model.ScheduledRecap {
    return &model.ScheduledRecap{
        Id:          model.NewId(),
        UserId:      userId,
        Title:       "Test Scheduled Recap",
        DaysOfWeek:  model.Weekdays,
        TimeOfDay:   "09:00",
        Timezone:    "America/New_York",
        TimePeriod:  model.TimePeriodLast24h,
        NextRunAt:   model.GetMillis() + 3600000, // 1 hour from now
        LastRunAt:   0,
        RunCount:    0,
        ChannelMode: model.ChannelModeSpecific,
        ChannelIds:  []string{model.NewId(), model.NewId()},
        AgentId:     "test-agent",
        IsRecurring: true,
        Enabled:     true,
        CreateAt:    model.GetMillis(),
        UpdateAt:    model.GetMillis(),
        DeleteAt:    0,
    }
}
```
  </action>
  <verify>
Run `go test -v ./server/channels/store/sqlstore/... -run TestScheduledRecapStore` to verify all tests pass.
  </verify>
  <done>
Store tests exist with full coverage for CRUD operations, GetDueBefore scheduler query, state update methods, and JSON serialization of ChannelIds array.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./server/channels/store/...` compiles successfully
2. `go build ./server/channels/store/sqlstore/...` compiles successfully
3. `go test -v ./server/channels/store/sqlstore/... -run TestScheduledRecapStore` passes all tests
4. Run `go generate ./server/channels/store/...` to regenerate store mocks (if needed)
</verification>

<success_criteria>
- ScheduledRecapStore interface is defined with all required methods
- SQL implementation follows existing patterns (squirrel query builder, error wrapping)
- Store is registered and accessible via Store.ScheduledRecap()
- Tests verify CRUD operations work correctly
- Tests verify GetDueBefore returns only enabled, non-deleted, due records
- Tests verify ChannelIds JSON array serialization works
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-02-SUMMARY.md`
</output>
