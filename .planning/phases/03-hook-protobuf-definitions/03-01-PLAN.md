---
phase: 03-hook-protobuf-definitions
plan: 01
type: execute
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - server/public/pluginapi/grpc/proto/hooks.proto
  - server/public/pluginapi/grpc/proto/hooks_common.proto
  - server/public/pluginapi/grpc/proto/hooks_lifecycle.proto
---

<objective>
Define protobuf/gRPC contracts for the **lifecycle + system** plugin hooks, aligned to the authoritative Go hook surface.

Purpose: Establish the baseline `PluginHooks` service and the shared hook context types so later hook groups can be added consistently.
Output: `hooks.proto` (service + imports) and `hooks_*` message protos for lifecycle/system hooks, compiling via `make proto-gen`.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 prerequisites (package naming, go_package, generation command)
@.planning/phases/01-protocol-foundation/01-01-PLAN.md
@.planning/phases/01-protocol-foundation/01-02-PLAN.md
@.planning/phases/01-protocol-foundation/01-03-PLAN.md
@.planning/phases/01-protocol-foundation/01-RESEARCH.md

# Authoritative hook surface
@server/public/plugin/hooks.go
@server/public/plugin/context.go

# Model types referenced by lifecycle/system hooks
@server/public/model/plugin_on_install_event.go
@server/public/model/cloud.go
@server/public/model/support_packet.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add shared hook context types (PluginContext) in `hooks_common.proto`</name>
  <files>server/public/pluginapi/grpc/proto/hooks_common.proto</files>
  <action>
Create `hooks_common.proto` under `server/public/pluginapi/grpc/proto/` using the Phase 1 proto package naming conventions (recommended in 01-01/01-02): `package mattermost.pluginapi.v1;` and the same `option go_package = ".../generated/go;pluginapiv1";`.

Define a `PluginContext` message that mirrors `server/public/plugin/context.go`:
- `session_id`
- `request_id`
- `ip_address`
- `accept_language`
- `user_agent`

Notes / pitfalls:
- Keep field names `snake_case`.
- Do NOT invent new semantics; this type should be a faithful transport of existing `plugin.Context`.
- Avoid naming collisions with gRPC “context”; use `PluginContext` explicitly.
  </action>
  <verify>cd server && make proto-gen</verify>
  <done>`hooks_common.proto` exists, compiles under the Phase 1 proto package, and generated Go code builds.</done>
</task>

<task type="auto">
  <name>Task 2: Define lifecycle/system hook request+response messages in `hooks_lifecycle.proto` and create the baseline `hooks.proto` service</name>
  <files>server/public/pluginapi/grpc/proto/hooks_lifecycle.proto, server/public/pluginapi/grpc/proto/hooks.proto</files>
  <action>
Create `hooks_lifecycle.proto` to contain request/response messages for these hooks (from `server/public/plugin/hooks.go`):

- `Implemented() ([]string, error)`
- `OnActivate() error`
- `OnDeactivate() error`
- `OnConfigurationChange() error`
- `OnInstall(c *Context, event model.OnInstallEvent) error`
- `OnSendDailyTelemetry()`
- `RunDataRetention(nowTime, batchSize int64) (int64, error)`
- `OnCloudLimitsUpdated(limits *model.ProductLimits)`
- `ConfigurationWillBeSaved(newCfg *model.Config) (*model.Config, error)`

Rules:
- Every request message must include `RequestContext context = 1;` (import the Phase 1 `RequestContext` definition; do not duplicate it).
- For hooks that take `*plugin.Context` in Go, include `PluginContext plugin_context = 2;` (import from `hooks_common.proto`).
- Prefer faithful typing for small structs; for large/volatile payloads, encode as JSON bytes to avoid gigantic proto churn.

Concrete type guidance:
- `OnInstallEvent` is tiny (only `user_id`); define a typed `OnInstallEvent` message (mirrors `model.OnInstallEvent`).
- `ProductLimits` and its nested limits are moderate; define typed messages (`ProductLimits`, `FilesLimits`, `MessagesLimits`, `TeamsLimits`). Use protobuf wrapper types for nullable primitives (e.g., `google.protobuf.Int64Value`) instead of sentinel 0.
- `model.Config` is massive and changes often: represent configs for this hook as `bytes config_json` in a small message such as `ConfigJson`. The Go side can `json.Marshal`/`json.Unmarshal` without maintaining a 5k-line proto schema.

Then create `hooks.proto` that defines the baseline:
- `syntax = "proto3";`
- `package mattermost.pluginapi.v1;`
- `option go_package = "github.com/mattermost/mattermost/server/public/pluginapi/grpc/generated/go;pluginapiv1";`
- `service PluginHooks { ... }` with RPCs for the lifecycle/system hooks above.
- Import `hooks_common.proto`, `hooks_lifecycle.proto`, and whatever proto file contains `RequestContext` (Phase 1 output).

Error semantics:
- For hooks whose Go signature returns `error` / `*model.AppError`, do NOT add `error` fields to responses unless Phase 1 explicitly chose “embedded AppError” as the project-wide convention.
- Default assumption (matches later phases’ direction): transport/business failures are represented via gRPC status codes; hook “business outcomes” (like “return count”) are response fields.
Document the convention in comments in `hooks.proto` so later plans don’t re-litigate it.
  </action>
  <verify>cd server && make proto-gen && make test-public</verify>
  <done>`hooks.proto` + `hooks_lifecycle.proto` compile, generated Go code builds, and the lifecycle/system hook RPCs exist in the `PluginHooks` service.</done>
</task>

<task type="auto">
  <name>Task 3: Sanity-check hook coverage and signatures against `server/public/plugin/hooks.go`</name>
  <files>server/public/pluginapi/grpc/proto/hooks.proto, server/public/pluginapi/grpc/proto/hooks_lifecycle.proto</files>
  <action>
Add a final review pass to ensure:
- Every lifecycle/system hook listed in this plan exists as an RPC with matching request/response shapes.
- Field naming and numbering are stable (no accidental renumbering).
- Comments capture the parity semantics from Go (e.g., what “batchSize” means in `RunDataRetention`).

Avoid:
- Adding unrelated hook groups (posts/users/http) in this plan; those belong to 03-02..03-04 to keep diffs reviewable.
  </action>
  <verify>cd server && make proto-gen && make test-public</verify>
  <done>All targeted hooks are present, and regen+compile is clean.</done>
</task>

</tasks>

<verification>
Before declaring this plan complete:
- [ ] `cd server && make proto-gen`
- [ ] `cd server && make test-public`
</verification>

<success_criteria>
- Lifecycle/system hook RPCs exist in protobuf form, anchored by a baseline `hooks.proto` defining `service PluginHooks`.
- Shared `PluginContext` exists and mirrors `server/public/plugin/context.go`.
- Protos compile cleanly and generate Go code under `server/public/pluginapi/grpc/generated/go/`.
</success_criteria>

<output>
After completion, create `.planning/phases/03-hook-protobuf-definitions/03-01-SUMMARY.md` documenting:
- Which hooks were added
- Which model types were added vs represented as JSON blobs
- Any conventions established (field numbering, error strategy, request context)
</output>


