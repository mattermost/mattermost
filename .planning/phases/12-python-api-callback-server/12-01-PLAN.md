---
phase: 12-python-api-callback-server
plan: 01
type: execute
depends_on: []
files_modified: [server/public/plugin/python_supervisor.go, server/public/plugin/python_supervisor_test.go]
---

<objective>
Start gRPC PluginAPI server when Python plugins launch and pass the server address to Python via environment variable.

Purpose: Enable Python plugins to make API calls back to the Mattermost server. Currently, Python plugins can receive hooks but cannot call server APIs because no gRPC PluginAPI server is running.

Output: Python plugins can call all 236 Plugin API methods via the existing Python SDK (PluginAPIClient).
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-server-integration/11-03-SUMMARY.md

**Key files:**
@server/public/plugin/python_supervisor.go
@server/public/plugin/supervisor.go
@server/public/pluginapi/grpc/server/api_server.go
@python-sdk/src/mattermost_plugin/_internal/channel.py

**Tech stack available:**
- gRPC server implementation at `server/public/pluginapi/grpc/server/` (201+ API handlers ready)
- Python SDK expects `MATTERMOST_PLUGIN_API_TARGET` env var

**Constraining decisions:**
- Phase 4: APIServer wraps plugin.API and has full handler coverage (236 RPCs)
- Phase 6: Python SDK uses MATTERMOST_PLUGIN_API_TARGET to discover API server
- Phase 11: Python plugins use gRPC for hooks, supervisor extracts grpc.Conn from go-plugin

**Architecture insight:**
For Go plugins, hashicorp/go-plugin creates a bidirectional connection:
- Server → Plugin: Plugin receives hooks via hooksRPCServer
- Plugin → Server: Plugin calls API via apiRPCClient/apiRPCServer

For Python plugins, we have the first half (hooks via gRPC), but need to add:
- A separate gRPC server serving the PluginAPI service
- Pass server address to Python subprocess via MATTERMOST_PLUGIN_API_TARGET
</context>

<tasks>

<task type="auto">
  <name>Task 1: Start gRPC PluginAPI server for Python plugins</name>
  <files>server/public/plugin/python_supervisor.go</files>
  <action>
Add a function `startAPIServer` that:
1. Creates a new `grpc.Server` with appropriate options
2. Uses `apiserver.Register(grpcServer, apiImpl)` to register the PluginAPI service
3. Listens on a random available TCP port (use "localhost:0" and extract the assigned port)
4. Starts serving in a goroutine
5. Returns the listener address (e.g., "localhost:54321") and a cleanup function

Modify `configurePythonCommand` to:
1. Accept the `plugin.API` implementation as an additional parameter
2. Call `startAPIServer` to start the API server
3. Set `MATTERMOST_PLUGIN_API_TARGET` in cmd.Env with the server address
4. Store the cleanup function for later shutdown

Import the apiserver package: `apiserver "github.com/mattermost/mattermost/server/public/pluginapi/grpc/server"`

**Key implementation details:**
- Use `net.Listen("tcp", "localhost:0")` to get a random available port
- The gRPC server must be started BEFORE the Python process (so the port is ready)
- The cleanup must happen AFTER Python process terminates
- Preserve existing parent env vars: `cmd.Env = append(os.Environ(), "MATTERMOST_PLUGIN_API_TARGET=" + addr)`

**Error handling:**
- If listener creation fails, return error (Python plugin cannot start without API server)
- If server registration fails, close listener and return error
  </action>
  <verify>go build ./server/public/plugin/... compiles without errors</verify>
  <done>
- startAPIServer function exists and starts a gRPC server serving PluginAPI
- configurePythonCommand sets MATTERMOST_PLUGIN_API_TARGET env var
- cmd.Env includes the API target for the Python subprocess
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire API server lifecycle into supervisor</name>
  <files>server/public/plugin/python_supervisor.go, server/public/plugin/supervisor.go</files>
  <action>
Update `WithCommandFromManifest` and supervisor to:

1. Pass the `apiImpl` from supervisor to `configurePythonCommand`:
   - Modify `WithCommandFromManifest` signature to capture apiImpl
   - Or create a new option `WithPythonAPIServer(apiImpl API)` that stores it

2. Track the API server cleanup in the supervisor struct:
   - Add `apiServerCleanup func()` field to supervisor (only used for Python)
   - Call cleanup in `Shutdown()` method

3. Ensure proper lifecycle order:
   - Start API server BEFORE Python process
   - Stop Python process BEFORE stopping API server (allow graceful disconnect)

**Implementation approach:**
Since `WithCommandFromManifest` is called with `pluginInfo` but needs `apiImpl`, and `apiImpl` is available in `newSupervisor`:

Option A: Create a closure in newSupervisor that captures apiImpl
```go
// In newSupervisor, before applying opts:
if isPythonPlugin(pluginInfo.Manifest) {
    apiServerOpt := WithPythonAPIServer(apiImpl)
    opts = append(opts, apiServerOpt)
}
```

Option B: Store apiImpl in supervisor struct and access in configurePythonCommand
- Less clean but works

Choose Option A for cleaner separation.

**Shutdown order:**
In supervisor.Shutdown():
1. Call sup.client.Kill() (stops Python process)
2. If sup.apiServerCleanup != nil, call it (stops API server)
  </action>
  <verify>go build ./server/public/plugin/... compiles; go test ./server/public/plugin/... -run TestPython passes</verify>
  <done>
- API server starts before Python plugin subprocess
- API server stops after Python plugin subprocess
- supervisor.Shutdown() properly cleans up API server
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for Python API callback</name>
  <files>server/public/plugin/python_supervisor_test.go</files>
  <action>
Add tests verifying:

1. **TestPythonAPIServerStartup**: Verify API server starts and env var is set
   - Create a fake plugin with Python manifest
   - Call the configuration functions
   - Assert MATTERMOST_PLUGIN_API_TARGET is in cmd.Env
   - Assert the address is valid (host:port format)

2. **TestPythonAPIServerLifecycle**: Verify cleanup on shutdown
   - Start a supervisor with Python plugin (use fake interpreter pattern)
   - Verify API server is listening (try to connect)
   - Call Shutdown()
   - Verify API server is no longer listening

3. **TestPythonPluginCanCallAPI** (integration): End-to-end test
   - Create a fake Python interpreter that:
     a. Reads MATTERMOST_PLUGIN_API_TARGET env var
     b. Connects to the gRPC server
     c. Calls GetServerVersion()
     d. Returns success if version matches expected
   - Use the existing fake interpreter pattern from Phase 5/11
   - Verify the call succeeds

**Use existing test patterns:**
- Follow patterns from python_supervisor_test.go
- Use fake interpreter Go binaries compiled at test time (TestMain pattern)
- Mock the plugin.API interface to return known values
  </action>
  <verify>go test ./server/public/plugin/... -run TestPython -v passes all tests</verify>
  <done>
- TestPythonAPIServerStartup passes
- TestPythonAPIServerLifecycle passes
- TestPythonPluginCanCallAPI integration test passes
- API callback from Python to Go is fully verified
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./server/public/plugin/...` compiles
- [ ] `go test ./server/public/plugin/...` passes all tests
- [ ] `go test ./server/public/plugin/... -run TestPython -v` shows API callback tests passing
- [ ] No race conditions (run with `-race` flag)
</verification>

<success_criteria>

- Python plugins receive MATTERMOST_PLUGIN_API_TARGET env var with valid address
- gRPC PluginAPI server starts before Python subprocess
- Python plugins can call GetServerVersion() and get correct response
- API server properly shuts down when plugin is stopped
- All existing Python plugin tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-python-api-callback-server/12-01-SUMMARY.md` with:

# Phase 12-01: Python API Callback Server Summary

**[One-liner describing what was implemented]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- [File paths and descriptions]

## Decisions Made
- [Key decisions with rationale]

## Issues Encountered
- [Problems and resolutions, or "None"]

## Next Step
- Phase 12 complete - Python plugins can now call back to Go API
</output>
