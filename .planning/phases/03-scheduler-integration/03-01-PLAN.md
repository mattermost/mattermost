---
phase: 03-scheduler-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/public/model/job.go
  - server/channels/jobs/scheduled_recap/scheduler.go
  - server/channels/jobs/scheduled_recap/worker.go
autonomous: true

must_haves:
  truths:
    - "JobTypeScheduledRecap constant exists and is valid"
    - "Scheduler polls GetDueBefore and creates jobs for due recaps"
    - "Worker processes scheduled recap jobs and creates actual recaps"
    - "Worker updates ScheduledRecap state after execution"
  artifacts:
    - path: "server/public/model/job.go"
      provides: "JobTypeScheduledRecap constant"
      contains: "JobTypeScheduledRecap"
    - path: "server/channels/jobs/scheduled_recap/scheduler.go"
      provides: "ScheduledRecap scheduler"
      min_lines: 40
    - path: "server/channels/jobs/scheduled_recap/worker.go"
      provides: "ScheduledRecap worker"
      min_lines: 60
  key_links:
    - from: "scheduler.go"
      to: "store.ScheduledRecap().GetDueBefore"
      via: "polling for due recaps"
      pattern: "GetDueBefore"
    - from: "worker.go"
      to: "store.ScheduledRecap().MarkExecuted"
      via: "updating state after execution"
      pattern: "MarkExecuted"
---

<objective>
Create the ScheduledRecap job type constant, scheduler, and worker implementations following Mattermost's job system patterns.

Purpose: Enable automatic execution of scheduled recaps at the correct time with cluster-safe coordination.
Output: Job type constant, scheduler that polls for due recaps, and worker that executes them.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scheduler-integration/03-RESEARCH.md

# Key existing files
@server/public/model/job.go
@server/channels/jobs/base_schedulers.go
@server/channels/jobs/delete_expired_posts/scheduler.go
@server/channels/jobs/delete_expired_posts/worker.go
@server/channels/jobs/recap/worker.go
@server/channels/store/store.go
@server/public/model/scheduled_recap.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add JobTypeScheduledRecap constant</name>
  <files>server/public/model/job.go</files>
  <action>
Add the JobTypeScheduledRecap constant to server/public/model/job.go:

1. Add constant in the const block (around line 49, after JobTypeDeleteExpiredPosts):
   ```go
   JobTypeScheduledRecap = "scheduled_recap"
   ```

2. Add to AllJobTypes slice (around line 82):
   ```go
   JobTypeScheduledRecap,
   ```

Follow the exact pattern of existing job type constants. The constant value should be lowercase with underscores.
  </action>
  <verify>
Run `grep -n "JobTypeScheduledRecap" server/public/model/job.go` - should show constant definition and AllJobTypes entry.
Run `go build ./server/public/model/` - should compile without errors.
  </verify>
  <done>
JobTypeScheduledRecap constant exists in job.go and is included in AllJobTypes slice.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create scheduler implementation</name>
  <files>server/channels/jobs/scheduled_recap/scheduler.go</files>
  <action>
Create a new directory `server/channels/jobs/scheduled_recap/` and add `scheduler.go`:

The scheduler must:
1. Use a 1-minute polling interval (SchedulerPollingInterval constant)
2. Be enabled when cfg.FeatureFlags.EnableAIRecaps is true
3. Override ScheduleJob to poll GetDueBefore(now, 100) for due scheduled recaps
4. Create a job for each due recap using CreateJobOnce to prevent duplicates
5. Pass job data: "scheduled_recap_id", "user_id", "channel_ids" (comma-joined), "agent_id"

Pattern to follow (from 03-RESEARCH.md):
```go
package scheduled_recap

import (
    "strings"
    "time"

    "github.com/mattermost/mattermost/server/public/model"
    "github.com/mattermost/mattermost/server/public/shared/mlog"
    "github.com/mattermost/mattermost/server/public/shared/request"
    "github.com/mattermost/mattermost/server/v8/channels/jobs"
    "github.com/mattermost/mattermost/server/v8/channels/store"
)

const SchedulerPollingInterval = 1 * time.Minute

type Scheduler struct {
    *jobs.PeriodicScheduler
    store store.Store
}

func MakeScheduler(jobServer *jobs.JobServer, storeInstance store.Store) *Scheduler {
    isEnabled := func(cfg *model.Config) bool {
        return cfg.FeatureFlags.EnableAIRecaps
    }
    return &Scheduler{
        PeriodicScheduler: jobs.NewPeriodicScheduler(
            jobServer,
            model.JobTypeScheduledRecap,
            SchedulerPollingInterval,
            isEnabled,
        ),
        store: storeInstance,
    }
}

// NextScheduleTime overrides to use tight polling interval
func (s *Scheduler) NextScheduleTime(cfg *model.Config, now time.Time, pendingJobs bool, lastJob *model.Job) *time.Time {
    next := now.Add(SchedulerPollingInterval)
    return &next
}

// ScheduleJob polls for due scheduled recaps and creates jobs
func (s *Scheduler) ScheduleJob(rctx request.CTX, cfg *model.Config, pendingJobs bool, lastJob *model.Job) (*model.Job, *model.AppError) {
    now := model.GetMillis()
    dueRecaps, err := s.store.ScheduledRecap().GetDueBefore(now, 100)
    if err != nil {
        mlog.Error("Failed to get due scheduled recaps", mlog.Err(err))
        return nil, nil
    }

    for _, sr := range dueRecaps {
        jobData := model.StringMap{
            "scheduled_recap_id": sr.Id,
            "user_id":            sr.UserId,
            "channel_ids":        strings.Join(sr.ChannelIds, ","),
            "agent_id":           sr.AgentId,
        }
        
        _, jobErr := s.PeriodicScheduler.Jobs().CreateJobOnce(rctx, model.JobTypeScheduledRecap, jobData)
        if jobErr != nil {
            // Job might already exist - this is OK (deduplication)
            mlog.Debug("Scheduled recap job creation skipped", 
                mlog.String("scheduled_recap_id", sr.Id),
                mlog.Err(jobErr))
        }
    }

    return nil, nil
}
```

Note: You need to expose the jobs field from PeriodicScheduler. Check if there's a Jobs() accessor or use the embedded field directly. Reference `delete_expired_posts/scheduler.go` pattern.
  </action>
  <verify>
Run `go build ./server/channels/jobs/scheduled_recap/` - should compile without errors.
  </verify>
  <done>
Scheduler.go exists with MakeScheduler function, 1-minute polling, GetDueBefore query, and CreateJobOnce for each due recap.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create worker implementation</name>
  <files>server/channels/jobs/scheduled_recap/worker.go</files>
  <action>
Create `server/channels/jobs/scheduled_recap/worker.go`:

The worker must:
1. Define AppIface interface with CreateRecapFromSchedule method (will be implemented in 03-02)
2. Use SimpleWorker pattern (like recap/worker.go and delete_expired_posts/worker.go)
3. Be enabled when cfg.FeatureFlags.EnableAIRecaps is true
4. Extract job data: scheduled_recap_id, user_id, channel_ids, agent_id
5. Get the ScheduledRecap from store to verify it still exists and is enabled
6. Call app.CreateRecapFromSchedule to create the actual recap
7. Compute next run time using sr.ComputeNextRunAt(time.Now())
8. Call store.ScheduledRecap().MarkExecuted(id, lastRunAt, nextRunAt)
9. For non-recurring schedules (!sr.IsRecurring), call SetEnabled(id, false)

Pattern to follow:
```go
package scheduled_recap

import (
    "fmt"
    "time"

    "github.com/mattermost/mattermost/server/public/model"
    "github.com/mattermost/mattermost/server/public/shared/mlog"
    "github.com/mattermost/mattermost/server/public/shared/request"
    "github.com/mattermost/mattermost/server/v8/channels/jobs"
    "github.com/mattermost/mattermost/server/v8/channels/store"
)

type AppIface interface {
    CreateRecapFromSchedule(rctx request.CTX, scheduledRecap *model.ScheduledRecap) (*model.Recap, *model.AppError)
}

func MakeWorker(jobServer *jobs.JobServer, storeInstance store.Store, app AppIface) *jobs.SimpleWorker {
    const workerName = "ScheduledRecap"

    isEnabled := func(cfg *model.Config) bool {
        return cfg.FeatureFlags.EnableAIRecaps
    }

    execute := func(logger mlog.LoggerIFace, job *model.Job) error {
        defer jobServer.HandleJobPanic(logger, job)

        scheduledRecapID := job.Data["scheduled_recap_id"]

        // Get the scheduled recap
        sr, err := storeInstance.ScheduledRecap().Get(scheduledRecapID)
        if err != nil {
            return fmt.Errorf("scheduled recap not found: %w", err)
        }

        // Verify still enabled
        if !sr.Enabled {
            logger.Info("Scheduled recap is disabled, skipping",
                mlog.String("scheduled_recap_id", scheduledRecapID))
            return nil
        }

        // Create the actual recap
        rctx := request.EmptyContext(logger)
        _, appErr := app.CreateRecapFromSchedule(rctx, sr)
        if appErr != nil {
            return fmt.Errorf("failed to create recap from schedule: %w", appErr)
        }

        // Compute next run time
        now := time.Now()
        nextRunAt, computeErr := sr.ComputeNextRunAt(now)
        if computeErr != nil {
            logger.Error("Failed to compute next run time",
                mlog.String("scheduled_recap_id", scheduledRecapID),
                mlog.Err(computeErr))
            // Disable if can't compute next run
            _ = storeInstance.ScheduledRecap().SetEnabled(scheduledRecapID, false)
            return nil
        }

        // Update scheduled recap state atomically
        lastRunAt := model.GetMillis()
        if markErr := storeInstance.ScheduledRecap().MarkExecuted(scheduledRecapID, lastRunAt, nextRunAt); markErr != nil {
            return fmt.Errorf("failed to mark executed: %w", markErr)
        }

        // Handle non-recurring schedules
        if !sr.IsRecurring {
            logger.Info("Disabling non-recurring scheduled recap",
                mlog.String("scheduled_recap_id", scheduledRecapID))
            _ = storeInstance.ScheduledRecap().SetEnabled(scheduledRecapID, false)
        }

        logger.Info("Scheduled recap executed successfully",
            mlog.String("scheduled_recap_id", scheduledRecapID),
            mlog.Int64("next_run_at", nextRunAt))

        return nil
    }

    return jobs.NewSimpleWorker(workerName, jobServer, execute, isEnabled)
}
```
  </action>
  <verify>
Run `go build ./server/channels/jobs/scheduled_recap/` - should compile without errors.
Check the AppIface interface is correctly defined (will be implemented in 03-02).
  </verify>
  <done>
Worker.go exists with MakeWorker function, AppIface interface, job execution logic including state updates and non-recurring handling.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `go build ./server/public/model/` - model compiles
2. Run `go build ./server/channels/jobs/scheduled_recap/` - scheduler and worker compile
3. Verify file structure: `ls server/channels/jobs/scheduled_recap/` shows scheduler.go and worker.go
4. Verify job type: `grep -c "JobTypeScheduledRecap" server/public/model/job.go` returns 2 (constant + AllJobTypes)
</verification>

<success_criteria>
1. JobTypeScheduledRecap constant defined in model/job.go and added to AllJobTypes
2. Scheduler polls GetDueBefore every 1 minute and creates jobs with CreateJobOnce
3. Worker executes scheduled recap, calls MarkExecuted, and handles non-recurring schedules
4. All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-scheduler-integration/03-01-SUMMARY.md`
</output>
