---
phase: 03-scheduler-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - server/channels/app/server.go
  - server/channels/app/scheduled_recap.go
autonomous: true

must_haves:
  truths:
    - "ScheduledRecap job type is registered with JobServer"
    - "App.CreateRecapFromSchedule creates a Recap from a ScheduledRecap"
    - "Scheduled recaps execute automatically at the scheduled time"
    - "Job execution is cluster-aware (scheduler runs on leader only)"
  artifacts:
    - path: "server/channels/app/server.go"
      provides: "Job registration for ScheduledRecap"
      contains: "JobTypeScheduledRecap"
    - path: "server/channels/app/scheduled_recap.go"
      provides: "CreateRecapFromSchedule method"
      contains: "CreateRecapFromSchedule"
  key_links:
    - from: "server/channels/app/server.go"
      to: "scheduled_recap.MakeWorker"
      via: "RegisterJobType"
      pattern: "RegisterJobType.*JobTypeScheduledRecap"
    - from: "server/channels/app/scheduled_recap.go"
      to: "store.Recap().SaveRecap"
      via: "direct store save"
      pattern: "Store\\(\\)\\.Recap\\(\\)\\.SaveRecap"
    - from: "server/channels/app/scheduled_recap.go"
      to: "model.JobTypeRecap"
      via: "job creation"
      pattern: "JobTypeRecap"
---

<objective>
Register the ScheduledRecap job type and implement the App method to create recaps from scheduled recap configurations.

Purpose: Complete the scheduler integration by wiring up the job system and implementing the recap creation logic.
Output: Job registration in initJobs and CreateRecapFromSchedule App method.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scheduler-integration/03-RESEARCH.md
@.planning/phases/03-scheduler-integration/03-01-SUMMARY.md

# Key existing files
@server/channels/app/server.go
@server/channels/app/scheduled_recap.go
@server/channels/app/recap.go
@server/channels/jobs/scheduled_recap/scheduler.go
@server/channels/jobs/scheduled_recap/worker.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add job registration in initJobs</name>
  <files>server/channels/app/server.go</files>
  <action>
Add the ScheduledRecap job registration to server/channels/app/server.go in the initJobs() function.

1. Add import for the scheduled_recap package at the top of the file (around line 64, with other job imports):
   ```go
   "github.com/mattermost/mattermost/server/v8/channels/jobs/scheduled_recap"
   ```

2. Add job registration in initJobs() function, after the existing recap job registration (around line 1635):
   ```go
   s.Jobs.RegisterJobType(
       model.JobTypeScheduledRecap,
       scheduled_recap.MakeWorker(s.Jobs, s.Store(), New(ServerConnector(s.Channels()))),
       scheduled_recap.MakeScheduler(s.Jobs, s.Store()),
   )
   ```

Follow the exact pattern used by other jobs like delete_expired_posts which has both worker and scheduler:
- First arg: job type constant
- Second arg: worker created with MakeWorker(jobServer, store, app)
- Third arg: scheduler created with MakeScheduler(jobServer, store)

The `New(ServerConnector(s.Channels()))` creates an App instance that implements the AppIface interface.
  </action>
  <verify>
Run `go build ./server/channels/app/` - should compile without errors.
Run `grep -n "JobTypeScheduledRecap" server/channels/app/server.go` - should show the registration.
  </verify>
  <done>
ScheduledRecap job is registered in initJobs with both worker and scheduler.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CreateRecapFromSchedule App method</name>
  <files>server/channels/app/scheduled_recap.go</files>
  <action>
Add the CreateRecapFromSchedule method to server/channels/app/scheduled_recap.go.

**IMPORTANT:** This method is called from a job worker context where there is NO session. 
The existing `CreateRecap(rctx, title, channelIDs, agentID)` method uses `rctx.Session().UserId` 
internally, which will fail from a worker context. Therefore, CreateRecapFromSchedule must:
1. Create the recap record directly via store (using sr.UserId)
2. Create the recap job directly
3. NOT delegate to CreateRecap

Add the required import at the top of the file (with other imports):
```go
"strings"
```

Add this method after the existing methods in the file:

```go
// CreateRecapFromSchedule creates a Recap from a ScheduledRecap configuration.
// This is called by the scheduled recap worker when executing a scheduled recap.
// NOTE: This method does NOT use CreateRecap because that method relies on
// rctx.Session().UserId which is not available in a job worker context.
func (a *App) CreateRecapFromSchedule(rctx request.CTX, sr *model.ScheduledRecap) (*model.Recap, *model.AppError) {
    var channelIDs []string

    if sr.ChannelMode == model.ChannelModeSpecific {
        channelIDs = sr.ChannelIds
    } else {
        // all_unreads mode: get user's channels with unread messages
        // For now, use the specified channel IDs as fallback
        // TODO: Implement GetChannelsWithUnreadForUser when all_unreads mode is needed
        channelIDs = sr.ChannelIds
    }

    if len(channelIDs) == 0 {
        return nil, model.NewAppError("CreateRecapFromSchedule", "app.scheduled_recap.no_channels.app_error", nil, "", http.StatusBadRequest)
    }

    timeNow := model.GetMillis()

    // Create recap record directly (not using CreateRecap which requires session)
    recap := &model.Recap{
        Id:                model.NewId(),
        UserId:            sr.UserId,  // Use UserId from ScheduledRecap, not session
        Title:             sr.Title,
        CreateAt:          timeNow,
        UpdateAt:          timeNow,
        DeleteAt:          0,
        ReadAt:            0,
        TotalMessageCount: 0,
        Status:            model.RecapStatusPending,
        BotID:             sr.AgentId,
    }

    savedRecap, err := a.Srv().Store().Recap().SaveRecap(recap)
    if err != nil {
        return nil, model.NewAppError("CreateRecapFromSchedule", "app.scheduled_recap.save_recap.app_error", nil, "", http.StatusInternalServerError).Wrap(err)
    }

    // Create recap job to trigger processing
    jobData := map[string]string{
        "recap_id":    savedRecap.Id,
        "user_id":     sr.UserId,
        "channel_ids": strings.Join(channelIDs, ","),
        "agent_id":    sr.AgentId,
    }

    _, jobErr := a.CreateJob(rctx, &model.Job{
        Type: model.JobTypeRecap,
        Data: jobData,
    })
    if jobErr != nil {
        return nil, jobErr
    }

    return savedRecap, nil
}
```

This mirrors the logic in app/recap.go CreateRecap but uses sr.UserId instead of rctx.Session().UserId.
  </action>
  <verify>
Run `go build ./server/channels/app/` - should compile without errors.
Run `grep -n "CreateRecapFromSchedule" server/channels/app/scheduled_recap.go` - should show the method.
Run `grep -n "sr.UserId" server/channels/app/scheduled_recap.go` - should show UserId is taken from ScheduledRecap.
  </verify>
  <done>
CreateRecapFromSchedule method exists and creates a Recap from ScheduledRecap configuration using sr.UserId (not session).
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify full integration compiles</name>
  <files>server/channels/app/server.go, server/channels/jobs/scheduled_recap/scheduler.go, server/channels/jobs/scheduled_recap/worker.go</files>
  <action>
Verify the complete integration compiles and all pieces connect:

1. Run full server build: `go build ./server/...` or `make build-server` (depending on project setup)
2. If there are compile errors, fix them:
   - Check that AppIface in worker.go matches the App method signature (CreateRecapFromSchedule takes request.CTX and *model.ScheduledRecap)
   - Check that scheduler properly accesses JobServer methods
   - Verify import paths are correct

Common issues to check:
- If PeriodicScheduler doesn't expose Jobs(), you may need to store jobServer directly in Scheduler struct
- Ensure worker.go's AppIface interface includes: CreateRecapFromSchedule(request.CTX, *model.ScheduledRecap) (*model.Recap, *model.AppError)
  </action>
  <verify>
Run `go build ./server/channels/...` - full build should succeed.
Run `go vet ./server/channels/jobs/scheduled_recap/...` - no issues.
  </verify>
  <done>
Full integration compiles: job registration, scheduler, worker, and App method all work together.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `go build ./server/channels/...` - full channels build succeeds
2. Verify job registration: `grep -A3 "JobTypeScheduledRecap" server/channels/app/server.go`
3. Verify App method: `grep -A10 "CreateRecapFromSchedule" server/channels/app/scheduled_recap.go`
4. Verify scheduler->store link: `grep "GetDueBefore" server/channels/jobs/scheduled_recap/scheduler.go`
5. Verify worker->app link: `grep "CreateRecapFromSchedule" server/channels/jobs/scheduled_recap/worker.go`
</verification>

<success_criteria>
1. ScheduledRecap job registered in initJobs with worker and scheduler
2. CreateRecapFromSchedule App method creates Recap from ScheduledRecap config
3. Full integration compiles without errors
4. Scheduler runs only on cluster leader (via standard job system)
5. Worker updates ScheduledRecap state after execution
</success_criteria>

<output>
After completion, create `.planning/phases/03-scheduler-integration/03-02-SUMMARY.md`
</output>
