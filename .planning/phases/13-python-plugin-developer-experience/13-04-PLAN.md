---
phase: 13-python-plugin-developer-experience
plan: 04
type: execute
depends_on: ["13-01"]
files_modified: [examples/hello_python/CLAUDE.md, python-sdk/CLAUDE.md, server/public/pluginapi/grpc/CLAUDE.md]
---

<objective>
Create CLAUDE.md files for agentic AI development guidance in key project areas.

Purpose: Enable Claude Code and other AI assistants to effectively work with the Python plugin system.
Output: Three CLAUDE.md files: example plugin (for plugin developers), Python SDK (for SDK maintainers), server gRPC (for Mattermost contributors).
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

**Existing CLAUDE.md example:**
@e2e-tests/playwright/CLAUDE.md

**Architecture docs (from 13-01):**
@server/public/pluginapi/grpc/ARCHITECTURE.md (if exists after 13-01)

**Key files to reference:**
@examples/hello_python/plugin.py
@python-sdk/src/mattermost_plugin/plugin.py
@python-sdk/src/mattermost_plugin/hooks.py
@server/public/plugin/python_supervisor.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create example plugin CLAUDE.md</name>
  <files>examples/hello_python/CLAUDE.md</files>
  <action>
Create CLAUDE.md at examples/hello_python/CLAUDE.md with guidance for plugin developers:

```markdown
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with Mattermost Python plugins.

## Repository Purpose

This is an example Mattermost Python plugin demonstrating the Python Plugin SDK. Use it as a template for building your own Python plugins.

## Key Commands

### Setup

```bash
# Create virtual environment with SDK
make venv

# Activate the environment
source venv/bin/activate
```

### Development

```bash
# Run linting
make lint

# Package for upload to Mattermost
make dist
```

### Packaging

```bash
# Create plugin bundle (includes vendored SDK)
make dist

# Create minimal bundle (server must have SDK installed)
make dist-minimal

# Clean build artifacts
make clean
```

## Architecture Overview

### Plugin Structure

- `plugin.json` - Plugin manifest defining metadata and runtime
- `plugin.py` - Main plugin implementation
- `requirements.txt` - Python dependencies

### Plugin Implementation Pattern

```python
from mattermost_plugin import Plugin, hook, HookName

class MyPlugin(Plugin):
    @hook(HookName.OnActivate)
    def on_activate(self) -> None:
        self.logger.info("Plugin activated!")
        # Initialize state, register commands

    @hook(HookName.MessageWillBePosted)
    def filter_message(self, context, post):
        # Return (post, "") to allow, (None, "reason") to reject
        return post, ""

if __name__ == "__main__":
    from mattermost_plugin.server import run_plugin
    run_plugin(MyPlugin)
```

### Available Hooks

- `OnActivate` / `OnDeactivate` - Lifecycle events
- `MessageWillBePosted` / `MessageHasBeenPosted` - Message filtering
- `ExecuteCommand` - Slash command handling
- `ServeHTTP` - HTTP endpoint handling
- See `mattermost_plugin.HookName` for full list

### API Client Usage

```python
# In any hook handler, use self.api:
user = self.api.get_user(user_id)
self.api.create_post(post)
self.api.kv_set("key", value_bytes)
```

## Best Practices

1. **Logging**: Use `self.logger` instead of print()
2. **Error Handling**: Wrap API calls in try/except
3. **State**: Use KV store for persistent state, not module-level variables
4. **Commands**: Register commands in OnActivate, they persist across restarts
5. **Testing**: Test locally before packaging

## Manifest Format (plugin.json)

```json
{
  "id": "com.example.my-plugin",
  "name": "My Plugin",
  "version": "1.0.0",
  "min_server_version": "10.0.0",
  "server": {
    "executable": "plugin.py",
    "runtime": "python",
    "python_version": ">=3.9"
  }
}
```
```
  </action>
  <verify>test -f examples/hello_python/CLAUDE.md</verify>
  <done>Example plugin CLAUDE.md created with setup, development, and best practices guidance</done>
</task>

<task type="auto">
  <name>Task 2: Create Python SDK CLAUDE.md</name>
  <files>python-sdk/CLAUDE.md</files>
  <action>
Create CLAUDE.md at python-sdk/CLAUDE.md with guidance for SDK maintainers:

```markdown
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with the Mattermost Python Plugin SDK.

## Repository Purpose

This is the Python SDK for Mattermost plugins. It provides:
- gRPC client for calling Mattermost Plugin API
- Plugin base class and hook decorators
- Type-safe wrappers for Mattermost data types

## Key Commands

### Setup

```bash
# Create virtual environment with dev dependencies
make venv

# Activate environment
source .venv/bin/activate
```

### Development

```bash
# Regenerate gRPC code from proto files
make proto-gen

# Run tests
make test

# Run type checking
make lint

# Build package
make build
```

### Testing

```bash
# Run all tests
pytest tests/ -v

# Run specific test file
pytest tests/test_hooks_lifecycle.py -v

# Run integration tests (requires Go binaries)
pytest tests/test_integration_e2e.py -v
```

## Architecture Overview

### Directory Structure

```
python-sdk/
├── src/mattermost_plugin/
│   ├── __init__.py          # Public API exports
│   ├── plugin.py            # Plugin base class
│   ├── hooks.py             # @hook decorator and HookName enum
│   ├── client.py            # Sync API client
│   ├── async_client.py      # Async API client
│   ├── server.py            # gRPC server for hooks
│   ├── exceptions.py        # Exception types
│   ├── _internal/           # Internal implementation
│   │   └── wrappers.py      # Proto-to-Python type wrappers
│   ├── grpc/                # Generated gRPC code (do not edit)
│   └── servicers/           # gRPC servicer implementations
│       └── hooks_servicer.py
├── tests/                   # Test suite
└── scripts/
    └── generate_protos.py   # Proto generation script
```

### Key Components

1. **Plugin Class** (`plugin.py`)
   - Base class all plugins inherit from
   - Provides `self.api` and `self.logger`
   - Uses `__init_subclass__` for hook discovery

2. **Hook System** (`hooks.py`)
   - `@hook(HookName.X)` decorator
   - `HookName` enum with all available hooks
   - Automatic registration via metaclass

3. **API Client** (`client.py`)
   - Typed wrapper around gRPC stubs
   - Mixin classes for API domains (UsersMixin, ChannelsMixin, etc.)
   - Converts proto types to Python dataclasses

4. **gRPC Server** (`server.py`)
   - PluginHooks gRPC server
   - Handles hook dispatch from Go server
   - Health checking for go-plugin protocol

### Code Generation

Proto files are in `server/public/pluginapi/grpc/proto/`. After modifying:

```bash
# From python-sdk/
make proto-gen

# Or from server/
make python-proto-gen
```

Generated files go to `src/mattermost_plugin/grpc/`.

## Best Practices

1. **Type Annotations**: All public APIs must have type hints
2. **Proto Wrappers**: Use `_internal/wrappers.py` for proto conversions
3. **Testing**: Add tests for any new hooks or API methods
4. **Backwards Compatibility**: Don't break existing plugin APIs
5. **Generated Code**: Never manually edit files in `grpc/` directory

## Adding a New Hook

1. Define hook in `server/public/pluginapi/grpc/proto/hooks_*.proto`
2. Run `make proto-gen-all` from server/
3. Add to `HookName` enum in `hooks.py`
4. Add handler in `servicers/hooks_servicer.py`
5. Add test in `tests/test_hooks_*.py`

## Adding a New API Method

1. Define RPC in `server/public/pluginapi/grpc/proto/api*.proto`
2. Run `make proto-gen-all` from server/
3. Add to appropriate mixin in `client.py`
4. Add wrapper types to `_internal/wrappers.py` if needed
5. Add test in `tests/test_client_*.py`
```
  </action>
  <verify>test -f python-sdk/CLAUDE.md</verify>
  <done>Python SDK CLAUDE.md created with architecture, development workflow, and contribution guidance</done>
</task>

<task type="auto">
  <name>Task 3: Create server gRPC CLAUDE.md</name>
  <files>server/public/pluginapi/grpc/CLAUDE.md</files>
  <action>
Create CLAUDE.md at server/public/pluginapi/grpc/CLAUDE.md with guidance for Mattermost contributors:

```markdown
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with the Mattermost Python plugin gRPC infrastructure.

## Repository Purpose

This directory contains the Go-side gRPC infrastructure enabling Python plugins to communicate with the Mattermost server. It provides:
- Protocol buffer definitions for Plugin API and hooks
- gRPC server implementation for API callbacks
- Type conversion between Go models and protobuf
- ServeHTTP bidirectional streaming

## Key Commands

### Code Generation

```bash
# From server/ directory:

# Generate Go code from proto files
make -C public proto-gen

# Generate both Go and Python code
make -C public proto-gen-all
```

### Testing

```bash
# Run gRPC server tests
go test ./public/pluginapi/grpc/server/... -v

# Run Python supervisor tests
go test ./public/plugin/... -v -run Python

# Run integration tests
go test ./public/pluginapi/grpc/server/... -v -run Integration
```

## Architecture Overview

### Directory Structure

```
server/public/pluginapi/grpc/
├── proto/                    # Protocol buffer definitions
│   ├── common.proto          # Shared types (AppError, StringMap)
│   ├── user.proto            # User type
│   ├── channel.proto         # Channel type
│   ├── post.proto            # Post type
│   ├── team.proto            # Team type
│   ├── file.proto            # File types
│   ├── api.proto             # PluginAPI service definition
│   ├── api_*.proto           # API method groups
│   ├── hooks.proto           # PluginHooks service definition
│   └── hooks_*.proto         # Hook method groups
├── generated/go/pluginapiv1/ # Generated Go code (do not edit)
└── server/                   # gRPC server implementation
    ├── api_server.go         # Server startup and registration
    ├── handlers_*.go         # RPC method handlers
    ├── convert_*.go          # Go model ↔ proto conversion
    ├── serve_http.go         # ServeHTTP streaming handler
    └── errors.go             # Error conversion utilities
```

### Key Components

1. **Python Supervisor** (`plugin/python_supervisor.go`)
   - Spawns Python plugin subprocess
   - Sets up go-plugin gRPC connection
   - Passes API server address via env var

2. **Hooks gRPC Client** (`plugin/hooks_grpc_client.go`)
   - Implements `plugin.Hooks` interface
   - Dispatches hooks to Python via gRPC
   - Converts Go types to proto messages

3. **API Server** (`grpc/server/api_server.go`)
   - gRPC server Python plugins connect to
   - Implements PluginAPI service
   - Calls actual `plugin.API` methods

4. **ServeHTTP** (`grpc/server/serve_http.go`)
   - Bidirectional streaming for HTTP
   - 64KB chunks for request/response bodies
   - Handles flush signals

### Proto File Organization

| File | Purpose |
|------|---------|
| `api.proto` | PluginAPI service (all RPC definitions) |
| `api_user_team.proto` | User and Team API messages |
| `api_channel_post.proto` | Channel and Post API messages |
| `api_kv_config.proto` | KV Store and Config messages |
| `api_file_bot.proto` | File and Bot messages |
| `api_remaining.proto` | All other API messages |
| `hooks.proto` | PluginHooks service definition |
| `hooks_*.proto` | Hook messages by category |

## Best Practices

1. **Proto Changes**: Always regenerate Go AND Python code after proto changes
2. **Type Conversion**: Add converters in `convert_*.go` for new types
3. **Error Handling**: Use `ToAppErrorProto`/`FromAppErrorProto` for errors
4. **Testing**: Add tests in `*_test.go` for new handlers
5. **JSON Blobs**: Use `bytes *_json` for complex types (Config, License)

## Adding a New API Method

1. Add RPC to `api.proto` service definition
2. Add request/response messages to appropriate `api_*.proto`
3. Run `make -C public proto-gen-all`
4. Add handler method to appropriate `handlers_*.go`
5. Add conversion functions to `convert_*.go` if new types
6. Add test in `handlers_test.go`
7. Update Python SDK client (see python-sdk/CLAUDE.md)

## Adding a New Hook

1. Add RPC to `hooks.proto` service definition
2. Add request/response messages to appropriate `hooks_*.proto`
3. Run `make -C public proto-gen-all`
4. Add handler in `plugin/hooks_grpc_client.go`
5. Update Python SDK hooks (see python-sdk/CLAUDE.md)

## Common Patterns

### Response-Embedded Errors

All RPC responses include optional `AppError`:

```protobuf
message GetUserResponse {
  User user = 1;
  AppError error = 2;
}
```

Handlers check for errors from API calls and populate the error field:

```go
user, appErr := s.api.GetUser(req.UserId)
if appErr != nil {
    return &pb.GetUserResponse{Error: ToAppErrorProto(appErr)}, nil
}
return &pb.GetUserResponse{User: ToUserProto(user)}, nil
```

### ServeHTTP Streaming

ServeHTTP uses bidirectional streaming with message types:

- `HTTPRequestInit` - Initial request metadata
- `HTTPRequestBody` - Request body chunks
- `HTTPResponseInit` - Response status and headers
- `HTTPResponseBody` - Response body chunks

See `serve_http.go` and `serve_http_test.go` for implementation details.
```
  </action>
  <verify>test -f server/public/pluginapi/grpc/CLAUDE.md</verify>
  <done>Server gRPC CLAUDE.md created with architecture, proto organization, and contribution guidance</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `examples/hello_python/CLAUDE.md` exists
- [ ] `python-sdk/CLAUDE.md` exists
- [ ] `server/public/pluginapi/grpc/CLAUDE.md` exists
- [ ] Each file has: purpose, commands, architecture, best practices sections
</verification>

<success_criteria>

- Three CLAUDE.md files created for different audiences
- Example plugin guide helps plugin developers get started
- SDK guide helps maintainers understand the codebase
- Server guide helps Mattermost contributors extend the system
- All guides follow the pattern established in e2e-tests/playwright/CLAUDE.md
</success_criteria>

<output>
After completion, create `.planning/phases/13-python-plugin-developer-experience/13-04-SUMMARY.md`
</output>
