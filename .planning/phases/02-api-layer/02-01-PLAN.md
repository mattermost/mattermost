---
phase: 02-api-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/channels/app/scheduled_recap.go
  - server/channels/store/storetest/mocks/ScheduledRecapStore.go
autonomous: true

must_haves:
  truths:
    - "App layer can create a scheduled recap with validated inputs"
    - "App layer can retrieve a scheduled recap by ID"
    - "App layer can list scheduled recaps for a user"
    - "App layer can update a scheduled recap"
    - "App layer can delete a scheduled recap (soft delete)"
    - "App layer can pause and resume a scheduled recap"
    - "Resume recalculates NextRunAt before enabling"
  artifacts:
    - path: "server/channels/app/scheduled_recap.go"
      provides: "ScheduledRecap App layer methods"
      exports: ["CreateScheduledRecap", "GetScheduledRecap", "GetScheduledRecapsForUser", "UpdateScheduledRecap", "DeleteScheduledRecap", "PauseScheduledRecap", "ResumeScheduledRecap"]
      min_lines: 120
  key_links:
    - from: "server/channels/app/scheduled_recap.go"
      to: "server/channels/store/sqlstore/scheduled_recap_store.go"
      via: "a.Srv().Store().ScheduledRecap()"
      pattern: "Store\\(\\)\\.ScheduledRecap\\(\\)"
---

<objective>
Create App layer methods for ScheduledRecap CRUD and state management operations.

Purpose: The App layer provides business logic between API handlers and Store layer, handling validation, authorization context, and error wrapping following Mattermost's layered architecture pattern.

Output: `server/channels/app/scheduled_recap.go` with all methods needed by Phase 2 API endpoints.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-foundation/01-01-SUMMARY.md
@.planning/phases/01-database-foundation/01-02-SUMMARY.md

# Reference existing app layer pattern
@server/channels/app/recap.go

# Model and store from Phase 1
@server/public/model/scheduled_recap.go
@server/channels/store/store.go (lines 1310-1325 for ScheduledRecapStore interface)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Regenerate store mocks to include ScheduledRecapStore</name>
  <files>server/channels/store/storetest/mocks/ScheduledRecapStore.go</files>
  <action>
The ScheduledRecapStore interface was added in Phase 1, but the mock store hasn't been regenerated yet. This causes LSP errors in test files.

Run the mock generator to create the mock implementation:
```bash
cd server && make store-mocks
```

This will generate `server/channels/store/storetest/mocks/ScheduledRecapStore.go` and update the Store mock to include the ScheduledRecap() method.

If `make store-mocks` is not available, check for:
```bash
cd server && make generate-mocks
# or
cd server && go generate ./channels/store/...
```
  </action>
  <verify>
```bash
# Verify mock file exists
ls -la server/channels/store/storetest/mocks/ScheduledRecapStore.go

# Verify it has the right interface methods
grep -c "func.*ScheduledRecap" server/channels/store/storetest/mocks/ScheduledRecapStore.go
```
  </verify>
  <done>
ScheduledRecapStore mock exists and the Store mock implements the ScheduledRecap() method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create App layer file with CRUD methods</name>
  <files>server/channels/app/scheduled_recap.go</files>
  <action>
Create `server/channels/app/scheduled_recap.go` following the pattern in `recap.go`:

```go
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

package app

import (
    "net/http"
    "time"

    "github.com/mattermost/mattermost/server/public/model"
    "github.com/mattermost/mattermost/server/public/shared/request"
)
```

Implement these methods following the existing recap.go patterns:

**1. CreateScheduledRecap(rctx request.CTX, recap *model.ScheduledRecap) (*model.ScheduledRecap, *model.AppError)**
- Set recap.UserId from session: `rctx.Session().UserId`
- Call `recap.PreSave()` to generate ID and timestamps
- Validate with `recap.IsValid()` - return error if invalid
- Compute NextRunAt: `recap.ComputeNextRunAt(time.Now())` - return error if fails
- Set recap.NextRunAt from computed value
- Call `a.Srv().Store().ScheduledRecap().Save(recap)`
- Return saved recap or wrap error with: `model.NewAppError("CreateScheduledRecap", "app.scheduled_recap.create.app_error", nil, "", http.StatusInternalServerError).Wrap(err)`

**2. GetScheduledRecap(rctx request.CTX, id string) (*model.ScheduledRecap, *model.AppError)**
- Call `a.Srv().Store().ScheduledRecap().Get(id)`
- Return recap or wrap error with `http.StatusNotFound`

**3. GetScheduledRecapsForUser(rctx request.CTX, page, perPage int) ([]*model.ScheduledRecap, *model.AppError)**
- Get userId from session: `rctx.Session().UserId`
- Call `a.Srv().Store().ScheduledRecap().GetForUser(userId, page, perPage)`
- Return recaps or wrap error with `http.StatusInternalServerError`

**4. UpdateScheduledRecap(rctx request.CTX, recap *model.ScheduledRecap) (*model.ScheduledRecap, *model.AppError)**
- Call `recap.PreUpdate()` to set UpdateAt
- Validate with `recap.IsValid()` - return error if invalid
- If recap.Enabled is true, recompute NextRunAt with `time.Now()`
- Call `a.Srv().Store().ScheduledRecap().Update(recap)`
- Return updated recap or wrap error

**5. DeleteScheduledRecap(rctx request.CTX, id string) *model.AppError**
- Call `a.Srv().Store().ScheduledRecap().Delete(id)`
- Return nil or wrap error with `http.StatusInternalServerError`

**6. PauseScheduledRecap(rctx request.CTX, id string) (*model.ScheduledRecap, *model.AppError)**
- Get existing recap: `a.Srv().Store().ScheduledRecap().Get(id)`
- Return error if not found
- Call `a.Srv().Store().ScheduledRecap().SetEnabled(id, false)`
- Return error if fails
- Fetch and return updated recap

**7. ResumeScheduledRecap(rctx request.CTX, id string) (*model.ScheduledRecap, *model.AppError)**
- Get existing recap: `a.Srv().Store().ScheduledRecap().Get(id)`
- Return error if not found
- Compute new NextRunAt: `recap.ComputeNextRunAt(time.Now())`
- Return error if computation fails
- Update NextRunAt: `a.Srv().Store().ScheduledRecap().UpdateNextRunAt(id, nextRunAt)`
- Return error if fails
- Enable: `a.Srv().Store().ScheduledRecap().SetEnabled(id, true)`
- Return error if fails
- Fetch and return updated recap

Error ID pattern: `app.scheduled_recap.{operation}.app_error`
  </action>
  <verify>
```bash
# Verify file exists and compiles
cd server && go build ./channels/app/...

# Check methods exist
grep -E "func \(a \*App\) (Create|Get|Update|Delete|Pause|Resume)ScheduledRecap" channels/app/scheduled_recap.go
```
  </verify>
  <done>
All 7 App layer methods exist and compile successfully. Methods call Store layer and wrap errors with appropriate HTTP status codes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Regenerate app layer interfaces if needed</name>
  <files>server/channels/app/app_iface.go</files>
  <action>
Check if app_iface.go needs updating. In Mattermost, the app interface is often auto-generated.

First, check if there's a make target or generation script:
```bash
grep -r "app_iface" server/channels/app/Makefile 2>/dev/null || true
grep -r "generate" server/channels/app/*.go | head -5
```

If app_iface.go is auto-generated (has `//go:generate` comment), run the generator:
```bash
cd server && make app-layers
```

If not auto-generated, manually add the interface methods to match what was created in Task 2.

Verify the methods are accessible through the AppIface interface if one exists.
  </action>
  <verify>
```bash
# Verify the full server builds including any interface checks
cd server && go build ./...
```
  </verify>
  <done>
Server builds successfully with new App layer methods. Interface layer (if applicable) is updated.
  </done>
</task>

</tasks>

<verification>
```bash
# Full build verification
cd server && go build ./channels/app/...

# Method signature check
grep -c "ScheduledRecap" server/channels/app/scheduled_recap.go

# Ensure it imports the model
grep "model.ScheduledRecap" server/channels/app/scheduled_recap.go
```
</verification>

<success_criteria>
1. `server/channels/app/scheduled_recap.go` exists with all 7 methods
2. All methods follow existing patterns (error wrapping, store calls)
3. CreateScheduledRecap computes NextRunAt before saving
4. ResumeScheduledRecap recomputes NextRunAt before enabling
5. Server compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-layer/02-01-SUMMARY.md`
</output>
