## Objective

Implement the **User / Team / Channel** subset of the gRPC `PluginAPI` service by wiring the generated protobuf RPCs to the existing Go `plugin.API` interface.

This plan builds on the Phase 04-01 scaffolding and should result in a meaningful, testable slice of “real” API coverage.

## Execution Context

- `.planning/STATE.md`, `.planning/ROADMAP.md`
- `.planning/phases/01-protocol-foundation/01-RESEARCH.md` (error/status guidance + directory layout)
- **Must already exist from previous phases**:
  - `server/public/pluginapi/grpc/proto/api.proto`
  - Generated Go code under `server/public/pluginapi/grpc/generated/go/`
  - Phase 04-01 server scaffolding under `server/public/pluginapi/grpc/server/`
- **Authoritative API surface**:
  - `server/public/plugin/api.go` (method list + `@tag` grouping)
- **Mocks for testing**:
  - `server/public/plugin/plugintest` (mockery-generated mocks for `plugin.API`)

## Context

### Scope Definition (What counts as “User/Team/Channel”)

Use `server/public/plugin/api.go` comment tags to scope:

- `@tag User`
- `@tag Team`
- `@tag Channel`

Implement the corresponding RPCs in `api.proto` whose names match these interface methods.

### Conversion Strategy (pb ↔ model)

This plan assumes Phase 2 defined protobuf types under `plugin.proto` that represent the required Mattermost model objects (e.g., `User`, `Team`, `Channel`, `TeamMember`, etc.).

Before implementing methods, confirm:

- Which objects are represented as **typed messages** vs **Struct/JSON blobs**
- Whether ID fields are `string`, timestamps are `int64`, and enums are `int32`/`enum`

Then implement conversion helpers in a single place under the server package so they can be reused across plans:

- `server/public/pluginapi/grpc/server/convert_user.go`
- `server/public/pluginapi/grpc/server/convert_team.go`
- `server/public/pluginapi/grpc/server/convert_channel.go`

### Error Handling

All methods must:

- Return `status.Error(...)` via the helpers from 04-01
- Never “pack” errors into response messages

## Tasks

### Task 1: Produce an explicit method checklist (so we don’t miss coverage)

- From `server/public/plugin/api.go`, generate a checklist of method names in the `User/Team/Channel` tags.
  - Lightweight approach: `grep -n "@tag User" -A3 ...` and extract method signatures
  - Better approach: write a tiny Go script using `go/parser` to list interface methods + preceding `@tag` blocks
- Cross-check against `api.proto` RPC names; reconcile any naming differences **now** (this usually indicates Phase 2 proto mismatch).

### Task 2: Implement conversions for core objects in this slice

Add conversion helpers to translate between:

- `pb.User` ↔ `model.User`
- `pb.Team` ↔ `model.Team`
- `pb.Channel` ↔ `model.Channel`
- Any required supporting types for these methods (e.g., `TeamMember`, `ChannelMember`, `ChannelSearch`, `UserGetOptions`, etc.)

Guidelines:

- Keep conversions **pure** (no side effects, no API calls)
- Prefer `nil`-safe behavior; if `req.User == nil` and method requires it, return `InvalidArgument`
- Add focused unit tests for a few conversions that are likely to be tricky (timestamps, nested arrays, maps)

### Task 3: Implement gRPC handlers for User APIs

In `server/public/pluginapi/grpc/server/api_server.go` (or split into `api_user.go` for cleanliness):

- Implement each User-tagged RPC:
  - Validate request
  - Convert request to model types
  - Call `s.impl.<Method>(...)`
  - Convert response model to pb types
  - Map errors via `appErrorToStatus`

Add unit tests for at least:

- One “returns object” method (e.g., `GetUser`)
- One “creates object” method (e.g., `CreateUser`)
- One “list” method (e.g., `GetUsers`)
- One error mapping case (e.g., `NOT_FOUND`)

All tests should use:

- bufconn gRPC server from 04-01
- `plugintest.API` mock to control outputs and verify the wrapper calls are correct

### Task 4: Implement gRPC handlers for Team APIs

Repeat the same pattern for Team-tagged methods.

Add unit tests for at least:

- `CreateTeam` (success)
- A method returning `*model.AppError` only (no return value) to verify “empty response + error handling” pattern

### Task 5: Implement gRPC handlers for Channel APIs

Repeat the same pattern for Channel-tagged methods.

Add unit tests for at least:

- `CreateChannel` (success)
- A method returning a list of channels and/or members

### Task 6: Keep the implementation maintainable

- If `api_server.go` becomes unwieldy, split by domain:
  - `api_user.go`, `api_team.go`, `api_channel.go`
  - Keep `APIServer` struct + registration in `api_server.go`

## Verification

- `cd server/public && go test ./pluginapi/grpc/server -v`
- Spot-check that unimplemented RPCs still return `codes.Unimplemented` via embedded `UnimplementedPluginAPIServer`

## Success Criteria

- All User/Team/Channel RPCs agreed in the checklist are implemented.
- Tests cover at least one success and one failure path per domain.
- No “proto mismatch” drift: method names and message shapes align with `plugin.API` and Mattermost models.

## Output

- **Modified files** (expected):
  - `server/public/pluginapi/grpc/server/api_server.go` (or split files)
  - `server/public/pluginapi/grpc/server/api_server_test.go`
- **New files** (likely):
  - `server/public/pluginapi/grpc/server/convert_user.go`
  - `server/public/pluginapi/grpc/server/convert_team.go`
  - `server/public/pluginapi/grpc/server/convert_channel.go`


