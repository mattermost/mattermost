---
phase: 11-server-integration
plan: 02
type: execute
depends_on: ["11-01"]
files_modified: [server/public/plugin/supervisor.go]
---

<objective>
Wire the hooksGRPCClient adapter into supervisor.go, removing the Phase 5 limitation that skips hook dispensing for Python plugins.

Purpose: Enable Python plugins to fully participate in the hook dispatch infrastructure.
Output: Python plugins receive hooks identically to Go plugins.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-server-integration/11-RESEARCH.md
@.planning/phases/11-server-integration/11-01-SUMMARY.md

# Key reference files:
@server/public/plugin/supervisor.go - Lines 153-161 contain the Phase 5 limitation to remove
@server/public/plugin/hooks_grpc_client.go - The new adapter from Plan 01
@server/public/plugin/client_rpc.go - Pattern for Go plugins (lines 163-185)

**Tech stack available:** hashicorp/go-plugin GRPCClient
**Established patterns:** hooksTimerLayer wrapper, implemented array population
**Constraining decisions:**
- Phase 5: Python plugins use gRPC protocol
- Phase 11-01: hooksGRPCClient adapter implements Hooks interface
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove Phase 5 limitation and wire hooksGRPCClient</name>
  <files>server/public/plugin/supervisor.go</files>
  <action>
Modify newSupervisor() to use hooksGRPCClient for Python plugins instead of returning early.

Current code (lines 153-161):
```go
// For Python plugins in Phase 5, we skip hook dispensing.
// Hook dispatch will be implemented in Phase 7 (Python Hook System).
// This allows us to test process supervision + health checking independently.
if isPython {
    // Leave sup.hooks as nil - no hooks available yet for Python plugins.
    // The Environment will handle activation/deactivation without calling OnActivate/OnDeactivate.
    wrappedLogger.Info("Python plugin started (hooks not yet available - Phase 5 supervision only)")
    return &sup, nil
}
```

Replace with:
```go
if isPython {
    // Python plugins use gRPC for hook communication.
    // Extract the gRPC connection from go-plugin's client.
    grpcClient, ok := rpcClient.(*plugin.GRPCClient)
    if !ok {
        return nil, errors.New("expected gRPC client for Python plugin")
    }
    conn := grpcClient.Conn

    hooksClient, err := newHooksGRPCClient(conn, wrappedLogger)
    if err != nil {
        return nil, errors.Wrap(err, "failed to create gRPC hooks client")
    }

    sup.hooks = &hooksTimerLayer{pluginInfo.Manifest.Id, hooksClient, metrics}

    // Populate implemented array from gRPC client
    impl, err := hooksClient.Implemented()
    if err != nil {
        return nil, errors.Wrap(err, "failed to query implemented hooks")
    }
    for _, hookName := range impl {
        if hookId, ok := hookNameToId[hookName]; ok {
            sup.implemented[hookId] = true
        }
    }

    wrappedLogger.Info("Python plugin started with gRPC hooks")
    return &sup, nil
}
```

Add import for hashicorp/go-plugin if not already present:
```go
import "github.com/hashicorp/go-plugin"
```

This mirrors the pattern used for Go plugins (lines 163-185) but uses hooksGRPCClient instead of hooksRPCClient.
  </action>
  <verify>go build ./server/public/plugin/... compiles without errors</verify>
  <done>Python plugins now use hooksGRPCClient for hook dispatch</done>
</task>

<task type="auto">
  <name>Task 2: Add integration test for Python hook dispatch</name>
  <files>server/public/plugin/python_supervisor_test.go</files>
  <action>
Add a test that verifies Python plugins can receive hook invocations through the supervisor.

Test name: TestPythonPluginHookDispatch

Test approach:
1. Use the existing fake Python plugin pattern from Phase 5 tests
2. Create a fake Python binary that:
   - Implements PluginHooks gRPC service
   - Reports "OnActivate" and "MessageHasBeenPosted" as implemented
   - Tracks hook invocations in a way we can verify
3. Create supervisor with the fake plugin
4. Call sup.hooks.OnActivate() - verify it succeeds
5. Call sup.hooks.MessageHasBeenPosted() - verify no error
6. Verify sup.Implements(OnActivateID) returns true
7. Verify sup.Implements(MessageHasBeenPostedID) returns true
8. Verify sup.Implements(OnDeactivateID) returns false (not in implemented list)

The fake binary approach from Phase 5 (05-02-PLAN.md) uses go:generate to build test binaries.
Extend that pattern to include a hooks servicer.

If creating a full gRPC servicer is too complex, an alternative approach:
1. Test that newHooksGRPCClient works when given a mock connection
2. Use gomock or manual mock of PluginHooksClient interface
3. Verify the adapter correctly converts between proto and Go types

Choose the approach that best balances coverage with complexity.
  </action>
  <verify>go test ./server/public/plugin/... -run TestPythonPluginHookDispatch passes</verify>
  <done>Test verifies Python plugin hook dispatch works end-to-end</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./server/public/plugin/...` succeeds without errors
- [ ] `go test ./server/public/plugin/...` passes
- [ ] Phase 5 early-return code removed from supervisor.go
- [ ] Python plugins set sup.hooks to hooksGRPCClient wrapped in hooksTimerLayer
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Python plugins fully participate in hook dispatch
</success_criteria>

<output>
After completion, create `.planning/phases/11-server-integration/11-02-SUMMARY.md`
</output>
