---
phase: 11-server-integration
plan: 01
type: execute
depends_on: []
files_modified: [server/public/plugin/hooks_grpc_client.go, server/public/plugin/hooks_grpc_client_test.go]
---

<objective>
Create the hooksGRPCClient adapter that implements the plugin.Hooks interface by delegating to a gRPC PluginHooksClient.

Purpose: Enable Python plugins to receive hook invocations through the same infrastructure as Go plugins.
Output: hooks_grpc_client.go implementing Hooks interface, with unit tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-server-integration/11-RESEARCH.md

# Key reference files:
@server/public/plugin/hooks.go - Hooks interface definition with all hook IDs
@server/public/plugin/client_rpc.go - hooksRPCClient pattern to follow (lines 33-69)
@server/public/pluginapi/grpc/proto/hooks.proto - gRPC service definition
@server/public/pluginapi/grpc/server/serve_http.go - ServeHTTP streaming implementation

# Generated protobuf code location:
@server/public/pluginapi/grpc/generated/go/pluginapiv1/hooks_grpc.pb.go

**Tech stack available:** grpc-go, hashicorp/go-plugin, generated protobuf types
**Established patterns:** hooksRPCClient adapter, hooksTimerLayer wrapper
**Constraining decisions:**
- Phase 4: Domain-split handler files pattern
- Phase 8: Bidirectional streaming for ServeHTTP (64KB chunks)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hooksGRPCClient adapter structure</name>
  <files>server/public/plugin/hooks_grpc_client.go</files>
  <action>
Create hooks_grpc_client.go implementing the Hooks interface by wrapping a gRPC PluginHooksClient.

Structure:
```go
type hooksGRPCClient struct {
    client      pluginapiv1.PluginHooksClient
    implemented [TotalHooksID]bool
    log         *mlog.Logger
}
```

Implement:
1. `newHooksGRPCClient(conn *grpc.ClientConn, log *mlog.Logger) (*hooksGRPCClient, error)` - constructor that calls Implemented() to populate the implemented array
2. `Implemented() ([]string, error)` - returns list of implemented hooks
3. `OnActivate() error` - calls gRPC OnActivate, converts response.Error to model.AppError
4. `OnDeactivate() error` - calls gRPC OnDeactivate
5. `OnConfigurationChange() error` - calls gRPC OnConfigurationChange

For hook methods that return error:
- Use context.Background() with reasonable timeout (30s default, matching existing hook patterns)
- Convert gRPC errors to wrapped errors
- Convert response.Error (AppError proto) to *model.AppError

Import the generated protobuf package:
```go
import pluginapiv1 "github.com/mattermost/mattermost/server/public/pluginapi/grpc/generated/go/pluginapiv1"
```

Do NOT implement ServeHTTP yet - that's Task 2.
  </action>
  <verify>go build ./server/public/plugin/... compiles without errors</verify>
  <done>hooksGRPCClient struct exists with constructor and lifecycle hooks implemented</done>
</task>

<task type="auto">
  <name>Task 2: Implement ServeHTTP with bidirectional streaming</name>
  <files>server/public/plugin/hooks_grpc_client.go</files>
  <action>
Add ServeHTTP method using bidirectional streaming as defined in Phase 8.

ServeHTTP signature:
```go
func (h *hooksGRPCClient) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request)
```

Implementation flow:
1. Open bidirectional stream: `stream, err := h.client.ServeHTTP(r.Context())`
2. Send request init message with method, URL, headers from http.Request
3. Stream request body in 64KB chunks (use io.CopyBuffer pattern)
4. Mark last chunk with body_complete=true
5. Receive response init message with status code, headers
6. Write headers to http.ResponseWriter
7. Stream response body chunks to ResponseWriter
8. Handle flush flag if response supports http.Flusher
9. Use defer stream.CloseSend() for cleanup

Error handling:
- If stream open fails, return http.StatusServiceUnavailable
- If request send fails, return http.StatusBadGateway
- If response receive fails after headers sent, log error (can't write to client)

Reference the existing implementation in:
@server/public/pluginapi/grpc/server/serve_http.go for the streaming protocol details

Key constants:
- Chunk size: 64 * 1024 (64KB)
- Use pluginapiv1.ServeHTTPRequest and ServeHTTPResponse messages
  </action>
  <verify>go build ./server/public/plugin/... compiles without errors</verify>
  <done>ServeHTTP method implemented with bidirectional streaming</done>
</task>

<task type="auto">
  <name>Task 3: Implement remaining hook methods</name>
  <files>server/public/plugin/hooks_grpc_client.go</files>
  <action>
Implement all remaining hooks from the Hooks interface. Group by category:

**Message hooks:**
- MessageWillBePosted(c *Context, post *model.Post) (*model.Post, string)
- MessageWillBeUpdated(c *Context, newPost, oldPost *model.Post) (*model.Post, string)
- MessageHasBeenPosted(c *Context, post *model.Post)
- MessageHasBeenUpdated(c *Context, newPost, oldPost *model.Post)
- MessageHasBeenDeleted(c *Context, post *model.Post)
- MessagesWillBeConsumed(posts []*model.Post) []*model.Post

**User hooks:**
- UserHasBeenCreated(c *Context, user *model.User)
- UserWillLogIn(c *Context, user *model.User) string
- UserHasLoggedIn(c *Context, user *model.User)
- UserHasBeenDeactivated(c *Context, user *model.User)

**Channel/Team hooks:**
- ChannelHasBeenCreated(c *Context, channel *model.Channel)
- UserHasJoinedChannel(c *Context, channelMember *model.ChannelMember, actor *model.User)
- UserHasLeftChannel(c *Context, channelMember *model.ChannelMember, actor *model.User)
- UserHasJoinedTeam(c *Context, teamMember *model.TeamMember, actor *model.User)
- UserHasLeftTeam(c *Context, teamMember *model.TeamMember, actor *model.User)

**Command/WebSocket hooks:**
- ExecuteCommand(c *Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError)
- OnWebSocketConnect(webConnID, userID string)
- OnWebSocketDisconnect(webConnID, userID string)
- WebSocketMessageHasBeenPosted(webConnID, userID string, req *model.WebSocketRequest)

**Remaining hooks:**
- FileWillBeUploaded(c *Context, info *model.FileInfo, file io.Reader, output io.Writer) (*model.FileInfo, string)
- ReactionHasBeenAdded(c *Context, reaction *model.Reaction)
- ReactionHasBeenRemoved(c *Context, reaction *model.Reaction)
- OnPluginClusterEvent(c *Context, ev model.PluginClusterEvent)
- OnInstall(c *Context, event model.OnInstallEvent) error
- OnSendDailyTelemetry()
- RunDataRetention(nowTime, batchSize int64) (int64, error)
- OnCloudLimitsUpdated(limits *model.ProductLimits)
- ConfigurationWillBeSaved(newCfg *model.Config) (*model.Config, error)
- NotificationWillBePushed(pushNotification *model.PushNotification, userID string) (*model.PushNotification, string)
- PreferencesHaveChanged(c *Context, preferences []model.Preference)
- OnSharedChannelsSyncMsg, OnSharedChannelsPing, OnSharedChannelsAttachmentSyncMsg, OnSharedChannelsProfileImageSyncMsg
- GenerateSupportData(c *Context) ([]*model.FileData, error)
- OnSAMLLogin(c *Context, user *model.User, assertion *saml2.AssertionInfo) error
- EmailNotificationWillBeSent(emailNotification *model.EmailNotification) (*model.EmailNotificationContent, string)

For each hook:
1. Check if implemented using h.implemented[HookID] before calling gRPC
2. If not implemented, return default value (nil/empty/no-op)
3. Convert Go types to proto using existing converters from server/public/pluginapi/grpc/server/
4. Make gRPC call
5. Convert response back to Go types

Use the conversion helpers already implemented in Phase 4:
@server/public/pluginapi/grpc/server/convert_*.go

For SAML assertion (OnSAMLLogin), pass the assertion as JSON bytes since saml2.AssertionInfo is complex.
  </action>
  <verify>go build ./server/public/plugin/... compiles without errors</verify>
  <done>All Hooks interface methods implemented</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./server/public/plugin/...` succeeds without errors
- [ ] hooksGRPCClient implements Hooks interface (compiler verifies)
- [ ] ServeHTTP uses bidirectional streaming pattern from Phase 8
- [ ] All hooks check implemented array before making gRPC calls
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- hooksGRPCClient can be used as drop-in replacement for hooksRPCClient
</success_criteria>

<output>
After completion, create `.planning/phases/11-server-integration/11-01-SUMMARY.md`
</output>
