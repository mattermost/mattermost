---
phase: 11-server-integration
plan: 03
type: execute
depends_on: ["11-02"]
files_modified: [server/public/plugin/python_integration_test.go]
---

<objective>
Create end-to-end integration test demonstrating a complete Python plugin lifecycle: upload, activation, hook invocation, and HTTP request handling.

Purpose: Validate the full Python plugin system works as designed across all phases.
Output: Comprehensive integration test proving Python plugins work identically to Go plugins.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-server-integration/11-RESEARCH.md
@.planning/phases/11-server-integration/11-01-SUMMARY.md
@.planning/phases/11-server-integration/11-02-SUMMARY.md

# Key reference files:
@server/public/plugin/supervisor.go - Supervisor with Python support
@server/public/plugin/hooks_grpc_client.go - gRPC adapter
@server/channels/app/plugin_requests.go - HTTP routing to plugins
@examples/python-plugin/ - Example Python plugin from Phase 10

**Tech stack available:** go test, httptest, bufconn
**Established patterns:** Phase 10 integration tests
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Python plugin integration test</name>
  <files>server/public/plugin/python_integration_test.go</files>
  <action>
Create a comprehensive integration test that exercises the full Python plugin lifecycle.

Test name: TestPythonPluginIntegration

Test structure:
```go
func TestPythonPluginIntegration(t *testing.T) {
    // Skip if Python not available
    if _, err := exec.LookPath("python3"); err != nil {
        t.Skip("python3 not available")
    }

    // Setup test environment with temporary plugin directory
    // ...

    t.Run("plugin starts and reports implemented hooks", func(t *testing.T) {
        // Verify supervisor.Implements() returns true for expected hooks
    })

    t.Run("OnActivate is called successfully", func(t *testing.T) {
        // Verify OnActivate hook is invoked
    })

    t.Run("MessageHasBeenPosted hook receives events", func(t *testing.T) {
        // Create a post, verify hook is invoked
    })

    t.Run("ServeHTTP handles requests", func(t *testing.T) {
        // Make HTTP request to plugin endpoint
        // Verify response
    })

    t.Run("OnDeactivate is called on shutdown", func(t *testing.T) {
        // Shutdown plugin, verify OnDeactivate called
    })
}
```

For the test Python plugin, use a minimal inline script or reference the example plugin:
@examples/python-plugin/

The test should use the real Python SDK from:
@python-sdk/

Test requirements:
1. Python 3.9+ with grpcio installed
2. The python-sdk package installed (or PYTHONPATH set)
3. Temporary directory for plugin files

If full Python integration is too complex for unit tests, create a simpler approach:
1. Use a mock gRPC server that simulates the Python plugin
2. Use bufconn to create in-memory gRPC connections
3. Verify the Go-side integration without requiring actual Python

Document any skip conditions clearly (Python not available, dependencies not installed, etc.).
  </action>
  <verify>go test ./server/public/plugin/... -run TestPythonPluginIntegration passes (or skips gracefully)</verify>
  <done>Integration test demonstrates full Python plugin lifecycle</done>
</task>

<task type="auto">
  <name>Task 2: Add ServeHTTP integration test</name>
  <files>server/public/plugin/python_integration_test.go</files>
  <action>
Add a specific test for ServeHTTP streaming functionality.

Test name: TestPythonPluginServeHTTP

Test cases:
1. Simple GET request - verify response status and body
2. POST request with body - verify request body received by plugin
3. Large response body - verify streaming works (>64KB response)
4. Request headers - verify headers passed to plugin
5. Response headers - verify plugin can set response headers

Use httptest.ResponseRecorder for capturing responses.

For the streaming test:
- Create a response larger than 64KB (the chunk size)
- Verify the entire response is received correctly
- This validates the bidirectional streaming implementation

If using mock approach:
- Mock PluginHooksClient.ServeHTTP to return test responses
- Use a streaming mock that sends multiple chunks

Key validation points:
- Status codes are correctly propagated
- Headers are correctly propagated both directions
- Body content is not corrupted through streaming
- Large bodies work (tests chunking)
  </action>
  <verify>go test ./server/public/plugin/... -run TestPythonPluginServeHTTP passes</verify>
  <done>ServeHTTP streaming verified with multiple test cases</done>
</task>

<task type="auto">
  <name>Task 3: Update documentation with integration notes</name>
  <files>docs/python-plugins.md</files>
  <action>
Update the Python plugin documentation from Phase 10 to reflect the completed server integration.

Add a section: "## Server Integration"

Content to add:
1. Explain that Python plugins are now fully integrated with the server
2. Hook dispatch works identically to Go plugins
3. HTTP routing via /plugins/{plugin_id}/* works
4. Any known limitations or differences from Go plugins

Update the "Getting Started" section if needed to reflect any changes from the integration work.

Add a "Troubleshooting" section covering common issues:
- Plugin fails to start: check Python version, grpcio installation
- Hooks not called: verify Implemented() returns correct hook names
- HTTP requests fail: check ServeHTTP implementation, verify plugin ID routing
- API calls fail: ensure MATTERMOST_API_TARGET is set correctly

Keep documentation concise and practical.
  </action>
  <verify>docs/python-plugins.md exists and has Server Integration section</verify>
  <done>Documentation updated with server integration information</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./server/public/plugin/...` passes
- [ ] Integration tests cover plugin lifecycle, hooks, and HTTP
- [ ] Documentation updated with server integration details
- [ ] No regressions in existing tests
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Phase 11 complete - Python plugins fully integrated with Mattermost server
</success_criteria>

<output>
After completion, create `.planning/phases/11-server-integration/11-03-SUMMARY.md`:

Include:
- Summary of integration test coverage
- Any known limitations discovered
- Confirmation that Python plugins work end-to-end

Final note: "Phase 11 complete. Python plugin support is fully integrated with the Mattermost server."
</output>
