---
phase: 05-python-supervisor
plan: 02
type: execute
depends_on: ["05-01"]
files_modified:
  - server/public/plugin/supervisor.go
  - server/public/plugin/environment.go
  - server/public/plugin/python_supervisor_test.go
---

<objective>
Start Python plugin subprocesses under the existing Mattermost plugin environment using go-plugin’s gRPC transport + health checks, without implementing hook dispatch yet (Phase 7).

Purpose: Prove the Go-side supervisor can spawn and keep a Python plugin process alive and health-checkable.
Output: Supervisor logic that opts into `ProtocolGRPC` for Python plugins, environment activation/deactivation behavior that doesn’t require Hooks yet, and an integration test that validates gRPC health via a fake “python” interpreter.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-python-supervisor/05-RESEARCH.md

@server/public/plugin/supervisor.go
@server/public/plugin/environment.go
@server/public/plugin/health_check.go

@/Users/nickmisasi/go/pkg/mod/github.com/hashicorp/go-plugin@v1.7.0/docs/guide-plugin-write-non-go.md
@/Users/nickmisasi/go/pkg/mod/github.com/hashicorp/go-plugin@v1.7.0/grpc_client.go
@/Users/nickmisasi/go/pkg/mod/github.com/hashicorp/go-plugin@v1.7.0/client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Python plugin startup path in newSupervisor (gRPC protocol, no Dispense yet)</name>
  <files>server/public/plugin/supervisor.go</files>
  <action>
Extend `newSupervisor` to handle Python plugins as a separate protocol path while keeping Go plugins unchanged:

- Detect Python via the helpers from Plan 05-01 (`isPythonPlugin`).
- For Python plugins:
  - Set `clientConfig.AllowedProtocols = []plugin.Protocol{plugin.ProtocolGRPC}` (critical: go-plugin defaults to netrpc-only when nil).
  - Ensure `clientConfig.Plugins` is non-nil (an empty map is fine). This keeps `PLUGIN_PROTOCOL_VERSIONS` populated for the handshake.
  - Consider increasing `StartTimeout` for Python (e.g. 10s) to account for interpreter + import time.
  - Start the go-plugin client as usual (`plugin.NewClient(clientConfig)` then `sup.client.Client()`), but DO NOT call `Dispense("hooks")` yet. We are not implementing hook dispatch until Phase 7, and we should not block Phase 5 on generating a full Hooks gRPC bridge.
  - Leave `sup.hooks` unset (nil) and ensure `sup.Implements(hookId)` remains false for all hooks.

Why this is acceptable in Phase 5:
- Phase 5 is process supervision. Hook delivery + OnActivate/OnDeactivate semantics land in Phase 7 (Python Hook System).
- go-plugin gRPC health (`Ping`) works as long as the plugin serves gRPC health for service name `"plugin"` (see go-plugin non-go guide).

Avoid:
- Hand-rolling the handshake parsing: go-plugin already reads the single-line handshake and establishes the connection.
- Calling Hooks methods in this plan (would require implementing the entire Hooks interface over gRPC).
  </action>
  <verify>cd server/public && go test ./plugin -run TestSupervisor -count=1</verify>
  <done>
Supervisor can start a Python plugin client connection using ProtocolGRPC without attempting to dispense hooks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make Environment activation/deactivation tolerate “no hooks yet” for Python plugins</name>
  <files>server/public/plugin/environment.go</files>
  <action>
Adjust environment lifecycle so Phase 5 can activate/deactivate Python plugins even before hook dispatch exists:

- In `startPluginServer`:
  - After `newSupervisor(...)`, if `sup.Hooks()` is nil (Python path in Phase 5), treat activation as successful:
    - Set supervisor via `env.setPluginSupervisor(...)`
    - Return nil WITHOUT calling `sup.Hooks().OnActivate()`
  - Keep existing behavior for Go plugins (call `OnActivate`).

- In `Deactivate` and `Shutdown`:
  - Guard the `OnDeactivate()` call: only call if `rp.supervisor.Hooks() != nil`.
  - Always call `rp.supervisor.Shutdown()` to terminate the process.

Add a log line (info/warn) when activating a Python plugin with hooks disabled, so operators understand why the plugin didn’t run OnActivate yet.
  </action>
  <verify>cd server/public && go test ./plugin -count=1</verify>
  <done>
Environment can Activate/Deactivate a Python plugin without panicking, and existing Go plugin behavior remains unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration test: spawn a fake “python” plugin that only serves gRPC health + handshake</name>
  <files>server/public/plugin/python_supervisor_test.go</files>
  <action>
Add an integration test that validates end-to-end spawning + health check without needing a real Python runtime:

- Build a fake “python interpreter” binary at runtime in the test using `server/public/plugin/utils.CompileGo`.
  - The binary should ignore its argv[1] (script path), start a gRPC server on `127.0.0.1:0`, register gRPC health, set health status for service `"plugin"` to SERVING, then print the handshake line:
    - `1|1|tcp|127.0.0.1:<port>|grpc`
    - Flush stdout immediately.
  - Then block forever (or until SIGTERM) so the supervisor can ping it.

- Create a temp plugin bundle with:
  - `plugin.json` where `server.executable` is `plugin.py` (Python detection)
  - A dummy `plugin.py` file (content irrelevant)
  - The fake interpreter placed at the venv path expected by `findPythonInterpreter` (so no dependency on system python).

- Use the real environment activation path:
  - `env := NewEnvironment(...)` or construct `Environment{pluginDir: ..., logger: ...}` as tests do elsewhere.
  - Call `env.Activate(pluginID)` and assert `activated == true`.
  - Call `env.PerformHealthCheck(pluginID)` and assert it succeeds.

This test proves Phase 5’s core: process spawn + go-plugin gRPC Ping works with the documented non-Go handshake + health requirements.
  </action>
  <verify>cd server/public && go test ./plugin -run TestPythonSupervisor_HealthCheckSuccess -count=1</verify>
  <done>
Test passes reliably without external dependencies and demonstrates a healthy Python-plugin-shaped process can be supervised and pinged.
  </done>
</task>

</tasks>

<verification>
Before declaring this plan complete:
- [ ] `cd server/public && go test ./plugin -count=1` passes
- [ ] Go plugin activation tests remain passing (no regression to existing net/rpc plugins)
</verification>

<success_criteria>
- Python plugin startup uses go-plugin gRPC protocol (`AllowedProtocols` includes `ProtocolGRPC`)
- Environment activation/deactivation no longer assumes Hooks exist (Python path is supported without hook dispatch)
- Integration test demonstrates handshake + gRPC health Ping success for a non-Go-style plugin process
</success_criteria>

<output>
After completion, create `.planning/phases/05-python-supervisor/05-02-SUMMARY.md` using:
@/Users/nickmisasi/.claude/get-shit-done/templates/summary.md
</output>


