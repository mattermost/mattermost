---
phase: 02-api-protobuf-definitions
plan: 01
type: execute
depends_on: ["01-02", "01-03"]
files_modified:
  - server/public/pluginapi/grpc/cmd/apiverify/main.go
  - server/public/pluginapi/grpc/proto/api.proto
  - server/public/pluginapi/grpc/proto/api_user_team.proto
  - server/public/pluginapi/grpc/proto/api_channel_post.proto
  - server/public/pluginapi/grpc/proto/api_kv_config.proto
  - server/public/pluginapi/grpc/proto/api_file_bot.proto
  - server/public/pluginapi/grpc/proto/api_remaining.proto
  - server/public/pluginapi/grpc/proto/bootstrap.proto
  - server/public/pluginapi/grpc/proto/plugin.proto
---

<objective>
Define protobuf request/response messages for all User + Team Plugin API methods (Phase 2 plan 1), and establish an API surface “skeleton” + verifier so later plans can fill in other method groups without drifting from `server/public/plugin/api.go`.

Purpose: Make the gRPC Plugin API mechanically complete and verifiable, and deliver full protobuf definitions for User/Team methods.
Output: `api.proto` PluginAPI service + per-group proto files with placeholder messages, plus fully-specified User/Team request/response messages.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-protocol-foundation/01-RESEARCH.md

# Source of truth: Plugin API surface
@server/public/plugin/api.go

# Existing proto scaffolding + generation tooling
@server/public/pluginapi/grpc/proto/bootstrap.proto
@server/public/Makefile

# Error shape source of truth (for AppError message)
@server/public/model/app_error.go

# Primary model types for this plan’s methods
@server/public/model/user.go
@server/public/model/team.go
@server/public/model/session.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create/refresh PluginAPI proto skeleton + parity verifier</name>
  <files>server/public/pluginapi/grpc/proto/api.proto, server/public/pluginapi/grpc/proto/api_user_team.proto, server/public/pluginapi/grpc/proto/api_channel_post.proto, server/public/pluginapi/grpc/proto/api_kv_config.proto, server/public/pluginapi/grpc/proto/api_file_bot.proto, server/public/pluginapi/grpc/proto/api_remaining.proto, server/public/pluginapi/grpc/proto/bootstrap.proto, server/public/pluginapi/grpc/cmd/apiverify/main.go</files>
  <action>
Create a “complete by construction” proto skeleton driven by `server/public/plugin/api.go`:

- Add `server/public/pluginapi/grpc/proto/api.proto` defining `service PluginAPI` with **one rpc per method** in `type API interface {}`.
  - Each RPC must be named exactly like the Go method (e.g., `rpc GetUser(GetUserRequest) returns (GetUserResponse);`).
  - `api.proto` should only contain the service + imports (no message bodies beyond what’s necessary).

- Split request/response message definitions into per-group files:
  - `api_user_team.proto`
  - `api_channel_post.proto`
  - `api_kv_config.proto`
  - `api_file_bot.proto`
  - `api_remaining.proto`

- In each per-group file, create placeholder messages for methods owned by that group:
  - For every method `X`, create `message XRequest { /* TODO */ }` and `message XResponse { /* TODO */ }`.
  - **Response convention (applies to ALL methods, all plans):**
    - Field 1 is always `AppError error = 1;` (message defined in a shared proto; see below)
    - Success payload fields (if any) start at field number 2
    - Never reuse field numbers; reserve removed fields.

- Group assignment rule (must assign every method to exactly ONE file):
  1) `api_file_bot.proto`: tags include `File` OR `Upload` OR `Bot`, plus explicit overrides: `InstallPlugin`, `UploadData`, `EnsureBotUser`
  2) `api_kv_config.proto`: tags include `KeyValueStore` OR `Configuration` OR `Plugin` OR `Logging`, plus explicit overrides: `KVSetWithOptions`, `PublishWebSocketEvent`
  3) `api_channel_post.proto`: tags include `Channel` OR `Post` OR `ChannelSidebar` OR `Emoji`
  4) `api_remaining.proto`: tags include `Preference` OR `OAuth` OR `Group` OR `SharedChannels` OR `PropertyField` OR `PropertyValue` OR `PropertyGroup` OR `Audit` OR `Server` OR `Command` OR `SlashCommand`, plus explicit overrides: `PluginHTTP`, `GetCloudLimits`, `OpenInteractiveDialog`, `PublishPluginClusterEvent`, `RegisterCollectionAndTopic`, `RequestTrialLicense`, `RolesGrantPermission`, `SendMail`, `SendPushNotification`
  5) `api_user_team.proto`: tags include `User` OR `Team`
  6) Otherwise: `api_remaining.proto`

- Ensure all new proto files use the same versioned package + go_package as `bootstrap.proto`:
  - `package mattermost.pluginapi.v1;`
  - `option go_package = "github.com/mattermost/mattermost/server/public/pluginapi/grpc/generated/go/pluginapiv1";`

- Extend `bootstrap.proto` only as needed so the skeleton compiles (prefer to keep it minimal):
  - Keep `message Empty {}` (already present).
  - Add `message AppError { ... }` if it does not already exist (mirror `model.AppError` enough for parity: at minimum include `id`, `message`, `detailed_error`, `status_code`, `where`, `request_id`).
  - If you need dynamic JSON-ish payloads later, plan to use `google.protobuf.Struct` in Phase 2 Plan 03; do not introduce ad-hoc `map<string, bytes>` unless required.

- Add `server/public/pluginapi/grpc/cmd/apiverify/main.go`:
  - Parse `server/public/plugin/api.go` AST to list API interface method names.
  - Parse `api.proto` text to list `rpc {Name}` entries.
  - Fail with a clear diff if any methods are missing or extra.
  - This tool is the guardrail that prevents Phase 2 drift as the API evolves.

Avoid:
- Manually maintaining a 200+ method service definition by hand without a verifier.
- Using gRPC status errors to represent `*model.AppError` (we need parity across languages; app errors must be in the response payload as `AppError error = 1`).
  </action>
  <verify>make -C server/public proto-gen (protoc installed) succeeds AND go run ./server/public/pluginapi/grpc/cmd/apiverify reports no missing/extra RPCs</verify>
  <done>`api.proto` contains RPCs for every `plugin.API` method, generation succeeds, and apiverify enforces parity.</done>
</task>

<task type="auto">
  <name>Task 2: Fill in User + Team request/response message fields</name>
  <files>server/public/pluginapi/grpc/proto/api_user_team.proto, server/public/pluginapi/grpc/proto/bootstrap.proto, server/public/pluginapi/grpc/proto/plugin.proto</files>
  <action>
Replace placeholders in `api_user_team.proto` with real request/response fields for every method assigned to this file by the rule in Task 1.

Message design rules (keep consistent across the whole Phase 2):
- **Field naming**: snake_case (e.g., `team_id`, `per_page`).
- **Scalar types**: `string` for IDs, `int32` for Go `int`/`int32`, `int64` for timestamps/Go `int64`, `bool` for bool, `bytes` for `[]byte`.
- **Slices**: `repeated`.
- **Optionality**: if the Go type is a pointer-to-scalar, use `optional` (proto3) or wrapper types consistently (match the Phase 1 “common patterns” decision).
- **Errors**: every `XResponse` keeps `AppError error = 1;` and does NOT embed “error strings” elsewhere.

Supporting types:
- Ensure `plugin.proto` exists (created in Phase 1). If a required type for this plan is missing, add it there rather than inventing per-plan duplicates.
- User/Team plans will at least need messages matching these `model.*` types (based on signatures): `User`, `Team`, `TeamMember`, `TeamMemberWithError`, `TeamStats`, `TeamUnread`, `Session`, `UserAccessToken`, `UserAuth`, `UserGetOptions`, `UserSearch`, `ViewUsersRestrictions`.

Goal is correctness + parity first:
- Match Go signatures in `plugin/api.go`.
- Use `server/public/model/*.go` structs as the source of truth for fields when defining shared types.
- Reserve field numbers for removed fields; never reuse.
  </action>
  <verify>make -C server/public proto-gen succeeds AND grep shows no remaining “TODO” placeholders for methods owned by `api_user_team.proto`</verify>
  <done>All User/Team methods have fully specified request/response messages, required shared types exist in `plugin.proto`, and Go codegen succeeds.</done>
</task>

</tasks>

<verification>
Before declaring this plan complete:
- [ ] `go run ./server/public/pluginapi/grpc/cmd/apiverify` reports no missing/extra RPCs vs `server/public/plugin/api.go`
- [ ] `make -C server/public proto-gen` succeeds (requires `protoc` installed)
- [ ] No placeholder TODOs remain for methods assigned to `api_user_team.proto`
</verification>

<success_criteria>

- `api.proto` is mechanically complete for all Plugin API methods (RPC parity enforced)
- User/Team method protos are fully defined (no placeholders)
- Proto generation produces Go code in `server/public/pluginapi/grpc/generated/go/pluginapiv1/`
  </success_criteria>

<output>
After completion, create `.planning/phases/02-api-protobuf-definitions/02-01-SUMMARY.md`:

# Phase 2 Plan 01: User and Team API Protos Summary

**Established complete PluginAPI proto skeleton + implemented User/Team method messages.**

## Accomplishments

## Files Created/Modified

## Decisions Made

## Issues Encountered

## Next Step

Ready for `02-02-PLAN.md`
</output>


