// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make pluginapi"
// DO NOT EDIT

package plugin

import (
	"fmt"
	"log"

	"github.com/mattermost/mattermost-server/v5/mlog"
	"github.com/mattermost/mattermost-server/v5/model"
)

func init() {
	hookNameToId["OnDeactivate"] = OnDeactivateID
}

type ZOnDeactivateArgs struct {
}

type ZOnDeactivateReturns struct {
	A error
}

func (g *hooksRPCClient) OnDeactivate() error {
	_args := &ZOnDeactivateArgs{}
	_returns := &ZOnDeactivateReturns{}
	if g.implemented[OnDeactivateID] {
		if err := g.client.Call("Plugin.OnDeactivate", _args, _returns); err != nil {
			g.log.Error("RPC call OnDeactivate to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A
}

func (s *hooksRPCServer) OnDeactivate(args *ZOnDeactivateArgs, returns *ZOnDeactivateReturns) error {
	if hook, ok := s.impl.(interface {
		OnDeactivate() error
	}); ok {
		returns.A = hook.OnDeactivate()
		returns.A = encodableError(returns.A)
	} else {
		return encodableError(fmt.Errorf("Hook OnDeactivate called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["OnConfigurationChange"] = OnConfigurationChangeID
}

type ZOnConfigurationChangeArgs struct {
}

type ZOnConfigurationChangeReturns struct {
	A error
}

func (g *hooksRPCClient) OnConfigurationChange() error {
	_args := &ZOnConfigurationChangeArgs{}
	_returns := &ZOnConfigurationChangeReturns{}
	if g.implemented[OnConfigurationChangeID] {
		if err := g.client.Call("Plugin.OnConfigurationChange", _args, _returns); err != nil {
			g.log.Error("RPC call OnConfigurationChange to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A
}

func (s *hooksRPCServer) OnConfigurationChange(args *ZOnConfigurationChangeArgs, returns *ZOnConfigurationChangeReturns) error {
	if hook, ok := s.impl.(interface {
		OnConfigurationChange() error
	}); ok {
		returns.A = hook.OnConfigurationChange()
		returns.A = encodableError(returns.A)
	} else {
		return encodableError(fmt.Errorf("Hook OnConfigurationChange called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["ExecuteCommand"] = ExecuteCommandID
}

type ZExecuteCommandArgs struct {
	A *Context
	B *model.CommandArgs
}

type ZExecuteCommandReturns struct {
	A *model.CommandResponse
	B *model.AppError
}

func (g *hooksRPCClient) ExecuteCommand(c *Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) {
	_args := &ZExecuteCommandArgs{c, args}
	_returns := &ZExecuteCommandReturns{}
	if g.implemented[ExecuteCommandID] {
		if err := g.client.Call("Plugin.ExecuteCommand", _args, _returns); err != nil {
			g.log.Error("RPC call ExecuteCommand to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A, _returns.B
}

func (s *hooksRPCServer) ExecuteCommand(args *ZExecuteCommandArgs, returns *ZExecuteCommandReturns) error {
	if hook, ok := s.impl.(interface {
		ExecuteCommand(c *Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.ExecuteCommand(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook ExecuteCommand called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasBeenCreated"] = UserHasBeenCreatedID
}

type ZUserHasBeenCreatedArgs struct {
	A *Context
	B *model.User
}

type ZUserHasBeenCreatedReturns struct {
}

func (g *hooksRPCClient) UserHasBeenCreated(c *Context, user *model.User) {
	_args := &ZUserHasBeenCreatedArgs{c, user}
	_returns := &ZUserHasBeenCreatedReturns{}
	if g.implemented[UserHasBeenCreatedID] {
		if err := g.client.Call("Plugin.UserHasBeenCreated", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasBeenCreated to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasBeenCreated(args *ZUserHasBeenCreatedArgs, returns *ZUserHasBeenCreatedReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasBeenCreated(c *Context, user *model.User)
	}); ok {
		hook.UserHasBeenCreated(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook UserHasBeenCreated called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserWillLogIn"] = UserWillLogInID
}

type ZUserWillLogInArgs struct {
	A *Context
	B *model.User
}

type ZUserWillLogInReturns struct {
	A string
}

func (g *hooksRPCClient) UserWillLogIn(c *Context, user *model.User) string {
	_args := &ZUserWillLogInArgs{c, user}
	_returns := &ZUserWillLogInReturns{}
	if g.implemented[UserWillLogInID] {
		if err := g.client.Call("Plugin.UserWillLogIn", _args, _returns); err != nil {
			g.log.Error("RPC call UserWillLogIn to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A
}

func (s *hooksRPCServer) UserWillLogIn(args *ZUserWillLogInArgs, returns *ZUserWillLogInReturns) error {
	if hook, ok := s.impl.(interface {
		UserWillLogIn(c *Context, user *model.User) string
	}); ok {
		returns.A = hook.UserWillLogIn(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook UserWillLogIn called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasLoggedIn"] = UserHasLoggedInID
}

type ZUserHasLoggedInArgs struct {
	A *Context
	B *model.User
}

type ZUserHasLoggedInReturns struct {
}

func (g *hooksRPCClient) UserHasLoggedIn(c *Context, user *model.User) {
	_args := &ZUserHasLoggedInArgs{c, user}
	_returns := &ZUserHasLoggedInReturns{}
	if g.implemented[UserHasLoggedInID] {
		if err := g.client.Call("Plugin.UserHasLoggedIn", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasLoggedIn to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasLoggedIn(args *ZUserHasLoggedInArgs, returns *ZUserHasLoggedInReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasLoggedIn(c *Context, user *model.User)
	}); ok {
		hook.UserHasLoggedIn(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook UserHasLoggedIn called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["MessageHasBeenPosted"] = MessageHasBeenPostedID
}

type ZMessageHasBeenPostedArgs struct {
	A *Context
	B *model.Post
}

type ZMessageHasBeenPostedReturns struct {
}

func (g *hooksRPCClient) MessageHasBeenPosted(c *Context, post *model.Post) {
	_args := &ZMessageHasBeenPostedArgs{c, post}
	_returns := &ZMessageHasBeenPostedReturns{}
	if g.implemented[MessageHasBeenPostedID] {
		if err := g.client.Call("Plugin.MessageHasBeenPosted", _args, _returns); err != nil {
			g.log.Error("RPC call MessageHasBeenPosted to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) MessageHasBeenPosted(args *ZMessageHasBeenPostedArgs, returns *ZMessageHasBeenPostedReturns) error {
	if hook, ok := s.impl.(interface {
		MessageHasBeenPosted(c *Context, post *model.Post)
	}); ok {
		hook.MessageHasBeenPosted(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook MessageHasBeenPosted called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["MessageHasBeenUpdated"] = MessageHasBeenUpdatedID
}

type ZMessageHasBeenUpdatedArgs struct {
	A *Context
	B *model.Post
	C *model.Post
}

type ZMessageHasBeenUpdatedReturns struct {
}

func (g *hooksRPCClient) MessageHasBeenUpdated(c *Context, newPost, oldPost *model.Post) {
	_args := &ZMessageHasBeenUpdatedArgs{c, newPost, oldPost}
	_returns := &ZMessageHasBeenUpdatedReturns{}
	if g.implemented[MessageHasBeenUpdatedID] {
		if err := g.client.Call("Plugin.MessageHasBeenUpdated", _args, _returns); err != nil {
			g.log.Error("RPC call MessageHasBeenUpdated to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) MessageHasBeenUpdated(args *ZMessageHasBeenUpdatedArgs, returns *ZMessageHasBeenUpdatedReturns) error {
	if hook, ok := s.impl.(interface {
		MessageHasBeenUpdated(c *Context, newPost, oldPost *model.Post)
	}); ok {
		hook.MessageHasBeenUpdated(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("Hook MessageHasBeenUpdated called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["ChannelHasBeenCreated"] = ChannelHasBeenCreatedID
}

type ZChannelHasBeenCreatedArgs struct {
	A *Context
	B *model.Channel
}

type ZChannelHasBeenCreatedReturns struct {
}

func (g *hooksRPCClient) ChannelHasBeenCreated(c *Context, channel *model.Channel) {
	_args := &ZChannelHasBeenCreatedArgs{c, channel}
	_returns := &ZChannelHasBeenCreatedReturns{}
	if g.implemented[ChannelHasBeenCreatedID] {
		if err := g.client.Call("Plugin.ChannelHasBeenCreated", _args, _returns); err != nil {
			g.log.Error("RPC call ChannelHasBeenCreated to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) ChannelHasBeenCreated(args *ZChannelHasBeenCreatedArgs, returns *ZChannelHasBeenCreatedReturns) error {
	if hook, ok := s.impl.(interface {
		ChannelHasBeenCreated(c *Context, channel *model.Channel)
	}); ok {
		hook.ChannelHasBeenCreated(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook ChannelHasBeenCreated called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasJoinedChannel"] = UserHasJoinedChannelID
}

type ZUserHasJoinedChannelArgs struct {
	A *Context
	B *model.ChannelMember
	C *model.User
}

type ZUserHasJoinedChannelReturns struct {
}

func (g *hooksRPCClient) UserHasJoinedChannel(c *Context, channelMember *model.ChannelMember, actor *model.User) {
	_args := &ZUserHasJoinedChannelArgs{c, channelMember, actor}
	_returns := &ZUserHasJoinedChannelReturns{}
	if g.implemented[UserHasJoinedChannelID] {
		if err := g.client.Call("Plugin.UserHasJoinedChannel", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasJoinedChannel to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasJoinedChannel(args *ZUserHasJoinedChannelArgs, returns *ZUserHasJoinedChannelReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasJoinedChannel(c *Context, channelMember *model.ChannelMember, actor *model.User)
	}); ok {
		hook.UserHasJoinedChannel(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("Hook UserHasJoinedChannel called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasLeftChannel"] = UserHasLeftChannelID
}

type ZUserHasLeftChannelArgs struct {
	A *Context
	B *model.ChannelMember
	C *model.User
}

type ZUserHasLeftChannelReturns struct {
}

func (g *hooksRPCClient) UserHasLeftChannel(c *Context, channelMember *model.ChannelMember, actor *model.User) {
	_args := &ZUserHasLeftChannelArgs{c, channelMember, actor}
	_returns := &ZUserHasLeftChannelReturns{}
	if g.implemented[UserHasLeftChannelID] {
		if err := g.client.Call("Plugin.UserHasLeftChannel", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasLeftChannel to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasLeftChannel(args *ZUserHasLeftChannelArgs, returns *ZUserHasLeftChannelReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasLeftChannel(c *Context, channelMember *model.ChannelMember, actor *model.User)
	}); ok {
		hook.UserHasLeftChannel(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("Hook UserHasLeftChannel called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasJoinedTeam"] = UserHasJoinedTeamID
}

type ZUserHasJoinedTeamArgs struct {
	A *Context
	B *model.TeamMember
	C *model.User
}

type ZUserHasJoinedTeamReturns struct {
}

func (g *hooksRPCClient) UserHasJoinedTeam(c *Context, teamMember *model.TeamMember, actor *model.User) {
	_args := &ZUserHasJoinedTeamArgs{c, teamMember, actor}
	_returns := &ZUserHasJoinedTeamReturns{}
	if g.implemented[UserHasJoinedTeamID] {
		if err := g.client.Call("Plugin.UserHasJoinedTeam", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasJoinedTeam to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasJoinedTeam(args *ZUserHasJoinedTeamArgs, returns *ZUserHasJoinedTeamReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasJoinedTeam(c *Context, teamMember *model.TeamMember, actor *model.User)
	}); ok {
		hook.UserHasJoinedTeam(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("Hook UserHasJoinedTeam called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasLeftTeam"] = UserHasLeftTeamID
}

type ZUserHasLeftTeamArgs struct {
	A *Context
	B *model.TeamMember
	C *model.User
}

type ZUserHasLeftTeamReturns struct {
}

func (g *hooksRPCClient) UserHasLeftTeam(c *Context, teamMember *model.TeamMember, actor *model.User) {
	_args := &ZUserHasLeftTeamArgs{c, teamMember, actor}
	_returns := &ZUserHasLeftTeamReturns{}
	if g.implemented[UserHasLeftTeamID] {
		if err := g.client.Call("Plugin.UserHasLeftTeam", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasLeftTeam to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasLeftTeam(args *ZUserHasLeftTeamArgs, returns *ZUserHasLeftTeamReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasLeftTeam(c *Context, teamMember *model.TeamMember, actor *model.User)
	}); ok {
		hook.UserHasLeftTeam(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("Hook UserHasLeftTeam called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["ReactionHasBeenAdded"] = ReactionHasBeenAddedID
}

type ZReactionHasBeenAddedArgs struct {
	A *Context
	B *model.Reaction
}

type ZReactionHasBeenAddedReturns struct {
}

func (g *hooksRPCClient) ReactionHasBeenAdded(c *Context, reaction *model.Reaction) {
	_args := &ZReactionHasBeenAddedArgs{c, reaction}
	_returns := &ZReactionHasBeenAddedReturns{}
	if g.implemented[ReactionHasBeenAddedID] {
		if err := g.client.Call("Plugin.ReactionHasBeenAdded", _args, _returns); err != nil {
			g.log.Error("RPC call ReactionHasBeenAdded to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) ReactionHasBeenAdded(args *ZReactionHasBeenAddedArgs, returns *ZReactionHasBeenAddedReturns) error {
	if hook, ok := s.impl.(interface {
		ReactionHasBeenAdded(c *Context, reaction *model.Reaction)
	}); ok {
		hook.ReactionHasBeenAdded(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook ReactionHasBeenAdded called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["ReactionHasBeenRemoved"] = ReactionHasBeenRemovedID
}

type ZReactionHasBeenRemovedArgs struct {
	A *Context
	B *model.Reaction
}

type ZReactionHasBeenRemovedReturns struct {
}

func (g *hooksRPCClient) ReactionHasBeenRemoved(c *Context, reaction *model.Reaction) {
	_args := &ZReactionHasBeenRemovedArgs{c, reaction}
	_returns := &ZReactionHasBeenRemovedReturns{}
	if g.implemented[ReactionHasBeenRemovedID] {
		if err := g.client.Call("Plugin.ReactionHasBeenRemoved", _args, _returns); err != nil {
			g.log.Error("RPC call ReactionHasBeenRemoved to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) ReactionHasBeenRemoved(args *ZReactionHasBeenRemovedArgs, returns *ZReactionHasBeenRemovedReturns) error {
	if hook, ok := s.impl.(interface {
		ReactionHasBeenRemoved(c *Context, reaction *model.Reaction)
	}); ok {
		hook.ReactionHasBeenRemoved(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook ReactionHasBeenRemoved called but not implemented."))
	}
	return nil
}

type ZRegisterCommandArgs struct {
	A *model.Command
}

type ZRegisterCommandReturns struct {
	A error
}

func (g *apiRPCClient) RegisterCommand(command *model.Command) error {
	_args := &ZRegisterCommandArgs{command}
	_returns := &ZRegisterCommandReturns{}
	if err := g.client.Call("Plugin.RegisterCommand", _args, _returns); err != nil {
		log.Printf("RPC call to RegisterCommand API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) RegisterCommand(args *ZRegisterCommandArgs, returns *ZRegisterCommandReturns) error {
	if hook, ok := s.impl.(interface {
		RegisterCommand(command *model.Command) error
	}); ok {
		returns.A = hook.RegisterCommand(args.A)
		returns.A = encodableError(returns.A)
	} else {
		return encodableError(fmt.Errorf("API RegisterCommand called but not implemented."))
	}
	return nil
}

type ZUnregisterCommandArgs struct {
	A string
	B string
}

type ZUnregisterCommandReturns struct {
	A error
}

func (g *apiRPCClient) UnregisterCommand(teamId, trigger string) error {
	_args := &ZUnregisterCommandArgs{teamId, trigger}
	_returns := &ZUnregisterCommandReturns{}
	if err := g.client.Call("Plugin.UnregisterCommand", _args, _returns); err != nil {
		log.Printf("RPC call to UnregisterCommand API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) UnregisterCommand(args *ZUnregisterCommandArgs, returns *ZUnregisterCommandReturns) error {
	if hook, ok := s.impl.(interface {
		UnregisterCommand(teamId, trigger string) error
	}); ok {
		returns.A = hook.UnregisterCommand(args.A, args.B)
		returns.A = encodableError(returns.A)
	} else {
		return encodableError(fmt.Errorf("API UnregisterCommand called but not implemented."))
	}
	return nil
}

type ZExecuteSlashCommandArgs struct {
	A *model.CommandArgs
}

type ZExecuteSlashCommandReturns struct {
	A *model.CommandResponse
	B error
}

func (g *apiRPCClient) ExecuteSlashCommand(commandArgs *model.CommandArgs) (*model.CommandResponse, error) {
	_args := &ZExecuteSlashCommandArgs{commandArgs}
	_returns := &ZExecuteSlashCommandReturns{}
	if err := g.client.Call("Plugin.ExecuteSlashCommand", _args, _returns); err != nil {
		log.Printf("RPC call to ExecuteSlashCommand API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) ExecuteSlashCommand(args *ZExecuteSlashCommandArgs, returns *ZExecuteSlashCommandReturns) error {
	if hook, ok := s.impl.(interface {
		ExecuteSlashCommand(commandArgs *model.CommandArgs) (*model.CommandResponse, error)
	}); ok {
		returns.A, returns.B = hook.ExecuteSlashCommand(args.A)
		returns.B = encodableError(returns.B)
	} else {
		return encodableError(fmt.Errorf("API ExecuteSlashCommand called but not implemented."))
	}
	return nil
}

type ZGetSessionArgs struct {
	A string
}

type ZGetSessionReturns struct {
	A *model.Session
	B *model.AppError
}

func (g *apiRPCClient) GetSession(sessionId string) (*model.Session, *model.AppError) {
	_args := &ZGetSessionArgs{sessionId}
	_returns := &ZGetSessionReturns{}
	if err := g.client.Call("Plugin.GetSession", _args, _returns); err != nil {
		log.Printf("RPC call to GetSession API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetSession(args *ZGetSessionArgs, returns *ZGetSessionReturns) error {
	if hook, ok := s.impl.(interface {
		GetSession(sessionId string) (*model.Session, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetSession(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetSession called but not implemented."))
	}
	return nil
}

type ZGetConfigArgs struct {
}

type ZGetConfigReturns struct {
	A *model.Config
}

func (g *apiRPCClient) GetConfig() *model.Config {
	_args := &ZGetConfigArgs{}
	_returns := &ZGetConfigReturns{}
	if err := g.client.Call("Plugin.GetConfig", _args, _returns); err != nil {
		log.Printf("RPC call to GetConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetConfig(args *ZGetConfigArgs, returns *ZGetConfigReturns) error {
	if hook, ok := s.impl.(interface {
		GetConfig() *model.Config
	}); ok {
		returns.A = hook.GetConfig()
	} else {
		return encodableError(fmt.Errorf("API GetConfig called but not implemented."))
	}
	return nil
}

type ZGetUnsanitizedConfigArgs struct {
}

type ZGetUnsanitizedConfigReturns struct {
	A *model.Config
}

func (g *apiRPCClient) GetUnsanitizedConfig() *model.Config {
	_args := &ZGetUnsanitizedConfigArgs{}
	_returns := &ZGetUnsanitizedConfigReturns{}
	if err := g.client.Call("Plugin.GetUnsanitizedConfig", _args, _returns); err != nil {
		log.Printf("RPC call to GetUnsanitizedConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetUnsanitizedConfig(args *ZGetUnsanitizedConfigArgs, returns *ZGetUnsanitizedConfigReturns) error {
	if hook, ok := s.impl.(interface {
		GetUnsanitizedConfig() *model.Config
	}); ok {
		returns.A = hook.GetUnsanitizedConfig()
	} else {
		return encodableError(fmt.Errorf("API GetUnsanitizedConfig called but not implemented."))
	}
	return nil
}

type ZSaveConfigArgs struct {
	A *model.Config
}

type ZSaveConfigReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) SaveConfig(config *model.Config) *model.AppError {
	_args := &ZSaveConfigArgs{config}
	_returns := &ZSaveConfigReturns{}
	if err := g.client.Call("Plugin.SaveConfig", _args, _returns); err != nil {
		log.Printf("RPC call to SaveConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SaveConfig(args *ZSaveConfigArgs, returns *ZSaveConfigReturns) error {
	if hook, ok := s.impl.(interface {
		SaveConfig(config *model.Config) *model.AppError
	}); ok {
		returns.A = hook.SaveConfig(args.A)
	} else {
		return encodableError(fmt.Errorf("API SaveConfig called but not implemented."))
	}
	return nil
}

type ZGetPluginConfigArgs struct {
}

type ZGetPluginConfigReturns struct {
	A map[string]interface{}
}

func (g *apiRPCClient) GetPluginConfig() map[string]interface{} {
	_args := &ZGetPluginConfigArgs{}
	_returns := &ZGetPluginConfigReturns{}
	if err := g.client.Call("Plugin.GetPluginConfig", _args, _returns); err != nil {
		log.Printf("RPC call to GetPluginConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetPluginConfig(args *ZGetPluginConfigArgs, returns *ZGetPluginConfigReturns) error {
	if hook, ok := s.impl.(interface {
		GetPluginConfig() map[string]interface{}
	}); ok {
		returns.A = hook.GetPluginConfig()
	} else {
		return encodableError(fmt.Errorf("API GetPluginConfig called but not implemented."))
	}
	return nil
}

type ZSavePluginConfigArgs struct {
	A map[string]interface{}
}

type ZSavePluginConfigReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) SavePluginConfig(config map[string]interface{}) *model.AppError {
	_args := &ZSavePluginConfigArgs{config}
	_returns := &ZSavePluginConfigReturns{}
	if err := g.client.Call("Plugin.SavePluginConfig", _args, _returns); err != nil {
		log.Printf("RPC call to SavePluginConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SavePluginConfig(args *ZSavePluginConfigArgs, returns *ZSavePluginConfigReturns) error {
	if hook, ok := s.impl.(interface {
		SavePluginConfig(config map[string]interface{}) *model.AppError
	}); ok {
		returns.A = hook.SavePluginConfig(args.A)
	} else {
		return encodableError(fmt.Errorf("API SavePluginConfig called but not implemented."))
	}
	return nil
}

type ZGetBundlePathArgs struct {
}

type ZGetBundlePathReturns struct {
	A string
	B error
}

func (g *apiRPCClient) GetBundlePath() (string, error) {
	_args := &ZGetBundlePathArgs{}
	_returns := &ZGetBundlePathReturns{}
	if err := g.client.Call("Plugin.GetBundlePath", _args, _returns); err != nil {
		log.Printf("RPC call to GetBundlePath API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetBundlePath(args *ZGetBundlePathArgs, returns *ZGetBundlePathReturns) error {
	if hook, ok := s.impl.(interface {
		GetBundlePath() (string, error)
	}); ok {
		returns.A, returns.B = hook.GetBundlePath()
		returns.B = encodableError(returns.B)
	} else {
		return encodableError(fmt.Errorf("API GetBundlePath called but not implemented."))
	}
	return nil
}

type ZGetLicenseArgs struct {
}

type ZGetLicenseReturns struct {
	A *model.License
}

func (g *apiRPCClient) GetLicense() *model.License {
	_args := &ZGetLicenseArgs{}
	_returns := &ZGetLicenseReturns{}
	if err := g.client.Call("Plugin.GetLicense", _args, _returns); err != nil {
		log.Printf("RPC call to GetLicense API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetLicense(args *ZGetLicenseArgs, returns *ZGetLicenseReturns) error {
	if hook, ok := s.impl.(interface {
		GetLicense() *model.License
	}); ok {
		returns.A = hook.GetLicense()
	} else {
		return encodableError(fmt.Errorf("API GetLicense called but not implemented."))
	}
	return nil
}

type ZGetServerVersionArgs struct {
}

type ZGetServerVersionReturns struct {
	A string
}

func (g *apiRPCClient) GetServerVersion() string {
	_args := &ZGetServerVersionArgs{}
	_returns := &ZGetServerVersionReturns{}
	if err := g.client.Call("Plugin.GetServerVersion", _args, _returns); err != nil {
		log.Printf("RPC call to GetServerVersion API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetServerVersion(args *ZGetServerVersionArgs, returns *ZGetServerVersionReturns) error {
	if hook, ok := s.impl.(interface {
		GetServerVersion() string
	}); ok {
		returns.A = hook.GetServerVersion()
	} else {
		return encodableError(fmt.Errorf("API GetServerVersion called but not implemented."))
	}
	return nil
}

type ZGetSystemInstallDateArgs struct {
}

type ZGetSystemInstallDateReturns struct {
	A int64
	B *model.AppError
}

func (g *apiRPCClient) GetSystemInstallDate() (int64, *model.AppError) {
	_args := &ZGetSystemInstallDateArgs{}
	_returns := &ZGetSystemInstallDateReturns{}
	if err := g.client.Call("Plugin.GetSystemInstallDate", _args, _returns); err != nil {
		log.Printf("RPC call to GetSystemInstallDate API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetSystemInstallDate(args *ZGetSystemInstallDateArgs, returns *ZGetSystemInstallDateReturns) error {
	if hook, ok := s.impl.(interface {
		GetSystemInstallDate() (int64, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetSystemInstallDate()
	} else {
		return encodableError(fmt.Errorf("API GetSystemInstallDate called but not implemented."))
	}
	return nil
}

type ZGetDiagnosticIdArgs struct {
}

type ZGetDiagnosticIdReturns struct {
	A string
}

func (g *apiRPCClient) GetDiagnosticId() string {
	_args := &ZGetDiagnosticIdArgs{}
	_returns := &ZGetDiagnosticIdReturns{}
	if err := g.client.Call("Plugin.GetDiagnosticId", _args, _returns); err != nil {
		log.Printf("RPC call to GetDiagnosticId API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetDiagnosticId(args *ZGetDiagnosticIdArgs, returns *ZGetDiagnosticIdReturns) error {
	if hook, ok := s.impl.(interface {
		GetDiagnosticId() string
	}); ok {
		returns.A = hook.GetDiagnosticId()
	} else {
		return encodableError(fmt.Errorf("API GetDiagnosticId called but not implemented."))
	}
	return nil
}

type ZGetTelemetryIdArgs struct {
}

type ZGetTelemetryIdReturns struct {
	A string
}

func (g *apiRPCClient) GetTelemetryId() string {
	_args := &ZGetTelemetryIdArgs{}
	_returns := &ZGetTelemetryIdReturns{}
	if err := g.client.Call("Plugin.GetTelemetryId", _args, _returns); err != nil {
		log.Printf("RPC call to GetTelemetryId API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetTelemetryId(args *ZGetTelemetryIdArgs, returns *ZGetTelemetryIdReturns) error {
	if hook, ok := s.impl.(interface {
		GetTelemetryId() string
	}); ok {
		returns.A = hook.GetTelemetryId()
	} else {
		return encodableError(fmt.Errorf("API GetTelemetryId called but not implemented."))
	}
	return nil
}

type ZCreateUserArgs struct {
	A *model.User
}

type ZCreateUserReturns struct {
	A *model.User
	B *model.AppError
}

func (g *apiRPCClient) CreateUser(user *model.User) (*model.User, *model.AppError) {
	_args := &ZCreateUserArgs{user}
	_returns := &ZCreateUserReturns{}
	if err := g.client.Call("Plugin.CreateUser", _args, _returns); err != nil {
		log.Printf("RPC call to CreateUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateUser(args *ZCreateUserArgs, returns *ZCreateUserReturns) error {
	if hook, ok := s.impl.(interface {
		CreateUser(user *model.User) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API CreateUser called but not implemented."))
	}
	return nil
}

type ZDeleteUserArgs struct {
	A string
}

type ZDeleteUserReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteUser(userId string) *model.AppError {
	_args := &ZDeleteUserArgs{userId}
	_returns := &ZDeleteUserReturns{}
	if err := g.client.Call("Plugin.DeleteUser", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteUser API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteUser(args *ZDeleteUserArgs, returns *ZDeleteUserReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteUser(userId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API DeleteUser called but not implemented."))
	}
	return nil
}

type ZGetUsersArgs struct {
	A *model.UserGetOptions
}

type ZGetUsersReturns struct {
	A []*model.User
	B *model.AppError
}

func (g *apiRPCClient) GetUsers(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	_args := &ZGetUsersArgs{options}
	_returns := &ZGetUsersReturns{}
	if err := g.client.Call("Plugin.GetUsers", _args, _returns); err != nil {
		log.Printf("RPC call to GetUsers API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUsers(args *ZGetUsersArgs, returns *ZGetUsersReturns) error {
	if hook, ok := s.impl.(interface {
		GetUsers(options *model.UserGetOptions) ([]*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUsers(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUsers called but not implemented."))
	}
	return nil
}

type ZGetUserArgs struct {
	A string
}

type ZGetUserReturns struct {
	A *model.User
	B *model.AppError
}

func (g *apiRPCClient) GetUser(userId string) (*model.User, *model.AppError) {
	_args := &ZGetUserArgs{userId}
	_returns := &ZGetUserReturns{}
	if err := g.client.Call("Plugin.GetUser", _args, _returns); err != nil {
		log.Printf("RPC call to GetUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUser(args *ZGetUserArgs, returns *ZGetUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetUser(userId string) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUser called but not implemented."))
	}
	return nil
}

type ZGetUserByEmailArgs struct {
	A string
}

type ZGetUserByEmailReturns struct {
	A *model.User
	B *model.AppError
}

func (g *apiRPCClient) GetUserByEmail(email string) (*model.User, *model.AppError) {
	_args := &ZGetUserByEmailArgs{email}
	_returns := &ZGetUserByEmailReturns{}
	if err := g.client.Call("Plugin.GetUserByEmail", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserByEmail API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserByEmail(args *ZGetUserByEmailArgs, returns *ZGetUserByEmailReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserByEmail(email string) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserByEmail(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserByEmail called but not implemented."))
	}
	return nil
}

type ZGetUserByUsernameArgs struct {
	A string
}

type ZGetUserByUsernameReturns struct {
	A *model.User
	B *model.AppError
}

func (g *apiRPCClient) GetUserByUsername(name string) (*model.User, *model.AppError) {
	_args := &ZGetUserByUsernameArgs{name}
	_returns := &ZGetUserByUsernameReturns{}
	if err := g.client.Call("Plugin.GetUserByUsername", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserByUsername API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserByUsername(args *ZGetUserByUsernameArgs, returns *ZGetUserByUsernameReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserByUsername(name string) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserByUsername(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserByUsername called but not implemented."))
	}
	return nil
}

type ZGetUsersByUsernamesArgs struct {
	A []string
}

type ZGetUsersByUsernamesReturns struct {
	A []*model.User
	B *model.AppError
}

func (g *apiRPCClient) GetUsersByUsernames(usernames []string) ([]*model.User, *model.AppError) {
	_args := &ZGetUsersByUsernamesArgs{usernames}
	_returns := &ZGetUsersByUsernamesReturns{}
	if err := g.client.Call("Plugin.GetUsersByUsernames", _args, _returns); err != nil {
		log.Printf("RPC call to GetUsersByUsernames API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUsersByUsernames(args *ZGetUsersByUsernamesArgs, returns *ZGetUsersByUsernamesReturns) error {
	if hook, ok := s.impl.(interface {
		GetUsersByUsernames(usernames []string) ([]*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUsersByUsernames(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUsersByUsernames called but not implemented."))
	}
	return nil
}

type ZGetUsersInTeamArgs struct {
	A string
	B int
	C int
}

type ZGetUsersInTeamReturns struct {
	A []*model.User
	B *model.AppError
}

func (g *apiRPCClient) GetUsersInTeam(teamId string, page int, perPage int) ([]*model.User, *model.AppError) {
	_args := &ZGetUsersInTeamArgs{teamId, page, perPage}
	_returns := &ZGetUsersInTeamReturns{}
	if err := g.client.Call("Plugin.GetUsersInTeam", _args, _returns); err != nil {
		log.Printf("RPC call to GetUsersInTeam API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUsersInTeam(args *ZGetUsersInTeamArgs, returns *ZGetUsersInTeamReturns) error {
	if hook, ok := s.impl.(interface {
		GetUsersInTeam(teamId string, page int, perPage int) ([]*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUsersInTeam(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetUsersInTeam called but not implemented."))
	}
	return nil
}

type ZGetPreferencesForUserArgs struct {
	A string
}

type ZGetPreferencesForUserReturns struct {
	A []model.Preference
	B *model.AppError
}

func (g *apiRPCClient) GetPreferencesForUser(userId string) ([]model.Preference, *model.AppError) {
	_args := &ZGetPreferencesForUserArgs{userId}
	_returns := &ZGetPreferencesForUserReturns{}
	if err := g.client.Call("Plugin.GetPreferencesForUser", _args, _returns); err != nil {
		log.Printf("RPC call to GetPreferencesForUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPreferencesForUser(args *ZGetPreferencesForUserArgs, returns *ZGetPreferencesForUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetPreferencesForUser(userId string) ([]model.Preference, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPreferencesForUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetPreferencesForUser called but not implemented."))
	}
	return nil
}

type ZUpdatePreferencesForUserArgs struct {
	A string
	B []model.Preference
}

type ZUpdatePreferencesForUserReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) UpdatePreferencesForUser(userId string, preferences []model.Preference) *model.AppError {
	_args := &ZUpdatePreferencesForUserArgs{userId, preferences}
	_returns := &ZUpdatePreferencesForUserReturns{}
	if err := g.client.Call("Plugin.UpdatePreferencesForUser", _args, _returns); err != nil {
		log.Printf("RPC call to UpdatePreferencesForUser API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) UpdatePreferencesForUser(args *ZUpdatePreferencesForUserArgs, returns *ZUpdatePreferencesForUserReturns) error {
	if hook, ok := s.impl.(interface {
		UpdatePreferencesForUser(userId string, preferences []model.Preference) *model.AppError
	}); ok {
		returns.A = hook.UpdatePreferencesForUser(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API UpdatePreferencesForUser called but not implemented."))
	}
	return nil
}

type ZDeletePreferencesForUserArgs struct {
	A string
	B []model.Preference
}

type ZDeletePreferencesForUserReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeletePreferencesForUser(userId string, preferences []model.Preference) *model.AppError {
	_args := &ZDeletePreferencesForUserArgs{userId, preferences}
	_returns := &ZDeletePreferencesForUserReturns{}
	if err := g.client.Call("Plugin.DeletePreferencesForUser", _args, _returns); err != nil {
		log.Printf("RPC call to DeletePreferencesForUser API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeletePreferencesForUser(args *ZDeletePreferencesForUserArgs, returns *ZDeletePreferencesForUserReturns) error {
	if hook, ok := s.impl.(interface {
		DeletePreferencesForUser(userId string, preferences []model.Preference) *model.AppError
	}); ok {
		returns.A = hook.DeletePreferencesForUser(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API DeletePreferencesForUser called but not implemented."))
	}
	return nil
}

type ZGetTeamIconArgs struct {
	A string
}

type ZGetTeamIconReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) GetTeamIcon(teamId string) ([]byte, *model.AppError) {
	_args := &ZGetTeamIconArgs{teamId}
	_returns := &ZGetTeamIconReturns{}
	if err := g.client.Call("Plugin.GetTeamIcon", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeamIcon API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeamIcon(args *ZGetTeamIconArgs, returns *ZGetTeamIconReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamIcon(teamId string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamIcon(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetTeamIcon called but not implemented."))
	}
	return nil
}

type ZSetTeamIconArgs struct {
	A string
	B []byte
}

type ZSetTeamIconReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) SetTeamIcon(teamId string, data []byte) *model.AppError {
	_args := &ZSetTeamIconArgs{teamId, data}
	_returns := &ZSetTeamIconReturns{}
	if err := g.client.Call("Plugin.SetTeamIcon", _args, _returns); err != nil {
		log.Printf("RPC call to SetTeamIcon API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SetTeamIcon(args *ZSetTeamIconArgs, returns *ZSetTeamIconReturns) error {
	if hook, ok := s.impl.(interface {
		SetTeamIcon(teamId string, data []byte) *model.AppError
	}); ok {
		returns.A = hook.SetTeamIcon(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API SetTeamIcon called but not implemented."))
	}
	return nil
}

type ZRemoveTeamIconArgs struct {
	A string
}

type ZRemoveTeamIconReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) RemoveTeamIcon(teamId string) *model.AppError {
	_args := &ZRemoveTeamIconArgs{teamId}
	_returns := &ZRemoveTeamIconReturns{}
	if err := g.client.Call("Plugin.RemoveTeamIcon", _args, _returns); err != nil {
		log.Printf("RPC call to RemoveTeamIcon API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) RemoveTeamIcon(args *ZRemoveTeamIconArgs, returns *ZRemoveTeamIconReturns) error {
	if hook, ok := s.impl.(interface {
		RemoveTeamIcon(teamId string) *model.AppError
	}); ok {
		returns.A = hook.RemoveTeamIcon(args.A)
	} else {
		return encodableError(fmt.Errorf("API RemoveTeamIcon called but not implemented."))
	}
	return nil
}

type ZUpdateUserArgs struct {
	A *model.User
}

type ZUpdateUserReturns struct {
	A *model.User
	B *model.AppError
}

func (g *apiRPCClient) UpdateUser(user *model.User) (*model.User, *model.AppError) {
	_args := &ZUpdateUserArgs{user}
	_returns := &ZUpdateUserReturns{}
	if err := g.client.Call("Plugin.UpdateUser", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateUser(args *ZUpdateUserArgs, returns *ZUpdateUserReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateUser(user *model.User) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API UpdateUser called but not implemented."))
	}
	return nil
}

type ZGetUserStatusArgs struct {
	A string
}

type ZGetUserStatusReturns struct {
	A *model.Status
	B *model.AppError
}

func (g *apiRPCClient) GetUserStatus(userId string) (*model.Status, *model.AppError) {
	_args := &ZGetUserStatusArgs{userId}
	_returns := &ZGetUserStatusReturns{}
	if err := g.client.Call("Plugin.GetUserStatus", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserStatus API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserStatus(args *ZGetUserStatusArgs, returns *ZGetUserStatusReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserStatus(userId string) (*model.Status, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserStatus(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserStatus called but not implemented."))
	}
	return nil
}

type ZGetUserStatusesByIdsArgs struct {
	A []string
}

type ZGetUserStatusesByIdsReturns struct {
	A []*model.Status
	B *model.AppError
}

func (g *apiRPCClient) GetUserStatusesByIds(userIds []string) ([]*model.Status, *model.AppError) {
	_args := &ZGetUserStatusesByIdsArgs{userIds}
	_returns := &ZGetUserStatusesByIdsReturns{}
	if err := g.client.Call("Plugin.GetUserStatusesByIds", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserStatusesByIds API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserStatusesByIds(args *ZGetUserStatusesByIdsArgs, returns *ZGetUserStatusesByIdsReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserStatusesByIds(userIds []string) ([]*model.Status, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserStatusesByIds(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserStatusesByIds called but not implemented."))
	}
	return nil
}

type ZUpdateUserStatusArgs struct {
	A string
	B string
}

type ZUpdateUserStatusReturns struct {
	A *model.Status
	B *model.AppError
}

func (g *apiRPCClient) UpdateUserStatus(userId, status string) (*model.Status, *model.AppError) {
	_args := &ZUpdateUserStatusArgs{userId, status}
	_returns := &ZUpdateUserStatusReturns{}
	if err := g.client.Call("Plugin.UpdateUserStatus", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateUserStatus API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateUserStatus(args *ZUpdateUserStatusArgs, returns *ZUpdateUserStatusReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateUserStatus(userId, status string) (*model.Status, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateUserStatus(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API UpdateUserStatus called but not implemented."))
	}
	return nil
}

type ZUpdateUserActiveArgs struct {
	A string
	B bool
}

type ZUpdateUserActiveReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) UpdateUserActive(userId string, active bool) *model.AppError {
	_args := &ZUpdateUserActiveArgs{userId, active}
	_returns := &ZUpdateUserActiveReturns{}
	if err := g.client.Call("Plugin.UpdateUserActive", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateUserActive API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) UpdateUserActive(args *ZUpdateUserActiveArgs, returns *ZUpdateUserActiveReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateUserActive(userId string, active bool) *model.AppError
	}); ok {
		returns.A = hook.UpdateUserActive(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API UpdateUserActive called but not implemented."))
	}
	return nil
}

type ZGetUsersInChannelArgs struct {
	A string
	B string
	C int
	D int
}

type ZGetUsersInChannelReturns struct {
	A []*model.User
	B *model.AppError
}

func (g *apiRPCClient) GetUsersInChannel(channelId, sortBy string, page, perPage int) ([]*model.User, *model.AppError) {
	_args := &ZGetUsersInChannelArgs{channelId, sortBy, page, perPage}
	_returns := &ZGetUsersInChannelReturns{}
	if err := g.client.Call("Plugin.GetUsersInChannel", _args, _returns); err != nil {
		log.Printf("RPC call to GetUsersInChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUsersInChannel(args *ZGetUsersInChannelArgs, returns *ZGetUsersInChannelReturns) error {
	if hook, ok := s.impl.(interface {
		GetUsersInChannel(channelId, sortBy string, page, perPage int) ([]*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUsersInChannel(args.A, args.B, args.C, args.D)
	} else {
		return encodableError(fmt.Errorf("API GetUsersInChannel called but not implemented."))
	}
	return nil
}

type ZGetLDAPUserAttributesArgs struct {
	A string
	B []string
}

type ZGetLDAPUserAttributesReturns struct {
	A map[string]string
	B *model.AppError
}

func (g *apiRPCClient) GetLDAPUserAttributes(userId string, attributes []string) (map[string]string, *model.AppError) {
	_args := &ZGetLDAPUserAttributesArgs{userId, attributes}
	_returns := &ZGetLDAPUserAttributesReturns{}
	if err := g.client.Call("Plugin.GetLDAPUserAttributes", _args, _returns); err != nil {
		log.Printf("RPC call to GetLDAPUserAttributes API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetLDAPUserAttributes(args *ZGetLDAPUserAttributesArgs, returns *ZGetLDAPUserAttributesReturns) error {
	if hook, ok := s.impl.(interface {
		GetLDAPUserAttributes(userId string, attributes []string) (map[string]string, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetLDAPUserAttributes(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetLDAPUserAttributes called but not implemented."))
	}
	return nil
}

type ZCreateTeamArgs struct {
	A *model.Team
}

type ZCreateTeamReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *apiRPCClient) CreateTeam(team *model.Team) (*model.Team, *model.AppError) {
	_args := &ZCreateTeamArgs{team}
	_returns := &ZCreateTeamReturns{}
	if err := g.client.Call("Plugin.CreateTeam", _args, _returns); err != nil {
		log.Printf("RPC call to CreateTeam API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateTeam(args *ZCreateTeamArgs, returns *ZCreateTeamReturns) error {
	if hook, ok := s.impl.(interface {
		CreateTeam(team *model.Team) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateTeam(args.A)
	} else {
		return encodableError(fmt.Errorf("API CreateTeam called but not implemented."))
	}
	return nil
}

type ZDeleteTeamArgs struct {
	A string
}

type ZDeleteTeamReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteTeam(teamId string) *model.AppError {
	_args := &ZDeleteTeamArgs{teamId}
	_returns := &ZDeleteTeamReturns{}
	if err := g.client.Call("Plugin.DeleteTeam", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteTeam API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteTeam(args *ZDeleteTeamArgs, returns *ZDeleteTeamReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteTeam(teamId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteTeam(args.A)
	} else {
		return encodableError(fmt.Errorf("API DeleteTeam called but not implemented."))
	}
	return nil
}

type ZGetTeamsArgs struct {
}

type ZGetTeamsReturns struct {
	A []*model.Team
	B *model.AppError
}

func (g *apiRPCClient) GetTeams() ([]*model.Team, *model.AppError) {
	_args := &ZGetTeamsArgs{}
	_returns := &ZGetTeamsReturns{}
	if err := g.client.Call("Plugin.GetTeams", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeams API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeams(args *ZGetTeamsArgs, returns *ZGetTeamsReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeams() ([]*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeams()
	} else {
		return encodableError(fmt.Errorf("API GetTeams called but not implemented."))
	}
	return nil
}

type ZGetTeamArgs struct {
	A string
}

type ZGetTeamReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *apiRPCClient) GetTeam(teamId string) (*model.Team, *model.AppError) {
	_args := &ZGetTeamArgs{teamId}
	_returns := &ZGetTeamReturns{}
	if err := g.client.Call("Plugin.GetTeam", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeam API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeam(args *ZGetTeamArgs, returns *ZGetTeamReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeam(teamId string) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeam(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetTeam called but not implemented."))
	}
	return nil
}

type ZGetTeamByNameArgs struct {
	A string
}

type ZGetTeamByNameReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *apiRPCClient) GetTeamByName(name string) (*model.Team, *model.AppError) {
	_args := &ZGetTeamByNameArgs{name}
	_returns := &ZGetTeamByNameReturns{}
	if err := g.client.Call("Plugin.GetTeamByName", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeamByName API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeamByName(args *ZGetTeamByNameArgs, returns *ZGetTeamByNameReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamByName(name string) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamByName(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetTeamByName called but not implemented."))
	}
	return nil
}

type ZGetTeamsUnreadForUserArgs struct {
	A string
}

type ZGetTeamsUnreadForUserReturns struct {
	A []*model.TeamUnread
	B *model.AppError
}

func (g *apiRPCClient) GetTeamsUnreadForUser(userId string) ([]*model.TeamUnread, *model.AppError) {
	_args := &ZGetTeamsUnreadForUserArgs{userId}
	_returns := &ZGetTeamsUnreadForUserReturns{}
	if err := g.client.Call("Plugin.GetTeamsUnreadForUser", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeamsUnreadForUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeamsUnreadForUser(args *ZGetTeamsUnreadForUserArgs, returns *ZGetTeamsUnreadForUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamsUnreadForUser(userId string) ([]*model.TeamUnread, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamsUnreadForUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetTeamsUnreadForUser called but not implemented."))
	}
	return nil
}

type ZUpdateTeamArgs struct {
	A *model.Team
}

type ZUpdateTeamReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *apiRPCClient) UpdateTeam(team *model.Team) (*model.Team, *model.AppError) {
	_args := &ZUpdateTeamArgs{team}
	_returns := &ZUpdateTeamReturns{}
	if err := g.client.Call("Plugin.UpdateTeam", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateTeam API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateTeam(args *ZUpdateTeamArgs, returns *ZUpdateTeamReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateTeam(team *model.Team) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateTeam(args.A)
	} else {
		return encodableError(fmt.Errorf("API UpdateTeam called but not implemented."))
	}
	return nil
}

type ZSearchTeamsArgs struct {
	A string
}

type ZSearchTeamsReturns struct {
	A []*model.Team
	B *model.AppError
}

func (g *apiRPCClient) SearchTeams(term string) ([]*model.Team, *model.AppError) {
	_args := &ZSearchTeamsArgs{term}
	_returns := &ZSearchTeamsReturns{}
	if err := g.client.Call("Plugin.SearchTeams", _args, _returns); err != nil {
		log.Printf("RPC call to SearchTeams API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) SearchTeams(args *ZSearchTeamsArgs, returns *ZSearchTeamsReturns) error {
	if hook, ok := s.impl.(interface {
		SearchTeams(term string) ([]*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.SearchTeams(args.A)
	} else {
		return encodableError(fmt.Errorf("API SearchTeams called but not implemented."))
	}
	return nil
}

type ZGetTeamsForUserArgs struct {
	A string
}

type ZGetTeamsForUserReturns struct {
	A []*model.Team
	B *model.AppError
}

func (g *apiRPCClient) GetTeamsForUser(userId string) ([]*model.Team, *model.AppError) {
	_args := &ZGetTeamsForUserArgs{userId}
	_returns := &ZGetTeamsForUserReturns{}
	if err := g.client.Call("Plugin.GetTeamsForUser", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeamsForUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeamsForUser(args *ZGetTeamsForUserArgs, returns *ZGetTeamsForUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamsForUser(userId string) ([]*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamsForUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetTeamsForUser called but not implemented."))
	}
	return nil
}

type ZCreateTeamMemberArgs struct {
	A string
	B string
}

type ZCreateTeamMemberReturns struct {
	A *model.TeamMember
	B *model.AppError
}

func (g *apiRPCClient) CreateTeamMember(teamId, userId string) (*model.TeamMember, *model.AppError) {
	_args := &ZCreateTeamMemberArgs{teamId, userId}
	_returns := &ZCreateTeamMemberReturns{}
	if err := g.client.Call("Plugin.CreateTeamMember", _args, _returns); err != nil {
		log.Printf("RPC call to CreateTeamMember API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateTeamMember(args *ZCreateTeamMemberArgs, returns *ZCreateTeamMemberReturns) error {
	if hook, ok := s.impl.(interface {
		CreateTeamMember(teamId, userId string) (*model.TeamMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateTeamMember(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API CreateTeamMember called but not implemented."))
	}
	return nil
}

type ZCreateTeamMembersArgs struct {
	A string
	B []string
	C string
}

type ZCreateTeamMembersReturns struct {
	A []*model.TeamMember
	B *model.AppError
}

func (g *apiRPCClient) CreateTeamMembers(teamId string, userIds []string, requestorId string) ([]*model.TeamMember, *model.AppError) {
	_args := &ZCreateTeamMembersArgs{teamId, userIds, requestorId}
	_returns := &ZCreateTeamMembersReturns{}
	if err := g.client.Call("Plugin.CreateTeamMembers", _args, _returns); err != nil {
		log.Printf("RPC call to CreateTeamMembers API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateTeamMembers(args *ZCreateTeamMembersArgs, returns *ZCreateTeamMembersReturns) error {
	if hook, ok := s.impl.(interface {
		CreateTeamMembers(teamId string, userIds []string, requestorId string) ([]*model.TeamMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateTeamMembers(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API CreateTeamMembers called but not implemented."))
	}
	return nil
}

type ZCreateTeamMembersGracefullyArgs struct {
	A string
	B []string
	C string
}

type ZCreateTeamMembersGracefullyReturns struct {
	A []*model.TeamMemberWithError
	B *model.AppError
}

func (g *apiRPCClient) CreateTeamMembersGracefully(teamId string, userIds []string, requestorId string) ([]*model.TeamMemberWithError, *model.AppError) {
	_args := &ZCreateTeamMembersGracefullyArgs{teamId, userIds, requestorId}
	_returns := &ZCreateTeamMembersGracefullyReturns{}
	if err := g.client.Call("Plugin.CreateTeamMembersGracefully", _args, _returns); err != nil {
		log.Printf("RPC call to CreateTeamMembersGracefully API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateTeamMembersGracefully(args *ZCreateTeamMembersGracefullyArgs, returns *ZCreateTeamMembersGracefullyReturns) error {
	if hook, ok := s.impl.(interface {
		CreateTeamMembersGracefully(teamId string, userIds []string, requestorId string) ([]*model.TeamMemberWithError, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateTeamMembersGracefully(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API CreateTeamMembersGracefully called but not implemented."))
	}
	return nil
}

type ZDeleteTeamMemberArgs struct {
	A string
	B string
	C string
}

type ZDeleteTeamMemberReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteTeamMember(teamId, userId, requestorId string) *model.AppError {
	_args := &ZDeleteTeamMemberArgs{teamId, userId, requestorId}
	_returns := &ZDeleteTeamMemberReturns{}
	if err := g.client.Call("Plugin.DeleteTeamMember", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteTeamMember API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteTeamMember(args *ZDeleteTeamMemberArgs, returns *ZDeleteTeamMemberReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteTeamMember(teamId, userId, requestorId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteTeamMember(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API DeleteTeamMember called but not implemented."))
	}
	return nil
}

type ZGetTeamMembersArgs struct {
	A string
	B int
	C int
}

type ZGetTeamMembersReturns struct {
	A []*model.TeamMember
	B *model.AppError
}

func (g *apiRPCClient) GetTeamMembers(teamId string, page, perPage int) ([]*model.TeamMember, *model.AppError) {
	_args := &ZGetTeamMembersArgs{teamId, page, perPage}
	_returns := &ZGetTeamMembersReturns{}
	if err := g.client.Call("Plugin.GetTeamMembers", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeamMembers API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeamMembers(args *ZGetTeamMembersArgs, returns *ZGetTeamMembersReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamMembers(teamId string, page, perPage int) ([]*model.TeamMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamMembers(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetTeamMembers called but not implemented."))
	}
	return nil
}

type ZGetTeamMemberArgs struct {
	A string
	B string
}

type ZGetTeamMemberReturns struct {
	A *model.TeamMember
	B *model.AppError
}

func (g *apiRPCClient) GetTeamMember(teamId, userId string) (*model.TeamMember, *model.AppError) {
	_args := &ZGetTeamMemberArgs{teamId, userId}
	_returns := &ZGetTeamMemberReturns{}
	if err := g.client.Call("Plugin.GetTeamMember", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeamMember API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeamMember(args *ZGetTeamMemberArgs, returns *ZGetTeamMemberReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamMember(teamId, userId string) (*model.TeamMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamMember(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetTeamMember called but not implemented."))
	}
	return nil
}

type ZGetTeamMembersForUserArgs struct {
	A string
	B int
	C int
}

type ZGetTeamMembersForUserReturns struct {
	A []*model.TeamMember
	B *model.AppError
}

func (g *apiRPCClient) GetTeamMembersForUser(userId string, page int, perPage int) ([]*model.TeamMember, *model.AppError) {
	_args := &ZGetTeamMembersForUserArgs{userId, page, perPage}
	_returns := &ZGetTeamMembersForUserReturns{}
	if err := g.client.Call("Plugin.GetTeamMembersForUser", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeamMembersForUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeamMembersForUser(args *ZGetTeamMembersForUserArgs, returns *ZGetTeamMembersForUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamMembersForUser(userId string, page int, perPage int) ([]*model.TeamMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamMembersForUser(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetTeamMembersForUser called but not implemented."))
	}
	return nil
}

type ZUpdateTeamMemberRolesArgs struct {
	A string
	B string
	C string
}

type ZUpdateTeamMemberRolesReturns struct {
	A *model.TeamMember
	B *model.AppError
}

func (g *apiRPCClient) UpdateTeamMemberRoles(teamId, userId, newRoles string) (*model.TeamMember, *model.AppError) {
	_args := &ZUpdateTeamMemberRolesArgs{teamId, userId, newRoles}
	_returns := &ZUpdateTeamMemberRolesReturns{}
	if err := g.client.Call("Plugin.UpdateTeamMemberRoles", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateTeamMemberRoles API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateTeamMemberRoles(args *ZUpdateTeamMemberRolesArgs, returns *ZUpdateTeamMemberRolesReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateTeamMemberRoles(teamId, userId, newRoles string) (*model.TeamMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateTeamMemberRoles(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API UpdateTeamMemberRoles called but not implemented."))
	}
	return nil
}

type ZCreateChannelArgs struct {
	A *model.Channel
}

type ZCreateChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) CreateChannel(channel *model.Channel) (*model.Channel, *model.AppError) {
	_args := &ZCreateChannelArgs{channel}
	_returns := &ZCreateChannelReturns{}
	if err := g.client.Call("Plugin.CreateChannel", _args, _returns); err != nil {
		log.Printf("RPC call to CreateChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateChannel(args *ZCreateChannelArgs, returns *ZCreateChannelReturns) error {
	if hook, ok := s.impl.(interface {
		CreateChannel(channel *model.Channel) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateChannel(args.A)
	} else {
		return encodableError(fmt.Errorf("API CreateChannel called but not implemented."))
	}
	return nil
}

type ZDeleteChannelArgs struct {
	A string
}

type ZDeleteChannelReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteChannel(channelId string) *model.AppError {
	_args := &ZDeleteChannelArgs{channelId}
	_returns := &ZDeleteChannelReturns{}
	if err := g.client.Call("Plugin.DeleteChannel", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteChannel API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteChannel(args *ZDeleteChannelArgs, returns *ZDeleteChannelReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteChannel(channelId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteChannel(args.A)
	} else {
		return encodableError(fmt.Errorf("API DeleteChannel called but not implemented."))
	}
	return nil
}

type ZGetPublicChannelsForTeamArgs struct {
	A string
	B int
	C int
}

type ZGetPublicChannelsForTeamReturns struct {
	A []*model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetPublicChannelsForTeam(teamId string, page, perPage int) ([]*model.Channel, *model.AppError) {
	_args := &ZGetPublicChannelsForTeamArgs{teamId, page, perPage}
	_returns := &ZGetPublicChannelsForTeamReturns{}
	if err := g.client.Call("Plugin.GetPublicChannelsForTeam", _args, _returns); err != nil {
		log.Printf("RPC call to GetPublicChannelsForTeam API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPublicChannelsForTeam(args *ZGetPublicChannelsForTeamArgs, returns *ZGetPublicChannelsForTeamReturns) error {
	if hook, ok := s.impl.(interface {
		GetPublicChannelsForTeam(teamId string, page, perPage int) ([]*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPublicChannelsForTeam(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetPublicChannelsForTeam called but not implemented."))
	}
	return nil
}

type ZGetChannelArgs struct {
	A string
}

type ZGetChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetChannel(channelId string) (*model.Channel, *model.AppError) {
	_args := &ZGetChannelArgs{channelId}
	_returns := &ZGetChannelReturns{}
	if err := g.client.Call("Plugin.GetChannel", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannel(args *ZGetChannelArgs, returns *ZGetChannelReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannel(channelId string) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannel(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetChannel called but not implemented."))
	}
	return nil
}

type ZGetChannelByNameArgs struct {
	A string
	B string
	C bool
}

type ZGetChannelByNameReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetChannelByName(teamId, name string, includeDeleted bool) (*model.Channel, *model.AppError) {
	_args := &ZGetChannelByNameArgs{teamId, name, includeDeleted}
	_returns := &ZGetChannelByNameReturns{}
	if err := g.client.Call("Plugin.GetChannelByName", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannelByName API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannelByName(args *ZGetChannelByNameArgs, returns *ZGetChannelByNameReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelByName(teamId, name string, includeDeleted bool) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelByName(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetChannelByName called but not implemented."))
	}
	return nil
}

type ZGetChannelByNameForTeamNameArgs struct {
	A string
	B string
	C bool
}

type ZGetChannelByNameForTeamNameReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetChannelByNameForTeamName(teamName, channelName string, includeDeleted bool) (*model.Channel, *model.AppError) {
	_args := &ZGetChannelByNameForTeamNameArgs{teamName, channelName, includeDeleted}
	_returns := &ZGetChannelByNameForTeamNameReturns{}
	if err := g.client.Call("Plugin.GetChannelByNameForTeamName", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannelByNameForTeamName API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannelByNameForTeamName(args *ZGetChannelByNameForTeamNameArgs, returns *ZGetChannelByNameForTeamNameReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelByNameForTeamName(teamName, channelName string, includeDeleted bool) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelByNameForTeamName(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetChannelByNameForTeamName called but not implemented."))
	}
	return nil
}

type ZGetChannelsForTeamForUserArgs struct {
	A string
	B string
	C bool
}

type ZGetChannelsForTeamForUserReturns struct {
	A []*model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetChannelsForTeamForUser(teamId, userId string, includeDeleted bool) ([]*model.Channel, *model.AppError) {
	_args := &ZGetChannelsForTeamForUserArgs{teamId, userId, includeDeleted}
	_returns := &ZGetChannelsForTeamForUserReturns{}
	if err := g.client.Call("Plugin.GetChannelsForTeamForUser", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannelsForTeamForUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannelsForTeamForUser(args *ZGetChannelsForTeamForUserArgs, returns *ZGetChannelsForTeamForUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelsForTeamForUser(teamId, userId string, includeDeleted bool) ([]*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelsForTeamForUser(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetChannelsForTeamForUser called but not implemented."))
	}
	return nil
}

type ZGetChannelStatsArgs struct {
	A string
}

type ZGetChannelStatsReturns struct {
	A *model.ChannelStats
	B *model.AppError
}

func (g *apiRPCClient) GetChannelStats(channelId string) (*model.ChannelStats, *model.AppError) {
	_args := &ZGetChannelStatsArgs{channelId}
	_returns := &ZGetChannelStatsReturns{}
	if err := g.client.Call("Plugin.GetChannelStats", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannelStats API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannelStats(args *ZGetChannelStatsArgs, returns *ZGetChannelStatsReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelStats(channelId string) (*model.ChannelStats, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelStats(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetChannelStats called but not implemented."))
	}
	return nil
}

type ZGetDirectChannelArgs struct {
	A string
	B string
}

type ZGetDirectChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetDirectChannel(userId1, userId2 string) (*model.Channel, *model.AppError) {
	_args := &ZGetDirectChannelArgs{userId1, userId2}
	_returns := &ZGetDirectChannelReturns{}
	if err := g.client.Call("Plugin.GetDirectChannel", _args, _returns); err != nil {
		log.Printf("RPC call to GetDirectChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetDirectChannel(args *ZGetDirectChannelArgs, returns *ZGetDirectChannelReturns) error {
	if hook, ok := s.impl.(interface {
		GetDirectChannel(userId1, userId2 string) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetDirectChannel(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetDirectChannel called but not implemented."))
	}
	return nil
}

type ZGetGroupChannelArgs struct {
	A []string
}

type ZGetGroupChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetGroupChannel(userIds []string) (*model.Channel, *model.AppError) {
	_args := &ZGetGroupChannelArgs{userIds}
	_returns := &ZGetGroupChannelReturns{}
	if err := g.client.Call("Plugin.GetGroupChannel", _args, _returns); err != nil {
		log.Printf("RPC call to GetGroupChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetGroupChannel(args *ZGetGroupChannelArgs, returns *ZGetGroupChannelReturns) error {
	if hook, ok := s.impl.(interface {
		GetGroupChannel(userIds []string) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetGroupChannel(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetGroupChannel called but not implemented."))
	}
	return nil
}

type ZUpdateChannelArgs struct {
	A *model.Channel
}

type ZUpdateChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) UpdateChannel(channel *model.Channel) (*model.Channel, *model.AppError) {
	_args := &ZUpdateChannelArgs{channel}
	_returns := &ZUpdateChannelReturns{}
	if err := g.client.Call("Plugin.UpdateChannel", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateChannel(args *ZUpdateChannelArgs, returns *ZUpdateChannelReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateChannel(channel *model.Channel) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateChannel(args.A)
	} else {
		return encodableError(fmt.Errorf("API UpdateChannel called but not implemented."))
	}
	return nil
}

type ZSearchChannelsArgs struct {
	A string
	B string
}

type ZSearchChannelsReturns struct {
	A []*model.Channel
	B *model.AppError
}

func (g *apiRPCClient) SearchChannels(teamId string, term string) ([]*model.Channel, *model.AppError) {
	_args := &ZSearchChannelsArgs{teamId, term}
	_returns := &ZSearchChannelsReturns{}
	if err := g.client.Call("Plugin.SearchChannels", _args, _returns); err != nil {
		log.Printf("RPC call to SearchChannels API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) SearchChannels(args *ZSearchChannelsArgs, returns *ZSearchChannelsReturns) error {
	if hook, ok := s.impl.(interface {
		SearchChannels(teamId string, term string) ([]*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.SearchChannels(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API SearchChannels called but not implemented."))
	}
	return nil
}

type ZSearchUsersArgs struct {
	A *model.UserSearch
}

type ZSearchUsersReturns struct {
	A []*model.User
	B *model.AppError
}

func (g *apiRPCClient) SearchUsers(search *model.UserSearch) ([]*model.User, *model.AppError) {
	_args := &ZSearchUsersArgs{search}
	_returns := &ZSearchUsersReturns{}
	if err := g.client.Call("Plugin.SearchUsers", _args, _returns); err != nil {
		log.Printf("RPC call to SearchUsers API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) SearchUsers(args *ZSearchUsersArgs, returns *ZSearchUsersReturns) error {
	if hook, ok := s.impl.(interface {
		SearchUsers(search *model.UserSearch) ([]*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.SearchUsers(args.A)
	} else {
		return encodableError(fmt.Errorf("API SearchUsers called but not implemented."))
	}
	return nil
}

type ZSearchPostsInTeamArgs struct {
	A string
	B []*model.SearchParams
}

type ZSearchPostsInTeamReturns struct {
	A []*model.Post
	B *model.AppError
}

func (g *apiRPCClient) SearchPostsInTeam(teamId string, paramsList []*model.SearchParams) ([]*model.Post, *model.AppError) {
	_args := &ZSearchPostsInTeamArgs{teamId, paramsList}
	_returns := &ZSearchPostsInTeamReturns{}
	if err := g.client.Call("Plugin.SearchPostsInTeam", _args, _returns); err != nil {
		log.Printf("RPC call to SearchPostsInTeam API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) SearchPostsInTeam(args *ZSearchPostsInTeamArgs, returns *ZSearchPostsInTeamReturns) error {
	if hook, ok := s.impl.(interface {
		SearchPostsInTeam(teamId string, paramsList []*model.SearchParams) ([]*model.Post, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.SearchPostsInTeam(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API SearchPostsInTeam called but not implemented."))
	}
	return nil
}

type ZSearchPostsInTeamForUserArgs struct {
	A string
	B string
	C model.SearchParameter
}

type ZSearchPostsInTeamForUserReturns struct {
	A *model.PostSearchResults
	B *model.AppError
}

func (g *apiRPCClient) SearchPostsInTeamForUser(teamId string, userId string, searchParams model.SearchParameter) (*model.PostSearchResults, *model.AppError) {
	_args := &ZSearchPostsInTeamForUserArgs{teamId, userId, searchParams}
	_returns := &ZSearchPostsInTeamForUserReturns{}
	if err := g.client.Call("Plugin.SearchPostsInTeamForUser", _args, _returns); err != nil {
		log.Printf("RPC call to SearchPostsInTeamForUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) SearchPostsInTeamForUser(args *ZSearchPostsInTeamForUserArgs, returns *ZSearchPostsInTeamForUserReturns) error {
	if hook, ok := s.impl.(interface {
		SearchPostsInTeamForUser(teamId string, userId string, searchParams model.SearchParameter) (*model.PostSearchResults, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.SearchPostsInTeamForUser(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API SearchPostsInTeamForUser called but not implemented."))
	}
	return nil
}

type ZAddChannelMemberArgs struct {
	A string
	B string
}

type ZAddChannelMemberReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *apiRPCClient) AddChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError) {
	_args := &ZAddChannelMemberArgs{channelId, userId}
	_returns := &ZAddChannelMemberReturns{}
	if err := g.client.Call("Plugin.AddChannelMember", _args, _returns); err != nil {
		log.Printf("RPC call to AddChannelMember API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) AddChannelMember(args *ZAddChannelMemberArgs, returns *ZAddChannelMemberReturns) error {
	if hook, ok := s.impl.(interface {
		AddChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.AddChannelMember(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API AddChannelMember called but not implemented."))
	}
	return nil
}

type ZAddUserToChannelArgs struct {
	A string
	B string
	C string
}

type ZAddUserToChannelReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *apiRPCClient) AddUserToChannel(channelId, userId, asUserId string) (*model.ChannelMember, *model.AppError) {
	_args := &ZAddUserToChannelArgs{channelId, userId, asUserId}
	_returns := &ZAddUserToChannelReturns{}
	if err := g.client.Call("Plugin.AddUserToChannel", _args, _returns); err != nil {
		log.Printf("RPC call to AddUserToChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) AddUserToChannel(args *ZAddUserToChannelArgs, returns *ZAddUserToChannelReturns) error {
	if hook, ok := s.impl.(interface {
		AddUserToChannel(channelId, userId, asUserId string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.AddUserToChannel(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API AddUserToChannel called but not implemented."))
	}
	return nil
}

type ZGetChannelMemberArgs struct {
	A string
	B string
}

type ZGetChannelMemberReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *apiRPCClient) GetChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError) {
	_args := &ZGetChannelMemberArgs{channelId, userId}
	_returns := &ZGetChannelMemberReturns{}
	if err := g.client.Call("Plugin.GetChannelMember", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannelMember API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannelMember(args *ZGetChannelMemberArgs, returns *ZGetChannelMemberReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelMember(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetChannelMember called but not implemented."))
	}
	return nil
}

type ZGetChannelMembersArgs struct {
	A string
	B int
	C int
}

type ZGetChannelMembersReturns struct {
	A *model.ChannelMembers
	B *model.AppError
}

func (g *apiRPCClient) GetChannelMembers(channelId string, page, perPage int) (*model.ChannelMembers, *model.AppError) {
	_args := &ZGetChannelMembersArgs{channelId, page, perPage}
	_returns := &ZGetChannelMembersReturns{}
	if err := g.client.Call("Plugin.GetChannelMembers", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannelMembers API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannelMembers(args *ZGetChannelMembersArgs, returns *ZGetChannelMembersReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelMembers(channelId string, page, perPage int) (*model.ChannelMembers, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelMembers(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetChannelMembers called but not implemented."))
	}
	return nil
}

type ZGetChannelMembersByIdsArgs struct {
	A string
	B []string
}

type ZGetChannelMembersByIdsReturns struct {
	A *model.ChannelMembers
	B *model.AppError
}

func (g *apiRPCClient) GetChannelMembersByIds(channelId string, userIds []string) (*model.ChannelMembers, *model.AppError) {
	_args := &ZGetChannelMembersByIdsArgs{channelId, userIds}
	_returns := &ZGetChannelMembersByIdsReturns{}
	if err := g.client.Call("Plugin.GetChannelMembersByIds", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannelMembersByIds API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannelMembersByIds(args *ZGetChannelMembersByIdsArgs, returns *ZGetChannelMembersByIdsReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelMembersByIds(channelId string, userIds []string) (*model.ChannelMembers, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelMembersByIds(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetChannelMembersByIds called but not implemented."))
	}
	return nil
}

type ZGetChannelMembersForUserArgs struct {
	A string
	B string
	C int
	D int
}

type ZGetChannelMembersForUserReturns struct {
	A []*model.ChannelMember
	B *model.AppError
}

func (g *apiRPCClient) GetChannelMembersForUser(teamId, userId string, page, perPage int) ([]*model.ChannelMember, *model.AppError) {
	_args := &ZGetChannelMembersForUserArgs{teamId, userId, page, perPage}
	_returns := &ZGetChannelMembersForUserReturns{}
	if err := g.client.Call("Plugin.GetChannelMembersForUser", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannelMembersForUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannelMembersForUser(args *ZGetChannelMembersForUserArgs, returns *ZGetChannelMembersForUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelMembersForUser(teamId, userId string, page, perPage int) ([]*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelMembersForUser(args.A, args.B, args.C, args.D)
	} else {
		return encodableError(fmt.Errorf("API GetChannelMembersForUser called but not implemented."))
	}
	return nil
}

type ZUpdateChannelMemberRolesArgs struct {
	A string
	B string
	C string
}

type ZUpdateChannelMemberRolesReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *apiRPCClient) UpdateChannelMemberRoles(channelId, userId, newRoles string) (*model.ChannelMember, *model.AppError) {
	_args := &ZUpdateChannelMemberRolesArgs{channelId, userId, newRoles}
	_returns := &ZUpdateChannelMemberRolesReturns{}
	if err := g.client.Call("Plugin.UpdateChannelMemberRoles", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateChannelMemberRoles API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateChannelMemberRoles(args *ZUpdateChannelMemberRolesArgs, returns *ZUpdateChannelMemberRolesReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateChannelMemberRoles(channelId, userId, newRoles string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateChannelMemberRoles(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API UpdateChannelMemberRoles called but not implemented."))
	}
	return nil
}

type ZUpdateChannelMemberNotificationsArgs struct {
	A string
	B string
	C map[string]string
}

type ZUpdateChannelMemberNotificationsReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *apiRPCClient) UpdateChannelMemberNotifications(channelId, userId string, notifications map[string]string) (*model.ChannelMember, *model.AppError) {
	_args := &ZUpdateChannelMemberNotificationsArgs{channelId, userId, notifications}
	_returns := &ZUpdateChannelMemberNotificationsReturns{}
	if err := g.client.Call("Plugin.UpdateChannelMemberNotifications", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateChannelMemberNotifications API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateChannelMemberNotifications(args *ZUpdateChannelMemberNotificationsArgs, returns *ZUpdateChannelMemberNotificationsReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateChannelMemberNotifications(channelId, userId string, notifications map[string]string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateChannelMemberNotifications(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API UpdateChannelMemberNotifications called but not implemented."))
	}
	return nil
}

type ZGetGroupArgs struct {
	A string
}

type ZGetGroupReturns struct {
	A *model.Group
	B *model.AppError
}

func (g *apiRPCClient) GetGroup(groupId string) (*model.Group, *model.AppError) {
	_args := &ZGetGroupArgs{groupId}
	_returns := &ZGetGroupReturns{}
	if err := g.client.Call("Plugin.GetGroup", _args, _returns); err != nil {
		log.Printf("RPC call to GetGroup API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetGroup(args *ZGetGroupArgs, returns *ZGetGroupReturns) error {
	if hook, ok := s.impl.(interface {
		GetGroup(groupId string) (*model.Group, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetGroup(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetGroup called but not implemented."))
	}
	return nil
}

type ZGetGroupByNameArgs struct {
	A string
}

type ZGetGroupByNameReturns struct {
	A *model.Group
	B *model.AppError
}

func (g *apiRPCClient) GetGroupByName(name string) (*model.Group, *model.AppError) {
	_args := &ZGetGroupByNameArgs{name}
	_returns := &ZGetGroupByNameReturns{}
	if err := g.client.Call("Plugin.GetGroupByName", _args, _returns); err != nil {
		log.Printf("RPC call to GetGroupByName API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetGroupByName(args *ZGetGroupByNameArgs, returns *ZGetGroupByNameReturns) error {
	if hook, ok := s.impl.(interface {
		GetGroupByName(name string) (*model.Group, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetGroupByName(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetGroupByName called but not implemented."))
	}
	return nil
}

type ZGetGroupsForUserArgs struct {
	A string
}

type ZGetGroupsForUserReturns struct {
	A []*model.Group
	B *model.AppError
}

func (g *apiRPCClient) GetGroupsForUser(userId string) ([]*model.Group, *model.AppError) {
	_args := &ZGetGroupsForUserArgs{userId}
	_returns := &ZGetGroupsForUserReturns{}
	if err := g.client.Call("Plugin.GetGroupsForUser", _args, _returns); err != nil {
		log.Printf("RPC call to GetGroupsForUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetGroupsForUser(args *ZGetGroupsForUserArgs, returns *ZGetGroupsForUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetGroupsForUser(userId string) ([]*model.Group, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetGroupsForUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetGroupsForUser called but not implemented."))
	}
	return nil
}

type ZDeleteChannelMemberArgs struct {
	A string
	B string
}

type ZDeleteChannelMemberReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteChannelMember(channelId, userId string) *model.AppError {
	_args := &ZDeleteChannelMemberArgs{channelId, userId}
	_returns := &ZDeleteChannelMemberReturns{}
	if err := g.client.Call("Plugin.DeleteChannelMember", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteChannelMember API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteChannelMember(args *ZDeleteChannelMemberArgs, returns *ZDeleteChannelMemberReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteChannelMember(channelId, userId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteChannelMember(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API DeleteChannelMember called but not implemented."))
	}
	return nil
}

type ZCreatePostArgs struct {
	A *model.Post
}

type ZCreatePostReturns struct {
	A *model.Post
	B *model.AppError
}

func (g *apiRPCClient) CreatePost(post *model.Post) (*model.Post, *model.AppError) {
	_args := &ZCreatePostArgs{post}
	_returns := &ZCreatePostReturns{}
	if err := g.client.Call("Plugin.CreatePost", _args, _returns); err != nil {
		log.Printf("RPC call to CreatePost API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreatePost(args *ZCreatePostArgs, returns *ZCreatePostReturns) error {
	if hook, ok := s.impl.(interface {
		CreatePost(post *model.Post) (*model.Post, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreatePost(args.A)
	} else {
		return encodableError(fmt.Errorf("API CreatePost called but not implemented."))
	}
	return nil
}

type ZAddReactionArgs struct {
	A *model.Reaction
}

type ZAddReactionReturns struct {
	A *model.Reaction
	B *model.AppError
}

func (g *apiRPCClient) AddReaction(reaction *model.Reaction) (*model.Reaction, *model.AppError) {
	_args := &ZAddReactionArgs{reaction}
	_returns := &ZAddReactionReturns{}
	if err := g.client.Call("Plugin.AddReaction", _args, _returns); err != nil {
		log.Printf("RPC call to AddReaction API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) AddReaction(args *ZAddReactionArgs, returns *ZAddReactionReturns) error {
	if hook, ok := s.impl.(interface {
		AddReaction(reaction *model.Reaction) (*model.Reaction, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.AddReaction(args.A)
	} else {
		return encodableError(fmt.Errorf("API AddReaction called but not implemented."))
	}
	return nil
}

type ZRemoveReactionArgs struct {
	A *model.Reaction
}

type ZRemoveReactionReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) RemoveReaction(reaction *model.Reaction) *model.AppError {
	_args := &ZRemoveReactionArgs{reaction}
	_returns := &ZRemoveReactionReturns{}
	if err := g.client.Call("Plugin.RemoveReaction", _args, _returns); err != nil {
		log.Printf("RPC call to RemoveReaction API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) RemoveReaction(args *ZRemoveReactionArgs, returns *ZRemoveReactionReturns) error {
	if hook, ok := s.impl.(interface {
		RemoveReaction(reaction *model.Reaction) *model.AppError
	}); ok {
		returns.A = hook.RemoveReaction(args.A)
	} else {
		return encodableError(fmt.Errorf("API RemoveReaction called but not implemented."))
	}
	return nil
}

type ZGetReactionsArgs struct {
	A string
}

type ZGetReactionsReturns struct {
	A []*model.Reaction
	B *model.AppError
}

func (g *apiRPCClient) GetReactions(postId string) ([]*model.Reaction, *model.AppError) {
	_args := &ZGetReactionsArgs{postId}
	_returns := &ZGetReactionsReturns{}
	if err := g.client.Call("Plugin.GetReactions", _args, _returns); err != nil {
		log.Printf("RPC call to GetReactions API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetReactions(args *ZGetReactionsArgs, returns *ZGetReactionsReturns) error {
	if hook, ok := s.impl.(interface {
		GetReactions(postId string) ([]*model.Reaction, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetReactions(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetReactions called but not implemented."))
	}
	return nil
}

type ZSendEphemeralPostArgs struct {
	A string
	B *model.Post
}

type ZSendEphemeralPostReturns struct {
	A *model.Post
}

func (g *apiRPCClient) SendEphemeralPost(userId string, post *model.Post) *model.Post {
	_args := &ZSendEphemeralPostArgs{userId, post}
	_returns := &ZSendEphemeralPostReturns{}
	if err := g.client.Call("Plugin.SendEphemeralPost", _args, _returns); err != nil {
		log.Printf("RPC call to SendEphemeralPost API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SendEphemeralPost(args *ZSendEphemeralPostArgs, returns *ZSendEphemeralPostReturns) error {
	if hook, ok := s.impl.(interface {
		SendEphemeralPost(userId string, post *model.Post) *model.Post
	}); ok {
		returns.A = hook.SendEphemeralPost(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API SendEphemeralPost called but not implemented."))
	}
	return nil
}

type ZUpdateEphemeralPostArgs struct {
	A string
	B *model.Post
}

type ZUpdateEphemeralPostReturns struct {
	A *model.Post
}

func (g *apiRPCClient) UpdateEphemeralPost(userId string, post *model.Post) *model.Post {
	_args := &ZUpdateEphemeralPostArgs{userId, post}
	_returns := &ZUpdateEphemeralPostReturns{}
	if err := g.client.Call("Plugin.UpdateEphemeralPost", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateEphemeralPost API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) UpdateEphemeralPost(args *ZUpdateEphemeralPostArgs, returns *ZUpdateEphemeralPostReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateEphemeralPost(userId string, post *model.Post) *model.Post
	}); ok {
		returns.A = hook.UpdateEphemeralPost(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API UpdateEphemeralPost called but not implemented."))
	}
	return nil
}

type ZDeleteEphemeralPostArgs struct {
	A string
	B string
}

type ZDeleteEphemeralPostReturns struct {
}

func (g *apiRPCClient) DeleteEphemeralPost(userId, postId string) {
	_args := &ZDeleteEphemeralPostArgs{userId, postId}
	_returns := &ZDeleteEphemeralPostReturns{}
	if err := g.client.Call("Plugin.DeleteEphemeralPost", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteEphemeralPost API failed: %s", err.Error())
	}

}

func (s *apiRPCServer) DeleteEphemeralPost(args *ZDeleteEphemeralPostArgs, returns *ZDeleteEphemeralPostReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteEphemeralPost(userId, postId string)
	}); ok {
		hook.DeleteEphemeralPost(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API DeleteEphemeralPost called but not implemented."))
	}
	return nil
}

type ZDeletePostArgs struct {
	A string
}

type ZDeletePostReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeletePost(postId string) *model.AppError {
	_args := &ZDeletePostArgs{postId}
	_returns := &ZDeletePostReturns{}
	if err := g.client.Call("Plugin.DeletePost", _args, _returns); err != nil {
		log.Printf("RPC call to DeletePost API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeletePost(args *ZDeletePostArgs, returns *ZDeletePostReturns) error {
	if hook, ok := s.impl.(interface {
		DeletePost(postId string) *model.AppError
	}); ok {
		returns.A = hook.DeletePost(args.A)
	} else {
		return encodableError(fmt.Errorf("API DeletePost called but not implemented."))
	}
	return nil
}

type ZGetPostThreadArgs struct {
	A string
}

type ZGetPostThreadReturns struct {
	A *model.PostList
	B *model.AppError
}

func (g *apiRPCClient) GetPostThread(postId string) (*model.PostList, *model.AppError) {
	_args := &ZGetPostThreadArgs{postId}
	_returns := &ZGetPostThreadReturns{}
	if err := g.client.Call("Plugin.GetPostThread", _args, _returns); err != nil {
		log.Printf("RPC call to GetPostThread API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPostThread(args *ZGetPostThreadArgs, returns *ZGetPostThreadReturns) error {
	if hook, ok := s.impl.(interface {
		GetPostThread(postId string) (*model.PostList, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPostThread(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetPostThread called but not implemented."))
	}
	return nil
}

type ZGetPostArgs struct {
	A string
}

type ZGetPostReturns struct {
	A *model.Post
	B *model.AppError
}

func (g *apiRPCClient) GetPost(postId string) (*model.Post, *model.AppError) {
	_args := &ZGetPostArgs{postId}
	_returns := &ZGetPostReturns{}
	if err := g.client.Call("Plugin.GetPost", _args, _returns); err != nil {
		log.Printf("RPC call to GetPost API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPost(args *ZGetPostArgs, returns *ZGetPostReturns) error {
	if hook, ok := s.impl.(interface {
		GetPost(postId string) (*model.Post, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPost(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetPost called but not implemented."))
	}
	return nil
}

type ZGetPostsSinceArgs struct {
	A string
	B int64
}

type ZGetPostsSinceReturns struct {
	A *model.PostList
	B *model.AppError
}

func (g *apiRPCClient) GetPostsSince(channelId string, time int64) (*model.PostList, *model.AppError) {
	_args := &ZGetPostsSinceArgs{channelId, time}
	_returns := &ZGetPostsSinceReturns{}
	if err := g.client.Call("Plugin.GetPostsSince", _args, _returns); err != nil {
		log.Printf("RPC call to GetPostsSince API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPostsSince(args *ZGetPostsSinceArgs, returns *ZGetPostsSinceReturns) error {
	if hook, ok := s.impl.(interface {
		GetPostsSince(channelId string, time int64) (*model.PostList, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPostsSince(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetPostsSince called but not implemented."))
	}
	return nil
}

type ZGetPostsAfterArgs struct {
	A string
	B string
	C int
	D int
}

type ZGetPostsAfterReturns struct {
	A *model.PostList
	B *model.AppError
}

func (g *apiRPCClient) GetPostsAfter(channelId, postId string, page, perPage int) (*model.PostList, *model.AppError) {
	_args := &ZGetPostsAfterArgs{channelId, postId, page, perPage}
	_returns := &ZGetPostsAfterReturns{}
	if err := g.client.Call("Plugin.GetPostsAfter", _args, _returns); err != nil {
		log.Printf("RPC call to GetPostsAfter API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPostsAfter(args *ZGetPostsAfterArgs, returns *ZGetPostsAfterReturns) error {
	if hook, ok := s.impl.(interface {
		GetPostsAfter(channelId, postId string, page, perPage int) (*model.PostList, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPostsAfter(args.A, args.B, args.C, args.D)
	} else {
		return encodableError(fmt.Errorf("API GetPostsAfter called but not implemented."))
	}
	return nil
}

type ZGetPostsBeforeArgs struct {
	A string
	B string
	C int
	D int
}

type ZGetPostsBeforeReturns struct {
	A *model.PostList
	B *model.AppError
}

func (g *apiRPCClient) GetPostsBefore(channelId, postId string, page, perPage int) (*model.PostList, *model.AppError) {
	_args := &ZGetPostsBeforeArgs{channelId, postId, page, perPage}
	_returns := &ZGetPostsBeforeReturns{}
	if err := g.client.Call("Plugin.GetPostsBefore", _args, _returns); err != nil {
		log.Printf("RPC call to GetPostsBefore API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPostsBefore(args *ZGetPostsBeforeArgs, returns *ZGetPostsBeforeReturns) error {
	if hook, ok := s.impl.(interface {
		GetPostsBefore(channelId, postId string, page, perPage int) (*model.PostList, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPostsBefore(args.A, args.B, args.C, args.D)
	} else {
		return encodableError(fmt.Errorf("API GetPostsBefore called but not implemented."))
	}
	return nil
}

type ZGetPostsForChannelArgs struct {
	A string
	B int
	C int
}

type ZGetPostsForChannelReturns struct {
	A *model.PostList
	B *model.AppError
}

func (g *apiRPCClient) GetPostsForChannel(channelId string, page, perPage int) (*model.PostList, *model.AppError) {
	_args := &ZGetPostsForChannelArgs{channelId, page, perPage}
	_returns := &ZGetPostsForChannelReturns{}
	if err := g.client.Call("Plugin.GetPostsForChannel", _args, _returns); err != nil {
		log.Printf("RPC call to GetPostsForChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPostsForChannel(args *ZGetPostsForChannelArgs, returns *ZGetPostsForChannelReturns) error {
	if hook, ok := s.impl.(interface {
		GetPostsForChannel(channelId string, page, perPage int) (*model.PostList, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPostsForChannel(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetPostsForChannel called but not implemented."))
	}
	return nil
}

type ZGetTeamStatsArgs struct {
	A string
}

type ZGetTeamStatsReturns struct {
	A *model.TeamStats
	B *model.AppError
}

func (g *apiRPCClient) GetTeamStats(teamId string) (*model.TeamStats, *model.AppError) {
	_args := &ZGetTeamStatsArgs{teamId}
	_returns := &ZGetTeamStatsReturns{}
	if err := g.client.Call("Plugin.GetTeamStats", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeamStats API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeamStats(args *ZGetTeamStatsArgs, returns *ZGetTeamStatsReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamStats(teamId string) (*model.TeamStats, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamStats(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetTeamStats called but not implemented."))
	}
	return nil
}

type ZUpdatePostArgs struct {
	A *model.Post
}

type ZUpdatePostReturns struct {
	A *model.Post
	B *model.AppError
}

func (g *apiRPCClient) UpdatePost(post *model.Post) (*model.Post, *model.AppError) {
	_args := &ZUpdatePostArgs{post}
	_returns := &ZUpdatePostReturns{}
	if err := g.client.Call("Plugin.UpdatePost", _args, _returns); err != nil {
		log.Printf("RPC call to UpdatePost API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdatePost(args *ZUpdatePostArgs, returns *ZUpdatePostReturns) error {
	if hook, ok := s.impl.(interface {
		UpdatePost(post *model.Post) (*model.Post, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdatePost(args.A)
	} else {
		return encodableError(fmt.Errorf("API UpdatePost called but not implemented."))
	}
	return nil
}

type ZGetProfileImageArgs struct {
	A string
}

type ZGetProfileImageReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) GetProfileImage(userId string) ([]byte, *model.AppError) {
	_args := &ZGetProfileImageArgs{userId}
	_returns := &ZGetProfileImageReturns{}
	if err := g.client.Call("Plugin.GetProfileImage", _args, _returns); err != nil {
		log.Printf("RPC call to GetProfileImage API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetProfileImage(args *ZGetProfileImageArgs, returns *ZGetProfileImageReturns) error {
	if hook, ok := s.impl.(interface {
		GetProfileImage(userId string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetProfileImage(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetProfileImage called but not implemented."))
	}
	return nil
}

type ZSetProfileImageArgs struct {
	A string
	B []byte
}

type ZSetProfileImageReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) SetProfileImage(userId string, data []byte) *model.AppError {
	_args := &ZSetProfileImageArgs{userId, data}
	_returns := &ZSetProfileImageReturns{}
	if err := g.client.Call("Plugin.SetProfileImage", _args, _returns); err != nil {
		log.Printf("RPC call to SetProfileImage API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SetProfileImage(args *ZSetProfileImageArgs, returns *ZSetProfileImageReturns) error {
	if hook, ok := s.impl.(interface {
		SetProfileImage(userId string, data []byte) *model.AppError
	}); ok {
		returns.A = hook.SetProfileImage(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API SetProfileImage called but not implemented."))
	}
	return nil
}

type ZGetEmojiListArgs struct {
	A string
	B int
	C int
}

type ZGetEmojiListReturns struct {
	A []*model.Emoji
	B *model.AppError
}

func (g *apiRPCClient) GetEmojiList(sortBy string, page, perPage int) ([]*model.Emoji, *model.AppError) {
	_args := &ZGetEmojiListArgs{sortBy, page, perPage}
	_returns := &ZGetEmojiListReturns{}
	if err := g.client.Call("Plugin.GetEmojiList", _args, _returns); err != nil {
		log.Printf("RPC call to GetEmojiList API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetEmojiList(args *ZGetEmojiListArgs, returns *ZGetEmojiListReturns) error {
	if hook, ok := s.impl.(interface {
		GetEmojiList(sortBy string, page, perPage int) ([]*model.Emoji, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetEmojiList(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetEmojiList called but not implemented."))
	}
	return nil
}

type ZGetEmojiByNameArgs struct {
	A string
}

type ZGetEmojiByNameReturns struct {
	A *model.Emoji
	B *model.AppError
}

func (g *apiRPCClient) GetEmojiByName(name string) (*model.Emoji, *model.AppError) {
	_args := &ZGetEmojiByNameArgs{name}
	_returns := &ZGetEmojiByNameReturns{}
	if err := g.client.Call("Plugin.GetEmojiByName", _args, _returns); err != nil {
		log.Printf("RPC call to GetEmojiByName API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetEmojiByName(args *ZGetEmojiByNameArgs, returns *ZGetEmojiByNameReturns) error {
	if hook, ok := s.impl.(interface {
		GetEmojiByName(name string) (*model.Emoji, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetEmojiByName(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetEmojiByName called but not implemented."))
	}
	return nil
}

type ZGetEmojiArgs struct {
	A string
}

type ZGetEmojiReturns struct {
	A *model.Emoji
	B *model.AppError
}

func (g *apiRPCClient) GetEmoji(emojiId string) (*model.Emoji, *model.AppError) {
	_args := &ZGetEmojiArgs{emojiId}
	_returns := &ZGetEmojiReturns{}
	if err := g.client.Call("Plugin.GetEmoji", _args, _returns); err != nil {
		log.Printf("RPC call to GetEmoji API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetEmoji(args *ZGetEmojiArgs, returns *ZGetEmojiReturns) error {
	if hook, ok := s.impl.(interface {
		GetEmoji(emojiId string) (*model.Emoji, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetEmoji(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetEmoji called but not implemented."))
	}
	return nil
}

type ZCopyFileInfosArgs struct {
	A string
	B []string
}

type ZCopyFileInfosReturns struct {
	A []string
	B *model.AppError
}

func (g *apiRPCClient) CopyFileInfos(userId string, fileIds []string) ([]string, *model.AppError) {
	_args := &ZCopyFileInfosArgs{userId, fileIds}
	_returns := &ZCopyFileInfosReturns{}
	if err := g.client.Call("Plugin.CopyFileInfos", _args, _returns); err != nil {
		log.Printf("RPC call to CopyFileInfos API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CopyFileInfos(args *ZCopyFileInfosArgs, returns *ZCopyFileInfosReturns) error {
	if hook, ok := s.impl.(interface {
		CopyFileInfos(userId string, fileIds []string) ([]string, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CopyFileInfos(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API CopyFileInfos called but not implemented."))
	}
	return nil
}

type ZGetFileInfoArgs struct {
	A string
}

type ZGetFileInfoReturns struct {
	A *model.FileInfo
	B *model.AppError
}

func (g *apiRPCClient) GetFileInfo(fileId string) (*model.FileInfo, *model.AppError) {
	_args := &ZGetFileInfoArgs{fileId}
	_returns := &ZGetFileInfoReturns{}
	if err := g.client.Call("Plugin.GetFileInfo", _args, _returns); err != nil {
		log.Printf("RPC call to GetFileInfo API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetFileInfo(args *ZGetFileInfoArgs, returns *ZGetFileInfoReturns) error {
	if hook, ok := s.impl.(interface {
		GetFileInfo(fileId string) (*model.FileInfo, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetFileInfo(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetFileInfo called but not implemented."))
	}
	return nil
}

type ZGetFileInfosArgs struct {
	A int
	B int
	C *model.GetFileInfosOptions
}

type ZGetFileInfosReturns struct {
	A []*model.FileInfo
	B *model.AppError
}

func (g *apiRPCClient) GetFileInfos(page, perPage int, opt *model.GetFileInfosOptions) ([]*model.FileInfo, *model.AppError) {
	_args := &ZGetFileInfosArgs{page, perPage, opt}
	_returns := &ZGetFileInfosReturns{}
	if err := g.client.Call("Plugin.GetFileInfos", _args, _returns); err != nil {
		log.Printf("RPC call to GetFileInfos API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetFileInfos(args *ZGetFileInfosArgs, returns *ZGetFileInfosReturns) error {
	if hook, ok := s.impl.(interface {
		GetFileInfos(page, perPage int, opt *model.GetFileInfosOptions) ([]*model.FileInfo, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetFileInfos(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetFileInfos called but not implemented."))
	}
	return nil
}

type ZGetFileArgs struct {
	A string
}

type ZGetFileReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) GetFile(fileId string) ([]byte, *model.AppError) {
	_args := &ZGetFileArgs{fileId}
	_returns := &ZGetFileReturns{}
	if err := g.client.Call("Plugin.GetFile", _args, _returns); err != nil {
		log.Printf("RPC call to GetFile API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetFile(args *ZGetFileArgs, returns *ZGetFileReturns) error {
	if hook, ok := s.impl.(interface {
		GetFile(fileId string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetFile(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetFile called but not implemented."))
	}
	return nil
}

type ZGetFileLinkArgs struct {
	A string
}

type ZGetFileLinkReturns struct {
	A string
	B *model.AppError
}

func (g *apiRPCClient) GetFileLink(fileId string) (string, *model.AppError) {
	_args := &ZGetFileLinkArgs{fileId}
	_returns := &ZGetFileLinkReturns{}
	if err := g.client.Call("Plugin.GetFileLink", _args, _returns); err != nil {
		log.Printf("RPC call to GetFileLink API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetFileLink(args *ZGetFileLinkArgs, returns *ZGetFileLinkReturns) error {
	if hook, ok := s.impl.(interface {
		GetFileLink(fileId string) (string, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetFileLink(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetFileLink called but not implemented."))
	}
	return nil
}

type ZReadFileArgs struct {
	A string
}

type ZReadFileReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) ReadFile(path string) ([]byte, *model.AppError) {
	_args := &ZReadFileArgs{path}
	_returns := &ZReadFileReturns{}
	if err := g.client.Call("Plugin.ReadFile", _args, _returns); err != nil {
		log.Printf("RPC call to ReadFile API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) ReadFile(args *ZReadFileArgs, returns *ZReadFileReturns) error {
	if hook, ok := s.impl.(interface {
		ReadFile(path string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.ReadFile(args.A)
	} else {
		return encodableError(fmt.Errorf("API ReadFile called but not implemented."))
	}
	return nil
}

type ZGetEmojiImageArgs struct {
	A string
}

type ZGetEmojiImageReturns struct {
	A []byte
	B string
	C *model.AppError
}

func (g *apiRPCClient) GetEmojiImage(emojiId string) ([]byte, string, *model.AppError) {
	_args := &ZGetEmojiImageArgs{emojiId}
	_returns := &ZGetEmojiImageReturns{}
	if err := g.client.Call("Plugin.GetEmojiImage", _args, _returns); err != nil {
		log.Printf("RPC call to GetEmojiImage API failed: %s", err.Error())
	}
	return _returns.A, _returns.B, _returns.C
}

func (s *apiRPCServer) GetEmojiImage(args *ZGetEmojiImageArgs, returns *ZGetEmojiImageReturns) error {
	if hook, ok := s.impl.(interface {
		GetEmojiImage(emojiId string) ([]byte, string, *model.AppError)
	}); ok {
		returns.A, returns.B, returns.C = hook.GetEmojiImage(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetEmojiImage called but not implemented."))
	}
	return nil
}

type ZUploadFileArgs struct {
	A []byte
	B string
	C string
}

type ZUploadFileReturns struct {
	A *model.FileInfo
	B *model.AppError
}

func (g *apiRPCClient) UploadFile(data []byte, channelId string, filename string) (*model.FileInfo, *model.AppError) {
	_args := &ZUploadFileArgs{data, channelId, filename}
	_returns := &ZUploadFileReturns{}
	if err := g.client.Call("Plugin.UploadFile", _args, _returns); err != nil {
		log.Printf("RPC call to UploadFile API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UploadFile(args *ZUploadFileArgs, returns *ZUploadFileReturns) error {
	if hook, ok := s.impl.(interface {
		UploadFile(data []byte, channelId string, filename string) (*model.FileInfo, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UploadFile(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API UploadFile called but not implemented."))
	}
	return nil
}

type ZOpenInteractiveDialogArgs struct {
	A model.OpenDialogRequest
}

type ZOpenInteractiveDialogReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) OpenInteractiveDialog(dialog model.OpenDialogRequest) *model.AppError {
	_args := &ZOpenInteractiveDialogArgs{dialog}
	_returns := &ZOpenInteractiveDialogReturns{}
	if err := g.client.Call("Plugin.OpenInteractiveDialog", _args, _returns); err != nil {
		log.Printf("RPC call to OpenInteractiveDialog API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) OpenInteractiveDialog(args *ZOpenInteractiveDialogArgs, returns *ZOpenInteractiveDialogReturns) error {
	if hook, ok := s.impl.(interface {
		OpenInteractiveDialog(dialog model.OpenDialogRequest) *model.AppError
	}); ok {
		returns.A = hook.OpenInteractiveDialog(args.A)
	} else {
		return encodableError(fmt.Errorf("API OpenInteractiveDialog called but not implemented."))
	}
	return nil
}

type ZGetPluginsArgs struct {
}

type ZGetPluginsReturns struct {
	A []*model.Manifest
	B *model.AppError
}

func (g *apiRPCClient) GetPlugins() ([]*model.Manifest, *model.AppError) {
	_args := &ZGetPluginsArgs{}
	_returns := &ZGetPluginsReturns{}
	if err := g.client.Call("Plugin.GetPlugins", _args, _returns); err != nil {
		log.Printf("RPC call to GetPlugins API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPlugins(args *ZGetPluginsArgs, returns *ZGetPluginsReturns) error {
	if hook, ok := s.impl.(interface {
		GetPlugins() ([]*model.Manifest, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPlugins()
	} else {
		return encodableError(fmt.Errorf("API GetPlugins called but not implemented."))
	}
	return nil
}

type ZEnablePluginArgs struct {
	A string
}

type ZEnablePluginReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) EnablePlugin(id string) *model.AppError {
	_args := &ZEnablePluginArgs{id}
	_returns := &ZEnablePluginReturns{}
	if err := g.client.Call("Plugin.EnablePlugin", _args, _returns); err != nil {
		log.Printf("RPC call to EnablePlugin API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) EnablePlugin(args *ZEnablePluginArgs, returns *ZEnablePluginReturns) error {
	if hook, ok := s.impl.(interface {
		EnablePlugin(id string) *model.AppError
	}); ok {
		returns.A = hook.EnablePlugin(args.A)
	} else {
		return encodableError(fmt.Errorf("API EnablePlugin called but not implemented."))
	}
	return nil
}

type ZDisablePluginArgs struct {
	A string
}

type ZDisablePluginReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DisablePlugin(id string) *model.AppError {
	_args := &ZDisablePluginArgs{id}
	_returns := &ZDisablePluginReturns{}
	if err := g.client.Call("Plugin.DisablePlugin", _args, _returns); err != nil {
		log.Printf("RPC call to DisablePlugin API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DisablePlugin(args *ZDisablePluginArgs, returns *ZDisablePluginReturns) error {
	if hook, ok := s.impl.(interface {
		DisablePlugin(id string) *model.AppError
	}); ok {
		returns.A = hook.DisablePlugin(args.A)
	} else {
		return encodableError(fmt.Errorf("API DisablePlugin called but not implemented."))
	}
	return nil
}

type ZRemovePluginArgs struct {
	A string
}

type ZRemovePluginReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) RemovePlugin(id string) *model.AppError {
	_args := &ZRemovePluginArgs{id}
	_returns := &ZRemovePluginReturns{}
	if err := g.client.Call("Plugin.RemovePlugin", _args, _returns); err != nil {
		log.Printf("RPC call to RemovePlugin API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) RemovePlugin(args *ZRemovePluginArgs, returns *ZRemovePluginReturns) error {
	if hook, ok := s.impl.(interface {
		RemovePlugin(id string) *model.AppError
	}); ok {
		returns.A = hook.RemovePlugin(args.A)
	} else {
		return encodableError(fmt.Errorf("API RemovePlugin called but not implemented."))
	}
	return nil
}

type ZGetPluginStatusArgs struct {
	A string
}

type ZGetPluginStatusReturns struct {
	A *model.PluginStatus
	B *model.AppError
}

func (g *apiRPCClient) GetPluginStatus(id string) (*model.PluginStatus, *model.AppError) {
	_args := &ZGetPluginStatusArgs{id}
	_returns := &ZGetPluginStatusReturns{}
	if err := g.client.Call("Plugin.GetPluginStatus", _args, _returns); err != nil {
		log.Printf("RPC call to GetPluginStatus API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPluginStatus(args *ZGetPluginStatusArgs, returns *ZGetPluginStatusReturns) error {
	if hook, ok := s.impl.(interface {
		GetPluginStatus(id string) (*model.PluginStatus, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPluginStatus(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetPluginStatus called but not implemented."))
	}
	return nil
}

type ZKVSetArgs struct {
	A string
	B []byte
}

type ZKVSetReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) KVSet(key string, value []byte) *model.AppError {
	_args := &ZKVSetArgs{key, value}
	_returns := &ZKVSetReturns{}
	if err := g.client.Call("Plugin.KVSet", _args, _returns); err != nil {
		log.Printf("RPC call to KVSet API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) KVSet(args *ZKVSetArgs, returns *ZKVSetReturns) error {
	if hook, ok := s.impl.(interface {
		KVSet(key string, value []byte) *model.AppError
	}); ok {
		returns.A = hook.KVSet(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API KVSet called but not implemented."))
	}
	return nil
}

type ZKVCompareAndSetArgs struct {
	A string
	B []byte
	C []byte
}

type ZKVCompareAndSetReturns struct {
	A bool
	B *model.AppError
}

func (g *apiRPCClient) KVCompareAndSet(key string, oldValue, newValue []byte) (bool, *model.AppError) {
	_args := &ZKVCompareAndSetArgs{key, oldValue, newValue}
	_returns := &ZKVCompareAndSetReturns{}
	if err := g.client.Call("Plugin.KVCompareAndSet", _args, _returns); err != nil {
		log.Printf("RPC call to KVCompareAndSet API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) KVCompareAndSet(args *ZKVCompareAndSetArgs, returns *ZKVCompareAndSetReturns) error {
	if hook, ok := s.impl.(interface {
		KVCompareAndSet(key string, oldValue, newValue []byte) (bool, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVCompareAndSet(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API KVCompareAndSet called but not implemented."))
	}
	return nil
}

type ZKVCompareAndDeleteArgs struct {
	A string
	B []byte
}

type ZKVCompareAndDeleteReturns struct {
	A bool
	B *model.AppError
}

func (g *apiRPCClient) KVCompareAndDelete(key string, oldValue []byte) (bool, *model.AppError) {
	_args := &ZKVCompareAndDeleteArgs{key, oldValue}
	_returns := &ZKVCompareAndDeleteReturns{}
	if err := g.client.Call("Plugin.KVCompareAndDelete", _args, _returns); err != nil {
		log.Printf("RPC call to KVCompareAndDelete API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) KVCompareAndDelete(args *ZKVCompareAndDeleteArgs, returns *ZKVCompareAndDeleteReturns) error {
	if hook, ok := s.impl.(interface {
		KVCompareAndDelete(key string, oldValue []byte) (bool, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVCompareAndDelete(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API KVCompareAndDelete called but not implemented."))
	}
	return nil
}

type ZKVSetWithOptionsArgs struct {
	A string
	B []byte
	C model.PluginKVSetOptions
}

type ZKVSetWithOptionsReturns struct {
	A bool
	B *model.AppError
}

func (g *apiRPCClient) KVSetWithOptions(key string, value []byte, options model.PluginKVSetOptions) (bool, *model.AppError) {
	_args := &ZKVSetWithOptionsArgs{key, value, options}
	_returns := &ZKVSetWithOptionsReturns{}
	if err := g.client.Call("Plugin.KVSetWithOptions", _args, _returns); err != nil {
		log.Printf("RPC call to KVSetWithOptions API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) KVSetWithOptions(args *ZKVSetWithOptionsArgs, returns *ZKVSetWithOptionsReturns) error {
	if hook, ok := s.impl.(interface {
		KVSetWithOptions(key string, value []byte, options model.PluginKVSetOptions) (bool, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVSetWithOptions(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API KVSetWithOptions called but not implemented."))
	}
	return nil
}

type ZKVSetWithExpiryArgs struct {
	A string
	B []byte
	C int64
}

type ZKVSetWithExpiryReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) KVSetWithExpiry(key string, value []byte, expireInSeconds int64) *model.AppError {
	_args := &ZKVSetWithExpiryArgs{key, value, expireInSeconds}
	_returns := &ZKVSetWithExpiryReturns{}
	if err := g.client.Call("Plugin.KVSetWithExpiry", _args, _returns); err != nil {
		log.Printf("RPC call to KVSetWithExpiry API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) KVSetWithExpiry(args *ZKVSetWithExpiryArgs, returns *ZKVSetWithExpiryReturns) error {
	if hook, ok := s.impl.(interface {
		KVSetWithExpiry(key string, value []byte, expireInSeconds int64) *model.AppError
	}); ok {
		returns.A = hook.KVSetWithExpiry(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API KVSetWithExpiry called but not implemented."))
	}
	return nil
}

type ZKVGetArgs struct {
	A string
}

type ZKVGetReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) KVGet(key string) ([]byte, *model.AppError) {
	_args := &ZKVGetArgs{key}
	_returns := &ZKVGetReturns{}
	if err := g.client.Call("Plugin.KVGet", _args, _returns); err != nil {
		log.Printf("RPC call to KVGet API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) KVGet(args *ZKVGetArgs, returns *ZKVGetReturns) error {
	if hook, ok := s.impl.(interface {
		KVGet(key string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVGet(args.A)
	} else {
		return encodableError(fmt.Errorf("API KVGet called but not implemented."))
	}
	return nil
}

type ZKVDeleteArgs struct {
	A string
}

type ZKVDeleteReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) KVDelete(key string) *model.AppError {
	_args := &ZKVDeleteArgs{key}
	_returns := &ZKVDeleteReturns{}
	if err := g.client.Call("Plugin.KVDelete", _args, _returns); err != nil {
		log.Printf("RPC call to KVDelete API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) KVDelete(args *ZKVDeleteArgs, returns *ZKVDeleteReturns) error {
	if hook, ok := s.impl.(interface {
		KVDelete(key string) *model.AppError
	}); ok {
		returns.A = hook.KVDelete(args.A)
	} else {
		return encodableError(fmt.Errorf("API KVDelete called but not implemented."))
	}
	return nil
}

type ZKVDeleteAllArgs struct {
}

type ZKVDeleteAllReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) KVDeleteAll() *model.AppError {
	_args := &ZKVDeleteAllArgs{}
	_returns := &ZKVDeleteAllReturns{}
	if err := g.client.Call("Plugin.KVDeleteAll", _args, _returns); err != nil {
		log.Printf("RPC call to KVDeleteAll API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) KVDeleteAll(args *ZKVDeleteAllArgs, returns *ZKVDeleteAllReturns) error {
	if hook, ok := s.impl.(interface {
		KVDeleteAll() *model.AppError
	}); ok {
		returns.A = hook.KVDeleteAll()
	} else {
		return encodableError(fmt.Errorf("API KVDeleteAll called but not implemented."))
	}
	return nil
}

type ZKVListArgs struct {
	A int
	B int
}

type ZKVListReturns struct {
	A []string
	B *model.AppError
}

func (g *apiRPCClient) KVList(page, perPage int) ([]string, *model.AppError) {
	_args := &ZKVListArgs{page, perPage}
	_returns := &ZKVListReturns{}
	if err := g.client.Call("Plugin.KVList", _args, _returns); err != nil {
		log.Printf("RPC call to KVList API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) KVList(args *ZKVListArgs, returns *ZKVListReturns) error {
	if hook, ok := s.impl.(interface {
		KVList(page, perPage int) ([]string, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVList(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API KVList called but not implemented."))
	}
	return nil
}

type ZPublishWebSocketEventArgs struct {
	A string
	B map[string]interface{}
	C *model.WebsocketBroadcast
}

type ZPublishWebSocketEventReturns struct {
}

func (g *apiRPCClient) PublishWebSocketEvent(event string, payload map[string]interface{}, broadcast *model.WebsocketBroadcast) {
	_args := &ZPublishWebSocketEventArgs{event, payload, broadcast}
	_returns := &ZPublishWebSocketEventReturns{}
	if err := g.client.Call("Plugin.PublishWebSocketEvent", _args, _returns); err != nil {
		log.Printf("RPC call to PublishWebSocketEvent API failed: %s", err.Error())
	}

}

func (s *apiRPCServer) PublishWebSocketEvent(args *ZPublishWebSocketEventArgs, returns *ZPublishWebSocketEventReturns) error {
	if hook, ok := s.impl.(interface {
		PublishWebSocketEvent(event string, payload map[string]interface{}, broadcast *model.WebsocketBroadcast)
	}); ok {
		hook.PublishWebSocketEvent(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API PublishWebSocketEvent called but not implemented."))
	}
	return nil
}

type ZHasPermissionToArgs struct {
	A string
	B *model.Permission
}

type ZHasPermissionToReturns struct {
	A bool
}

func (g *apiRPCClient) HasPermissionTo(userId string, permission *model.Permission) bool {
	_args := &ZHasPermissionToArgs{userId, permission}
	_returns := &ZHasPermissionToReturns{}
	if err := g.client.Call("Plugin.HasPermissionTo", _args, _returns); err != nil {
		log.Printf("RPC call to HasPermissionTo API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) HasPermissionTo(args *ZHasPermissionToArgs, returns *ZHasPermissionToReturns) error {
	if hook, ok := s.impl.(interface {
		HasPermissionTo(userId string, permission *model.Permission) bool
	}); ok {
		returns.A = hook.HasPermissionTo(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API HasPermissionTo called but not implemented."))
	}
	return nil
}

type ZHasPermissionToTeamArgs struct {
	A string
	B string
	C *model.Permission
}

type ZHasPermissionToTeamReturns struct {
	A bool
}

func (g *apiRPCClient) HasPermissionToTeam(userId, teamId string, permission *model.Permission) bool {
	_args := &ZHasPermissionToTeamArgs{userId, teamId, permission}
	_returns := &ZHasPermissionToTeamReturns{}
	if err := g.client.Call("Plugin.HasPermissionToTeam", _args, _returns); err != nil {
		log.Printf("RPC call to HasPermissionToTeam API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) HasPermissionToTeam(args *ZHasPermissionToTeamArgs, returns *ZHasPermissionToTeamReturns) error {
	if hook, ok := s.impl.(interface {
		HasPermissionToTeam(userId, teamId string, permission *model.Permission) bool
	}); ok {
		returns.A = hook.HasPermissionToTeam(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API HasPermissionToTeam called but not implemented."))
	}
	return nil
}

type ZHasPermissionToChannelArgs struct {
	A string
	B string
	C *model.Permission
}

type ZHasPermissionToChannelReturns struct {
	A bool
}

func (g *apiRPCClient) HasPermissionToChannel(userId, channelId string, permission *model.Permission) bool {
	_args := &ZHasPermissionToChannelArgs{userId, channelId, permission}
	_returns := &ZHasPermissionToChannelReturns{}
	if err := g.client.Call("Plugin.HasPermissionToChannel", _args, _returns); err != nil {
		log.Printf("RPC call to HasPermissionToChannel API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) HasPermissionToChannel(args *ZHasPermissionToChannelArgs, returns *ZHasPermissionToChannelReturns) error {
	if hook, ok := s.impl.(interface {
		HasPermissionToChannel(userId, channelId string, permission *model.Permission) bool
	}); ok {
		returns.A = hook.HasPermissionToChannel(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API HasPermissionToChannel called but not implemented."))
	}
	return nil
}

type ZSendMailArgs struct {
	A string
	B string
	C string
}

type ZSendMailReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) SendMail(to, subject, htmlBody string) *model.AppError {
	_args := &ZSendMailArgs{to, subject, htmlBody}
	_returns := &ZSendMailReturns{}
	if err := g.client.Call("Plugin.SendMail", _args, _returns); err != nil {
		log.Printf("RPC call to SendMail API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SendMail(args *ZSendMailArgs, returns *ZSendMailReturns) error {
	if hook, ok := s.impl.(interface {
		SendMail(to, subject, htmlBody string) *model.AppError
	}); ok {
		returns.A = hook.SendMail(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API SendMail called but not implemented."))
	}
	return nil
}

type ZCreateBotArgs struct {
	A *model.Bot
}

type ZCreateBotReturns struct {
	A *model.Bot
	B *model.AppError
}

func (g *apiRPCClient) CreateBot(bot *model.Bot) (*model.Bot, *model.AppError) {
	_args := &ZCreateBotArgs{bot}
	_returns := &ZCreateBotReturns{}
	if err := g.client.Call("Plugin.CreateBot", _args, _returns); err != nil {
		log.Printf("RPC call to CreateBot API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateBot(args *ZCreateBotArgs, returns *ZCreateBotReturns) error {
	if hook, ok := s.impl.(interface {
		CreateBot(bot *model.Bot) (*model.Bot, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateBot(args.A)
	} else {
		return encodableError(fmt.Errorf("API CreateBot called but not implemented."))
	}
	return nil
}

type ZPatchBotArgs struct {
	A string
	B *model.BotPatch
}

type ZPatchBotReturns struct {
	A *model.Bot
	B *model.AppError
}

func (g *apiRPCClient) PatchBot(botUserId string, botPatch *model.BotPatch) (*model.Bot, *model.AppError) {
	_args := &ZPatchBotArgs{botUserId, botPatch}
	_returns := &ZPatchBotReturns{}
	if err := g.client.Call("Plugin.PatchBot", _args, _returns); err != nil {
		log.Printf("RPC call to PatchBot API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) PatchBot(args *ZPatchBotArgs, returns *ZPatchBotReturns) error {
	if hook, ok := s.impl.(interface {
		PatchBot(botUserId string, botPatch *model.BotPatch) (*model.Bot, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.PatchBot(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API PatchBot called but not implemented."))
	}
	return nil
}

type ZGetBotArgs struct {
	A string
	B bool
}

type ZGetBotReturns struct {
	A *model.Bot
	B *model.AppError
}

func (g *apiRPCClient) GetBot(botUserId string, includeDeleted bool) (*model.Bot, *model.AppError) {
	_args := &ZGetBotArgs{botUserId, includeDeleted}
	_returns := &ZGetBotReturns{}
	if err := g.client.Call("Plugin.GetBot", _args, _returns); err != nil {
		log.Printf("RPC call to GetBot API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetBot(args *ZGetBotArgs, returns *ZGetBotReturns) error {
	if hook, ok := s.impl.(interface {
		GetBot(botUserId string, includeDeleted bool) (*model.Bot, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetBot(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetBot called but not implemented."))
	}
	return nil
}

type ZGetBotsArgs struct {
	A *model.BotGetOptions
}

type ZGetBotsReturns struct {
	A []*model.Bot
	B *model.AppError
}

func (g *apiRPCClient) GetBots(options *model.BotGetOptions) ([]*model.Bot, *model.AppError) {
	_args := &ZGetBotsArgs{options}
	_returns := &ZGetBotsReturns{}
	if err := g.client.Call("Plugin.GetBots", _args, _returns); err != nil {
		log.Printf("RPC call to GetBots API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetBots(args *ZGetBotsArgs, returns *ZGetBotsReturns) error {
	if hook, ok := s.impl.(interface {
		GetBots(options *model.BotGetOptions) ([]*model.Bot, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetBots(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetBots called but not implemented."))
	}
	return nil
}

type ZUpdateBotActiveArgs struct {
	A string
	B bool
}

type ZUpdateBotActiveReturns struct {
	A *model.Bot
	B *model.AppError
}

func (g *apiRPCClient) UpdateBotActive(botUserId string, active bool) (*model.Bot, *model.AppError) {
	_args := &ZUpdateBotActiveArgs{botUserId, active}
	_returns := &ZUpdateBotActiveReturns{}
	if err := g.client.Call("Plugin.UpdateBotActive", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateBotActive API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateBotActive(args *ZUpdateBotActiveArgs, returns *ZUpdateBotActiveReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateBotActive(botUserId string, active bool) (*model.Bot, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateBotActive(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API UpdateBotActive called but not implemented."))
	}
	return nil
}

type ZPermanentDeleteBotArgs struct {
	A string
}

type ZPermanentDeleteBotReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) PermanentDeleteBot(botUserId string) *model.AppError {
	_args := &ZPermanentDeleteBotArgs{botUserId}
	_returns := &ZPermanentDeleteBotReturns{}
	if err := g.client.Call("Plugin.PermanentDeleteBot", _args, _returns); err != nil {
		log.Printf("RPC call to PermanentDeleteBot API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) PermanentDeleteBot(args *ZPermanentDeleteBotArgs, returns *ZPermanentDeleteBotReturns) error {
	if hook, ok := s.impl.(interface {
		PermanentDeleteBot(botUserId string) *model.AppError
	}); ok {
		returns.A = hook.PermanentDeleteBot(args.A)
	} else {
		return encodableError(fmt.Errorf("API PermanentDeleteBot called but not implemented."))
	}
	return nil
}

type ZGetBotIconImageArgs struct {
	A string
}

type ZGetBotIconImageReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) GetBotIconImage(botUserId string) ([]byte, *model.AppError) {
	_args := &ZGetBotIconImageArgs{botUserId}
	_returns := &ZGetBotIconImageReturns{}
	if err := g.client.Call("Plugin.GetBotIconImage", _args, _returns); err != nil {
		log.Printf("RPC call to GetBotIconImage API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetBotIconImage(args *ZGetBotIconImageArgs, returns *ZGetBotIconImageReturns) error {
	if hook, ok := s.impl.(interface {
		GetBotIconImage(botUserId string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetBotIconImage(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetBotIconImage called but not implemented."))
	}
	return nil
}

type ZSetBotIconImageArgs struct {
	A string
	B []byte
}

type ZSetBotIconImageReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) SetBotIconImage(botUserId string, data []byte) *model.AppError {
	_args := &ZSetBotIconImageArgs{botUserId, data}
	_returns := &ZSetBotIconImageReturns{}
	if err := g.client.Call("Plugin.SetBotIconImage", _args, _returns); err != nil {
		log.Printf("RPC call to SetBotIconImage API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SetBotIconImage(args *ZSetBotIconImageArgs, returns *ZSetBotIconImageReturns) error {
	if hook, ok := s.impl.(interface {
		SetBotIconImage(botUserId string, data []byte) *model.AppError
	}); ok {
		returns.A = hook.SetBotIconImage(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API SetBotIconImage called but not implemented."))
	}
	return nil
}

type ZDeleteBotIconImageArgs struct {
	A string
}

type ZDeleteBotIconImageReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteBotIconImage(botUserId string) *model.AppError {
	_args := &ZDeleteBotIconImageArgs{botUserId}
	_returns := &ZDeleteBotIconImageReturns{}
	if err := g.client.Call("Plugin.DeleteBotIconImage", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteBotIconImage API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteBotIconImage(args *ZDeleteBotIconImageArgs, returns *ZDeleteBotIconImageReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteBotIconImage(botUserId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteBotIconImage(args.A)
	} else {
		return encodableError(fmt.Errorf("API DeleteBotIconImage called but not implemented."))
	}
	return nil
}

type ZPublishUserTypingArgs struct {
	A string
	B string
	C string
}

type ZPublishUserTypingReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) PublishUserTyping(userId, channelId, parentId string) *model.AppError {
	_args := &ZPublishUserTypingArgs{userId, channelId, parentId}
	_returns := &ZPublishUserTypingReturns{}
	if err := g.client.Call("Plugin.PublishUserTyping", _args, _returns); err != nil {
		log.Printf("RPC call to PublishUserTyping API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) PublishUserTyping(args *ZPublishUserTypingArgs, returns *ZPublishUserTypingReturns) error {
	if hook, ok := s.impl.(interface {
		PublishUserTyping(userId, channelId, parentId string) *model.AppError
	}); ok {
		returns.A = hook.PublishUserTyping(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API PublishUserTyping called but not implemented."))
	}
	return nil
}

type ZCreateCommandArgs struct {
	A *model.Command
}

type ZCreateCommandReturns struct {
	A *model.Command
	B error
}

func (g *apiRPCClient) CreateCommand(cmd *model.Command) (*model.Command, error) {
	_args := &ZCreateCommandArgs{cmd}
	_returns := &ZCreateCommandReturns{}
	if err := g.client.Call("Plugin.CreateCommand", _args, _returns); err != nil {
		log.Printf("RPC call to CreateCommand API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateCommand(args *ZCreateCommandArgs, returns *ZCreateCommandReturns) error {
	if hook, ok := s.impl.(interface {
		CreateCommand(cmd *model.Command) (*model.Command, error)
	}); ok {
		returns.A, returns.B = hook.CreateCommand(args.A)
		returns.B = encodableError(returns.B)
	} else {
		return encodableError(fmt.Errorf("API CreateCommand called but not implemented."))
	}
	return nil
}

type ZListCommandsArgs struct {
	A string
}

type ZListCommandsReturns struct {
	A []*model.Command
	B error
}

func (g *apiRPCClient) ListCommands(teamID string) ([]*model.Command, error) {
	_args := &ZListCommandsArgs{teamID}
	_returns := &ZListCommandsReturns{}
	if err := g.client.Call("Plugin.ListCommands", _args, _returns); err != nil {
		log.Printf("RPC call to ListCommands API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) ListCommands(args *ZListCommandsArgs, returns *ZListCommandsReturns) error {
	if hook, ok := s.impl.(interface {
		ListCommands(teamID string) ([]*model.Command, error)
	}); ok {
		returns.A, returns.B = hook.ListCommands(args.A)
		returns.B = encodableError(returns.B)
	} else {
		return encodableError(fmt.Errorf("API ListCommands called but not implemented."))
	}
	return nil
}

type ZListCustomCommandsArgs struct {
	A string
}

type ZListCustomCommandsReturns struct {
	A []*model.Command
	B error
}

func (g *apiRPCClient) ListCustomCommands(teamID string) ([]*model.Command, error) {
	_args := &ZListCustomCommandsArgs{teamID}
	_returns := &ZListCustomCommandsReturns{}
	if err := g.client.Call("Plugin.ListCustomCommands", _args, _returns); err != nil {
		log.Printf("RPC call to ListCustomCommands API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) ListCustomCommands(args *ZListCustomCommandsArgs, returns *ZListCustomCommandsReturns) error {
	if hook, ok := s.impl.(interface {
		ListCustomCommands(teamID string) ([]*model.Command, error)
	}); ok {
		returns.A, returns.B = hook.ListCustomCommands(args.A)
		returns.B = encodableError(returns.B)
	} else {
		return encodableError(fmt.Errorf("API ListCustomCommands called but not implemented."))
	}
	return nil
}

type ZListPluginCommandsArgs struct {
	A string
}

type ZListPluginCommandsReturns struct {
	A []*model.Command
	B error
}

func (g *apiRPCClient) ListPluginCommands(teamID string) ([]*model.Command, error) {
	_args := &ZListPluginCommandsArgs{teamID}
	_returns := &ZListPluginCommandsReturns{}
	if err := g.client.Call("Plugin.ListPluginCommands", _args, _returns); err != nil {
		log.Printf("RPC call to ListPluginCommands API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) ListPluginCommands(args *ZListPluginCommandsArgs, returns *ZListPluginCommandsReturns) error {
	if hook, ok := s.impl.(interface {
		ListPluginCommands(teamID string) ([]*model.Command, error)
	}); ok {
		returns.A, returns.B = hook.ListPluginCommands(args.A)
		returns.B = encodableError(returns.B)
	} else {
		return encodableError(fmt.Errorf("API ListPluginCommands called but not implemented."))
	}
	return nil
}

type ZListBuiltInCommandsArgs struct {
}

type ZListBuiltInCommandsReturns struct {
	A []*model.Command
	B error
}

func (g *apiRPCClient) ListBuiltInCommands() ([]*model.Command, error) {
	_args := &ZListBuiltInCommandsArgs{}
	_returns := &ZListBuiltInCommandsReturns{}
	if err := g.client.Call("Plugin.ListBuiltInCommands", _args, _returns); err != nil {
		log.Printf("RPC call to ListBuiltInCommands API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) ListBuiltInCommands(args *ZListBuiltInCommandsArgs, returns *ZListBuiltInCommandsReturns) error {
	if hook, ok := s.impl.(interface {
		ListBuiltInCommands() ([]*model.Command, error)
	}); ok {
		returns.A, returns.B = hook.ListBuiltInCommands()
		returns.B = encodableError(returns.B)
	} else {
		return encodableError(fmt.Errorf("API ListBuiltInCommands called but not implemented."))
	}
	return nil
}

type ZGetCommandArgs struct {
	A string
}

type ZGetCommandReturns struct {
	A *model.Command
	B error
}

func (g *apiRPCClient) GetCommand(commandID string) (*model.Command, error) {
	_args := &ZGetCommandArgs{commandID}
	_returns := &ZGetCommandReturns{}
	if err := g.client.Call("Plugin.GetCommand", _args, _returns); err != nil {
		log.Printf("RPC call to GetCommand API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetCommand(args *ZGetCommandArgs, returns *ZGetCommandReturns) error {
	if hook, ok := s.impl.(interface {
		GetCommand(commandID string) (*model.Command, error)
	}); ok {
		returns.A, returns.B = hook.GetCommand(args.A)
		returns.B = encodableError(returns.B)
	} else {
		return encodableError(fmt.Errorf("API GetCommand called but not implemented."))
	}
	return nil
}

type ZUpdateCommandArgs struct {
	A string
	B *model.Command
}

type ZUpdateCommandReturns struct {
	A *model.Command
	B error
}

func (g *apiRPCClient) UpdateCommand(commandID string, updatedCmd *model.Command) (*model.Command, error) {
	_args := &ZUpdateCommandArgs{commandID, updatedCmd}
	_returns := &ZUpdateCommandReturns{}
	if err := g.client.Call("Plugin.UpdateCommand", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateCommand API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateCommand(args *ZUpdateCommandArgs, returns *ZUpdateCommandReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateCommand(commandID string, updatedCmd *model.Command) (*model.Command, error)
	}); ok {
		returns.A, returns.B = hook.UpdateCommand(args.A, args.B)
		returns.B = encodableError(returns.B)
	} else {
		return encodableError(fmt.Errorf("API UpdateCommand called but not implemented."))
	}
	return nil
}

type ZDeleteCommandArgs struct {
	A string
}

type ZDeleteCommandReturns struct {
	A error
}

func (g *apiRPCClient) DeleteCommand(commandID string) error {
	_args := &ZDeleteCommandArgs{commandID}
	_returns := &ZDeleteCommandReturns{}
	if err := g.client.Call("Plugin.DeleteCommand", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteCommand API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteCommand(args *ZDeleteCommandArgs, returns *ZDeleteCommandReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteCommand(commandID string) error
	}); ok {
		returns.A = hook.DeleteCommand(args.A)
		returns.A = encodableError(returns.A)
	} else {
		return encodableError(fmt.Errorf("API DeleteCommand called but not implemented."))
	}
	return nil
}
