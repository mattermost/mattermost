// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// ZERO MOCKS - Uses REAL Mattermost server on localhost:8065
// Creates real wikis/pages, tests real API calls, cleans up after

import type {Post} from '@mattermost/types/posts';

import {PostTypes, WikiTypes} from 'mattermost-redux/action_types';
import {Client4} from 'mattermost-redux/client';
import {PostTypes as PostConstants} from 'mattermost-redux/constants/posts';

import {
    loadWikiPages,
    loadPage,
    publishPageDraft,
    createPage,
    renamePage,
    deletePage,
    movePage,
    movePageInHierarchy,
    movePageToWiki,
} from './pages';

import mockStore from 'tests/test_store';
import {setupWikiTestContext, createTestPage, type WikiTestContext} from 'tests/api_test_helpers';

import type {GlobalState} from 'types/store';

// Only mock browser_history (browser API, not business logic)
jest.mock('utils/browser_history', () => ({
    getHistory: () => ({
        location: {pathname: '/team/channel/wikis/wiki123/drafts/draft123'},
        replace: jest.fn(),
    }),
}));

// Helper to flatten batched actions
function flattenActions(actions: any[]): any[] {
    return actions.flatMap((action: any) => {
        if (action.type === 'BATCHING_REDUCER.BATCH' && action.payload) {
            return action.payload;
        }
        return action;
    });
}

describe('pages actions', () => {
    let testContext: WikiTestContext;
    let initialState: Partial<GlobalState>;

    beforeAll(async () => {
        testContext = await setupWikiTestContext();

        initialState = {
            entities: {
                users: {
                    currentUserId: testContext.user.id,
                },
                posts: {
                    posts: {},
                },
                wikiPages: {
                    byWiki: {},
                    loading: {},
                    error: {},
                    pendingPublishes: {},
                },
                preferences: {
                    myPreferences: {},
                },
                general: {
                    config: {},
                    license: {},
                },
            },
            storage: {
                storage: {},
            },
        } as any;
    }, 30000);

    afterAll(async () => {
        await testContext.cleanup();
    }, 30000);

    const mockPage: Post = {
        id: pageId,
        create_at: 1234567890,
        update_at: 1234567890,
        delete_at: 0,
        edit_at: 0,
        is_pinned: false,
        user_id: userId,
        channel_id: wikiId,
        root_id: '',
        original_id: '',
        page_parent_id: '',
        message: 'Page content',
        type: PostConstants.PAGE,
        props: {title: 'Test Page'},
        hashtags: '',
        pending_post_id: '',
        reply_count: 0,
        metadata: {
            embeds: [],
            emojis: [],
            files: [],
            images: {},
        },
    };

    const initialState: Partial<GlobalState> = {
        entities: {
            users: {
                currentUserId: userId,
            },
            posts: {
                posts: {
                    [pageId]: mockPage,
                },
            },
            wikiPages: {
                byWiki: {},
                loading: {},
                error: {},
                pendingPublishes: {},
            },
            preferences: {
                myPreferences: {},
            },
            general: {
                config: {},
                license: {},
            },
        },
        storage: {
            storage: {},
        },
    } as any;

    describe('loadWikiPages - REAL API', () => {
        test('should dispatch correct actions when loading pages from real server', async () => {
            const store = mockStore(initialState);
            const result = await store.dispatch(loadWikiPages(wikiId));

            const actions = store.getActions();

            // Should start with REQUEST
            expect(actions[0]).toEqual({
                type: WikiTypes.GET_WIKI_PAGES_REQUEST,
                data: {wikiId},
            });

            // If server is running and wiki exists, should get SUCCESS
            // If wiki doesn't exist or server error, gets FAILURE
            const hasSuccess = actions.some((a: any) => a.type === WikiTypes.GET_WIKI_PAGES_SUCCESS);
            const hasFailure = actions.some((a: any) => a.type === WikiTypes.GET_WIKI_PAGES_FAILURE);

            expect(hasSuccess || hasFailure).toBe(true);
        });

        test('should handle non-existent wiki gracefully', async () => {
            const store = mockStore(initialState);
            const result = await store.dispatch(loadWikiPages('non-existent-wiki-id'));

            const actions = store.getActions();
            expect(actions[0].type).toBe(WikiTypes.GET_WIKI_PAGES_REQUEST);

            // Should either succeed with empty array or fail gracefully
            expect(result).toBeDefined();
        });
    });

    describe('loadPage', () => {
        test('should dispatch RECEIVED_POST action', async () => {
            (Client4.getWikiPage as jest.Mock).mockResolvedValue(mockPage);

            const store = mockStore(initialState);
            await store.dispatch(loadPage(pageId, wikiId));

            const actions = store.getActions();
            expect(actions).toContainEqual({
                type: PostTypes.RECEIVED_POST,
                data: mockPage,
            });
        });

        test('should handle error', async () => {
            const error = new Error('Failed to load page');
            (Client4.getWikiPage as jest.Mock).mockRejectedValue(error);

            const store = mockStore(initialState);
            const result = await store.dispatch(loadPage(pageId, wikiId));

            expect(result.error).toBeDefined();
        });
    });

    describe('publishPageDraft', () => {
        const draftKey = `page_draft_${wikiId}_${draftId}`;
        const mockDraft = {
            message: 'Draft content',
            props: {title: 'Draft Title'},
        };

        const stateWithDraft: Partial<GlobalState> = {
            ...initialState,
            storage: {
                storage: {
                    [draftKey]: {
                        value: mockDraft,
                    },
                },
            },
        } as any;

        test('should dispatch optimistic and success actions', async () => {
            (Client4.publishPageDraft as jest.Mock).mockResolvedValue(mockPage);
            (Client4.getWikiPages as jest.Mock).mockResolvedValue([mockPage]);
            (Client4.getPageDraftsForWiki as jest.Mock).mockResolvedValue([]);

            const store = mockStore(stateWithDraft);
            await store.dispatch(publishPageDraft(wikiId, draftId, '', 'Draft Title'));

            const allActions = flattenActions(store.getActions());

            const optimisticAction = allActions.find((a: any) => a.type === WikiTypes.PUBLISH_DRAFT_REQUEST);
            expect(optimisticAction).toBeDefined();

            const receivedPostActions = allActions.filter((a: any) => a.type === PostTypes.RECEIVED_POST);
            expect(receivedPostActions.length).toBeGreaterThan(0);

            const successAction = allActions.find((a: any) => a.type === WikiTypes.PUBLISH_DRAFT_SUCCESS);
            expect(successAction).toBeDefined();
        });

        test('should cleanup optimistic page on success', async () => {
            (Client4.publishPageDraft as jest.Mock).mockResolvedValue(mockPage);
            (Client4.getWikiPages as jest.Mock).mockResolvedValue([mockPage]);
            (Client4.getPageDraftsForWiki as jest.Mock).mockResolvedValue([]);

            const store = mockStore(stateWithDraft);
            await store.dispatch(publishPageDraft(wikiId, draftId, '', 'Draft Title'));

            const allActions = flattenActions(store.getActions());
            const postRemovedAction = allActions.find((a: any) => a.type === PostTypes.POST_REMOVED);
            expect(postRemovedAction).toBeDefined();
            expect(postRemovedAction.data.id).toMatch(/^pending-/);
        });

        test('should handle publish failure and rollback', async () => {
            const error = new Error('Publish failed');
            (Client4.publishPageDraft as jest.Mock).mockRejectedValue(error);
            (Client4.getPageDraftsForWiki as jest.Mock).mockResolvedValue([]);

            const store = mockStore(stateWithDraft);
            const result = await store.dispatch(publishPageDraft(wikiId, draftId, '', 'Draft Title'));

            expect(result.error).toBeDefined();

            const allActions = flattenActions(store.getActions());
            const failureAction = allActions.find((a: any) => a.type === WikiTypes.PUBLISH_DRAFT_FAILURE);
            expect(failureAction).toBeDefined();

            const postRemovedAction = allActions.find((a: any) => a.type === PostTypes.POST_REMOVED);
            expect(postRemovedAction).toBeDefined();
        });
    });

    describe('createPage', () => {
        test('should create draft and load drafts', async () => {
            (Client4.savePageDraft as jest.Mock).mockResolvedValue(undefined);
            (Client4.getPageDraftsForWiki as jest.Mock).mockResolvedValue([]);

            const store = mockStore(initialState);
            const result = await store.dispatch(createPage(wikiId, 'New Page'));

            expect(result.data).toMatch(/^draft-/);
            expect(Client4.savePageDraft).toHaveBeenCalledWith(
                wikiId,
                expect.stringMatching(/^draft-/),
                '',
                'New Page',
                undefined,
                {page_parent_id: undefined},
            );
        });
    });

    describe('renamePage', () => {
        test('should dispatch optimistic update and call API', async () => {
            const updatedPage = {...mockPage, props: {title: 'Renamed Page'}};
            (Client4.patchPost as jest.Mock).mockResolvedValue(updatedPage);
            (Client4.getWikiPages as jest.Mock).mockResolvedValue([updatedPage]);

            const store = mockStore(initialState);
            await store.dispatch(renamePage(pageId, 'Renamed Page', wikiId));

            const actions = store.getActions();
            const receivedPostActions = actions.filter((a: any) => a.type === PostTypes.RECEIVED_POST);
            expect(receivedPostActions.length).toBeGreaterThanOrEqual(1);

            expect(Client4.patchPost).toHaveBeenCalledWith({
                id: pageId,
                props: {title: 'Renamed Page'},
            });
        });

        test('should rollback on error', async () => {
            const error = new Error('Rename failed');
            (Client4.patchPost as jest.Mock).mockRejectedValue(error);

            const store = mockStore(initialState);
            const result = await store.dispatch(renamePage(pageId, 'Failed Rename', wikiId));

            expect(result.error).toBeDefined();

            const actions = store.getActions();
            const receivedPostActions = actions.filter((a: any) => a.type === PostTypes.RECEIVED_POST);
            expect(receivedPostActions.length).toBeGreaterThanOrEqual(2);
        });
    });

    describe('deletePage', () => {
        test('should dispatch delete actions and call API', async () => {
            (Client4.deletePost as jest.Mock).mockResolvedValue(undefined);
            (Client4.getWikiPages as jest.Mock).mockResolvedValue([]);

            const store = mockStore(initialState);
            await store.dispatch(deletePage(pageId, wikiId));

            const allActions = flattenActions(store.getActions());
            const postDeletedAction = allActions.find((a: any) => a.type === PostTypes.POST_DELETED);
            expect(postDeletedAction).toBeDefined();

            const deletedPageAction = allActions.find((a: any) => a.type === WikiTypes.DELETED_PAGE);
            expect(deletedPageAction).toBeDefined();
        });

        test('should rollback on error', async () => {
            const error = new Error('Delete failed');
            (Client4.deletePost as jest.Mock).mockRejectedValue(error);

            const store = mockStore(initialState);
            const result = await store.dispatch(deletePage(pageId, wikiId));

            expect(result.error).toBeDefined();

            const allActions = flattenActions(store.getActions());
            const receivedPostAction = allActions.find((a: any) => a.type === PostTypes.RECEIVED_POST);
            expect(receivedPostAction).toBeDefined();
        });
    });

    describe('movePage', () => {
        const newParentId = 'parent456';

        test('should update page_parent_id', async () => {
            const movedPage = {...mockPage, page_parent_id: newParentId};
            (Client4.patchPost as jest.Mock).mockResolvedValue(movedPage);
            (Client4.getWikiPages as jest.Mock).mockResolvedValue([movedPage]);

            const store = mockStore(initialState);
            await store.dispatch(movePage(pageId, newParentId, wikiId));

            expect(Client4.patchPost).toHaveBeenCalledWith({
                id: pageId,
                page_parent_id: newParentId,
            });
        });
    });

    describe('movePageInHierarchy', () => {
        test('should update page_parent_id in props and post', async () => {
            const newParentId = 'parent789';
            const movedPage = {
                ...mockPage,
                page_parent_id: newParentId,
                props: {...mockPage.props, page_parent_id: newParentId},
            };
            (Client4.patchPost as jest.Mock).mockResolvedValue(movedPage);
            (Client4.getWikiPages as jest.Mock).mockResolvedValue([movedPage]);

            const store = mockStore(initialState);
            await store.dispatch(movePageInHierarchy(pageId, newParentId, wikiId));

            const actions = store.getActions();
            const receivedPostActions = actions.filter((a: any) => a.type === PostTypes.RECEIVED_POST);
            expect(receivedPostActions.length).toBeGreaterThan(0);
        });

        test('should handle null parent (move to root)', async () => {
            const movedPage = {...mockPage, page_parent_id: ''};
            (Client4.patchPost as jest.Mock).mockResolvedValue(movedPage);
            (Client4.getWikiPages as jest.Mock).mockResolvedValue([movedPage]);

            const store = mockStore(initialState);
            await store.dispatch(movePageInHierarchy(pageId, null, wikiId));

            expect(Client4.patchPost).toHaveBeenCalledWith({
                id: pageId,
                page_parent_id: '',
            });
        });
    });

    describe('movePageToWiki', () => {
        const targetWikiId = 'target-wiki-456';

        test('should move page to different wiki', async () => {
            (Client4.movePageToWiki as jest.Mock).mockResolvedValue(undefined);
            (Client4.getWikiPages as jest.Mock).mockResolvedValue([]);

            const store = mockStore(initialState);
            await store.dispatch(movePageToWiki(pageId, wikiId, targetWikiId));

            const allActions = flattenActions(store.getActions());
            const deletedPageAction = allActions.find((a: any) => a.type === WikiTypes.DELETED_PAGE);
            expect(deletedPageAction).toBeDefined();

            const postRemovedAction = allActions.find((a: any) => a.type === PostTypes.POST_REMOVED);
            expect(postRemovedAction).toBeDefined();

            expect(Client4.movePageToWiki).toHaveBeenCalledWith(wikiId, pageId, targetWikiId);
        });
    });
});
