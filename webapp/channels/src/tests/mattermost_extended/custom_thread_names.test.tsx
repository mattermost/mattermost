// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/**
 * Tests for CustomThreadNames feature flag
 *
 * CustomThreadNames: Allow users to set custom names for threads from the thread header
 *
 * This tests the core logic used by ThreadView and ThreadPane components for custom thread names.
 */

import type {UserThread} from '@mattermost/types/threads';

import {cleanMessageForDisplay} from 'components/threading/utils';

describe('CustomThreadNames feature', () => {
    describe('config mapping', () => {
        it('should map FeatureFlagCustomThreadNames config to boolean', () => {
            const configEnabled = {FeatureFlagCustomThreadNames: 'true'};
            const configDisabled = {FeatureFlagCustomThreadNames: 'false'};
            const configMissing = {};

            expect(configEnabled.FeatureFlagCustomThreadNames === 'true').toBe(true);
            expect(configDisabled.FeatureFlagCustomThreadNames === 'true').toBe(false);
            expect((configMissing as Record<string, string>).FeatureFlagCustomThreadNames === 'true').toBe(false);
        });

        it('should work independently of ThreadsInSidebar', () => {
            // CustomThreadNames can be enabled even if ThreadsInSidebar is disabled
            const threadsInSidebarEnabled = false;
            const customThreadNamesEnabled = true;

            // The feature should be active based only on its own flag
            expect(customThreadNamesEnabled).toBe(true);
            expect(threadsInSidebarEnabled).toBe(false);
        });
    });

    describe('thread name resolution', () => {
        const createMockThread = (overrides: Partial<UserThread> = {}): UserThread => ({
            id: 'thread_id_1',
            reply_count: 5,
            last_reply_at: Date.now(),
            last_viewed_at: Date.now(),
            participants: [],
            post: {
                channel_id: 'channel_id_1',
                user_id: 'user_id_1',
            },
            unread_replies: 0,
            unread_mentions: 0,
            is_following: true,
            is_urgent: false,
            ...overrides,
        });

        it('should use custom_name from thread props when set', () => {
            const thread = createMockThread({
                props: {custom_name: 'My Custom Thread Name'},
            });
            const rootPostMessage = 'Original post message';

            // Logic from thread_view.tsx
            const customThreadName = thread?.props?.custom_name;
            const autoGeneratedName = cleanMessageForDisplay(rootPostMessage, 30);
            const threadName = customThreadName || autoGeneratedName;

            expect(threadName).toBe('My Custom Thread Name');
        });

        it('should fall back to auto-generated name when no custom name', () => {
            const thread = createMockThread();
            const rootPostMessage = 'This is the original post';

            const customThreadName = thread?.props?.custom_name;
            const autoGeneratedName = cleanMessageForDisplay(rootPostMessage, 30);
            const threadName = customThreadName || autoGeneratedName;

            expect(threadName).toBe('This is the original post');
        });

        it('should prefer custom name over auto-generated name', () => {
            const thread = createMockThread({
                props: {custom_name: 'Custom'},
            });
            const rootPostMessage = 'Auto-generated would be this';

            const customThreadName = thread?.props?.custom_name;
            const autoGeneratedName = cleanMessageForDisplay(rootPostMessage, 30);
            const threadName = customThreadName || autoGeneratedName;

            expect(threadName).toBe('Custom');
            expect(threadName).not.toBe(autoGeneratedName);
        });

        it('should handle empty custom name as falsy (use auto-generated)', () => {
            const thread = createMockThread({
                props: {custom_name: ''},
            });
            const rootPostMessage = 'Fallback message';

            const customThreadName = thread?.props?.custom_name;
            const autoGeneratedName = cleanMessageForDisplay(rootPostMessage, 30);
            const threadName = customThreadName || autoGeneratedName;

            expect(threadName).toBe('Fallback message');
        });
    });

    describe('edit state management', () => {
        it('should start editing with existing custom name', () => {
            const thread = {props: {custom_name: 'Existing Name'}};
            let isEditingName = false;
            let editedName = '';

            // Simulate startEditingName callback from thread_view.tsx
            const startEditingName = () => {
                const currentCustomName = thread?.props?.custom_name || '';
                editedName = currentCustomName;
                isEditingName = true;
            };

            startEditingName();

            expect(isEditingName).toBe(true);
            expect(editedName).toBe('Existing Name');
        });

        it('should start editing with empty string when no custom name', () => {
            const thread = {props: {}};
            let isEditingName = false;
            let editedName = '';

            const startEditingName = () => {
                const currentCustomName = (thread?.props as Record<string, string>)?.custom_name || '';
                editedName = currentCustomName;
                isEditingName = true;
            };

            startEditingName();

            expect(isEditingName).toBe(true);
            expect(editedName).toBe('');
        });

        it('should cancel editing and reset state', () => {
            let isEditingName = true;
            let editedName = 'Some edited value';

            // Simulate cancelEditingName callback
            const cancelEditingName = () => {
                isEditingName = false;
                editedName = '';
            };

            cancelEditingName();

            expect(isEditingName).toBe(false);
            expect(editedName).toBe('');
        });
    });

    describe('save thread name logic', () => {
        it('should create props with custom_name when name is provided', () => {
            const editedName = 'New Thread Name';

            // Logic from saveThreadName in thread_view.tsx
            const trimmedName = editedName.trim();
            const newProps = trimmedName ? {custom_name: trimmedName} : {custom_name: undefined};

            expect(newProps).toEqual({custom_name: 'New Thread Name'});
        });

        it('should clear custom_name when empty string is saved', () => {
            const editedName = '';

            const trimmedName = editedName.trim();
            const newProps = trimmedName ? {custom_name: trimmedName} : {custom_name: undefined};

            expect(newProps).toEqual({custom_name: undefined});
        });

        it('should trim whitespace from name', () => {
            const editedName = '  Trimmed Name  ';

            const trimmedName = editedName.trim();
            const newProps = trimmedName ? {custom_name: trimmedName} : {custom_name: undefined};

            expect(newProps).toEqual({custom_name: 'Trimmed Name'});
        });

        it('should clear custom_name when only whitespace is saved', () => {
            const editedName = '   ';

            const trimmedName = editedName.trim();
            const newProps = trimmedName ? {custom_name: trimmedName} : {custom_name: undefined};

            expect(newProps).toEqual({custom_name: undefined});
        });
    });

    describe('keyboard handling', () => {
        it('should save on Enter key', () => {
            let saved = false;
            let cancelled = false;

            const handleKeyDown = (key: string) => {
                if (key === 'Enter') {
                    saved = true;
                } else if (key === 'Escape') {
                    cancelled = true;
                }
            };

            handleKeyDown('Enter');

            expect(saved).toBe(true);
            expect(cancelled).toBe(false);
        });

        it('should cancel on Escape key', () => {
            let saved = false;
            let cancelled = false;

            const handleKeyDown = (key: string) => {
                if (key === 'Enter') {
                    saved = true;
                } else if (key === 'Escape') {
                    cancelled = true;
                }
            };

            handleKeyDown('Escape');

            expect(saved).toBe(false);
            expect(cancelled).toBe(true);
        });

        it('should ignore other keys', () => {
            let saved = false;
            let cancelled = false;

            const handleKeyDown = (key: string) => {
                if (key === 'Enter') {
                    saved = true;
                } else if (key === 'Escape') {
                    cancelled = true;
                }
            };

            handleKeyDown('Tab');
            handleKeyDown('a');
            handleKeyDown('Space');

            expect(saved).toBe(false);
            expect(cancelled).toBe(false);
        });
    });

    describe('UI state based on feature flag', () => {
        it('should allow editing when CustomThreadNames is enabled', () => {
            const isCustomThreadNamesEnabled = true;

            // Simulate the click handler condition from thread_view.tsx
            const onClickHandler = isCustomThreadNamesEnabled ? () => 'start-editing' : undefined;

            expect(onClickHandler).toBeDefined();
            expect(onClickHandler!()).toBe('start-editing');
        });

        it('should NOT allow editing when CustomThreadNames is disabled', () => {
            const isCustomThreadNamesEnabled = false;

            const onClickHandler = isCustomThreadNamesEnabled ? () => 'start-editing' : undefined;

            expect(onClickHandler).toBeUndefined();
        });

        it('should add editable class when feature is enabled', () => {
            const isCustomThreadNamesEnabled = true;

            // Simulate classNames logic from thread_view.tsx
            const headerTextClasses = {
                'ThreadView__header-text': true,
                'ThreadView__header-text--editable': isCustomThreadNamesEnabled,
            };

            expect(headerTextClasses['ThreadView__header-text--editable']).toBe(true);
        });

        it('should NOT add editable class when feature is disabled', () => {
            const isCustomThreadNamesEnabled = false;

            const headerTextClasses = {
                'ThreadView__header-text': true,
                'ThreadView__header-text--editable': isCustomThreadNamesEnabled,
            };

            expect(headerTextClasses['ThreadView__header-text--editable']).toBe(false);
        });

        it('should show pencil icon only when feature is enabled', () => {
            const isCustomThreadNamesEnabled = true;

            // Simulate the conditional rendering from thread_view.tsx
            const showPencilIcon = isCustomThreadNamesEnabled;

            expect(showPencilIcon).toBe(true);
        });

        it('should NOT show pencil icon when feature is disabled', () => {
            const isCustomThreadNamesEnabled = false;

            const showPencilIcon = isCustomThreadNamesEnabled;

            expect(showPencilIcon).toBe(false);
        });
    });

    describe('patchThread API call format', () => {
        it('should format props correctly for setting custom name', () => {
            const threadId = 'thread_123';
            const newName = 'My New Thread Name';

            // Expected format for patchThread action
            const patchPayload = {
                props: {custom_name: newName},
            };

            expect(patchPayload.props.custom_name).toBe('My New Thread Name');
        });

        it('should format props correctly for clearing custom name', () => {
            const threadId = 'thread_123';

            // Expected format for clearing custom name
            const patchPayload = {
                props: {custom_name: undefined},
            };

            expect(patchPayload.props.custom_name).toBeUndefined();
        });
    });

    describe('ThreadsInSidebar integration', () => {
        it('should only show enhanced header when ThreadsInSidebar is enabled', () => {
            const isThreadsInSidebarEnabled = true;
            const isCustomThreadNamesEnabled = true;

            // The enhanced header (with edit capability) is only shown when ThreadsInSidebar is enabled
            // From thread_view.tsx: if (isThreadsInSidebarEnabled) { renderEnhancedHeading() }
            const showEnhancedHeader = isThreadsInSidebarEnabled;
            const canEditName = showEnhancedHeader && isCustomThreadNamesEnabled;

            expect(showEnhancedHeader).toBe(true);
            expect(canEditName).toBe(true);
        });

        it('should show simple header when ThreadsInSidebar is disabled', () => {
            const isThreadsInSidebarEnabled = false;
            const isCustomThreadNamesEnabled = true;

            // Even if CustomThreadNames is enabled, the edit UI requires ThreadsInSidebar
            const showEnhancedHeader = isThreadsInSidebarEnabled;
            const canEditName = showEnhancedHeader && isCustomThreadNamesEnabled;

            expect(showEnhancedHeader).toBe(false);
            expect(canEditName).toBe(false);
        });

        it('should show enhanced header without edit when only ThreadsInSidebar is enabled', () => {
            const isThreadsInSidebarEnabled = true;
            const isCustomThreadNamesEnabled = false;

            const showEnhancedHeader = isThreadsInSidebarEnabled;
            const canEditName = showEnhancedHeader && isCustomThreadNamesEnabled;

            expect(showEnhancedHeader).toBe(true);
            expect(canEditName).toBe(false);
        });
    });
});
