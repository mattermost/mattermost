# Web App Style Guide

## Introduction

This is the style guide for the Mattermost Web App. It establishes strict rules and more general recommendations for how code in the app should be written. It also builds on the rules enforced by automated tooling by establishing how our code should be written in cases which either cannot be enforced by that tooling or in cases where there's room for developer discretion.

### Automated style checking and linting

Whenever possible, we should use automated tooling (ESLint for our JavaScript/TypeScript code and Stylelint for our CSS/SCSS code) to enforce code style rules and linter checks. By making those automated, they can be enforced automatically by CI and developers' editors. That makes it easier to ensure that those checks are always applied without giving reviewers extra work, and it makes sure that they are applied evenly across the code base.

### Application of guidelines

The following guidelines should be applied to both new and existing code. However, this does not mean that a developer is *required* to fix any surrounding code that contravenes the rules in the style guide. It's encouraged to keep fixing things as you go, but it's not compulsory to do so. Reviewers should refrain from asking for stylistic changes in surrounding code if the submitter has not included them in their pull request.

## Guidelines

### Network & Data Layer

- **HTTP Client**: All HTTP traffic must use the singleton Client4. Only bypass it for streaming or blob handling, and document the reason inline.
- **New Endpoints**: Expose new Client4 methods via mattermost-redux/client/index.ts.
- **Thunk Responses**: Async thunks must always return a {data} or {error} object.
- **Error Handling**: Destructive errors in thunks must trigger forceLogoutIfNecessary.
- **Data Fetching**: Prefer dispatching Redux actions to fetch and cache data; component-side fetches should be read-only.
- **Batching**: Batch Redux actions whenever possible (e.g., using DelayedDataLoader) to reduce network requests.
- **WebSockets**: Consume the exported singleton from client/web_websocket_client.tsx; do not instantiate new connections.
- **WebSocket Listeners**: Use action creators (reconnect, handleFirstConnect) for connection logic and always clean up listeners using the provided remove helpers.

### Application Structure & Organization

- **Component Wiring**: Keep Redux wiring (connect, hooks) in index.ts files, separate from presentation logic in sibling components.
- **Component Factoring**: When refactoring large existing components, break them into smaller, more focused components.
- **Import Aliases**: Always import types using the @mattermost/types alias.
- **Import Grouping**: Group type-only imports together.
- **Code Splitting**: Use the makeAsyncComponent wrapper for new heavy routes and components.
- **Suspense Fallbacks**: Keep Suspense fallbacks null unless there is a strong UX reason otherwise.

### Routing & Navigation

- **New Routes**: Introduce new top-level routes in the Root component to ensure plugins are initialized.
- **Route Wrappers**: Wrap admin or onboarding flows with the appropriate HFRoute variant.
- **Protected Routes**: Use LoggedInRoute or LoggedInHFTRoute to guard routes.

### Error Handling & Boundaries

- **Component Errors**: Wrap new dynamic plugin entry points with the withErrorBoundary HOC to isolate crashes.
- **Fallback UI**: Provide an actionable fallback (e.g., a reload button) via the renderFallback option.
- **Logging**: Use the logError action to centralize error logging.
- **Log Noise**: Avoid logging known, common network failures (like "Failed to fetch").
- **Log UI**: Use LogErrorBarMode options to control if an error is shown to the user.

### Performance Optimization

- **Selectors**: Use makeGet... selector factories for per-instance memoization to avoid cross-component collisions.
- **Callbacks**: Wrap callbacks passed to child components in useCallback with precise dependencies.
- **Memoization Target**: Focus memoization on high-frequency lists; avoid it for cheap renders.

### State Management & React

- **Component Type**: Prefer functional components with hooks for all new code. Avoid adding new class-based components.
- **Redux Hooks**: Prefer useSelector/useDispatch hooks over mapStateToProps for new components.
- **Redux Types**: Import Redux types (like ActionFuncAsync) from webapp/channels/src/types/store/index.ts, not directly from redux-thunk.
- **Global State**: Extend the GlobalState intersection in types/store when adding new store slices.
- **any**: Avoid using any in thunks.
- **Data Hooks**: Use the makeUseEntity factory to create new hooks for lazy-fetching entity data.
- **Data Hook Naming**: Name hooks generated by the factory use<Entity> (e.g., useUser).
- **Data Hook Logic**: Ensure the selector passed to makeUseEntity returns undefined when data is absent to trigger the fetch.

### Side Effects & Lifecycle

- **Rules of Hooks**: Always follow the Rules of Hooks (as enforced by ESLint).
- **Data Fetching**: Use thunks for data shared across views; reserve fetch inside component effects for local-state-only data.
- **Thunk Responses**: Always destructure thunk responses into {data, error} variables.

### Event Handling & Accessibility

- **Keyboard Shortcuts**: Use `isKeyPressed(event, Constants.KeyCodes.KEY_NAME)` instead of raw key codes to support different keyboard layouts.
- **Platform Keys**: Use `cmdOrCtrlPressed(event)` for cross-platform Cmd/Ctrl detection.
- **Input Protection**: Check if `event.target` is an input/textarea/select before handling shortcuts.
- **Semantic HTML**: Always use `<button type="button">` for clickable actions, never divs with onClick.
- **ARIA Labels**: Provide `aria-label` on icon-only buttons and add `aria-hidden="true"` to decorative icons.
- **Focus Management**: Use `focusElement(elementOrId)` from `utils/a11y_utils` for programmatic focus. Store origin with `a11yController.storeOriginElement()` before opening modals and restore with `a11yController.restoreOriginFocus()` on close.
- **Modals**: Use `role="dialog"`, `aria-modal="true"`, implement focus trap, and add `a11y__modal` class to disable global navigation.

### A11y Controller (Keyboard Navigation)

- **Purpose**: Enables hierarchical keyboard navigation (F6/Ctrl+~ between regions, arrows within sections).
- **Regions**: Add `a11y__region` class and `data-a11y-sort-order` attribute to major UI areas for F6 navigation.
- **Sections**: Add `a11y__section` class to navigable list items for arrow key navigation when region is active.
- **Modal/Popup Disable**: Add `a11y__modal` or `a11y__popup` class to temporarily disable global navigation.
- **Additional Attributes**: Use `data-a11y-focus-child`, `data-a11y-loop-navigation`, or `data-a11y-order-reversed` as needed.

### Security Patterns

- **Auth**: Do not manually add Authorization headers; call Client4.setToken during login.
- **File Uploads**: Pass FormData objects directly to Client4 so the browser sets the correct Content-Type boundary.

### Component Libraries & Packages

- **Search First**: Before creating a new UI component, search for an existing one (e.g., GenericModal, Input) that can accomplish the task.
- **React Bootstrap**: Avoid using React Bootstrap. Use GenericModal from @mattermost/components instead of React Bootstrap's Modal.
- **MUI**: If using MUI is necessary, wrap the components in an interface to hide implementation details (as done in components/menu).
- **Popovers**: Use WithTooltip for simple tooltips. Prefer Floating UI for other popover/menu uses.
- **Deprecated Packages**: @mattermost/compass-components is deprecated.
- **Icons**: Prefer using icons from @mattermost/compass-icons/components.

### Styling & Theming (SCSS)

- **File Type & Tooling**: Use SCSS (.scss) for all component styles. Do not use plain CSS. Use @use 'utils/mixins' for shared variables and mixins, not the deprecated @import.
- **Co-location & Import**: Create a .scss file alongside its component (e.g., header_footer_route.scss next to header_footer_route.tsx).
- **Import**: Import the component's .scss file directly into the component's .tsx file (e.g., `import './header_footer_route.scss';`).
- **Scope & Naming**:
  - **Root**: Scope all styles under a unique root class named after the component (e.g., .header-footer-route).
  - **BEM**: Use BEM-inspired naming in kebab-case. For root classes use PascalCase for blocks to match with the component name.
  - **Elements**: Use the &__element suffix (e.g., .system-policy-indicator__title).
  - **Modifiers**: Use modifier classes for variants (e.g., &.compact).
- **Theme Tokens (CSS Variables)**:
  - **Colors**: Always use CSS custom properties for colors (e.g., `color: var(--link-color);`). Do not hard-code hex values.
  - **Transparency**: For transparent colors, use the RGB-tuple variable (e.g., `background: rgba(var(--sidebar-header-text-color-rgb), 0.08);)`.
- **Layout**: Prefer display: flex for layouts; use `display: grid` for more complex grids
- **Win specificity by:**
  - Scoping under the component root class
  - Using variant classes (e.g., .Component--compact)
  - If you must override third-party/legacy, create a narrowly scoped wrapper class instead of !important.

### Internationalization (I18n)

- **Component vs. Hook**: Prefer the <FormattedMessage> component over the useIntl().formatMessage hook, unless you specifically need a string for a prop.
- **Redux**: Actions or Redux state should store MessageDescriptor objects, with formatting deferred to the React component.
- **Prohibited APIs**: Do not use localizeMessage or FormattedMarkdownMessage.
- **Concatenation**: Use React Intl's Rich Text Formatting feature instead of concatenating translated strings.

### Plugin Development

- **APIs**: When exposing components or APIs for plugins, be extra sure it's necessary and limit the number of props to reduce the risk of breakage.
- **Libraries**: Do not add new libraries for plugins to consume.

### Testing

- **Library**: Use React Testing Library (RTL) instead of Enzyme for all component unit tests.
- **Helpers**: Import testing functions from utils/react_testing_utils and use renderWithContext for components that need Redux, I18n, or Router context.
- **Method**: Test the functionality and behavior of the component. Do not use snapshot tests.
- **Selectors**: Prefer accessible selectors in this order: `getByRole` > `getByLabelText` > `getByPlaceholderText` > `getByText` > `getByTestId` (last resort).
- **Keyboard Testing**: Use `userEvent.keyboard('{Enter}')` and `userEvent.tab()` to test keyboard interactions.
- **ARIA Verification**: Assert ARIA attributes are correct (e.g., `expect(el).toHaveAttribute('aria-expanded', 'true')`).

## Asset Management & Constants

- **Asset Location**: Store new images under webapp/channels/src/images.
- **New Constants**: Add new preference keys, modal IDs, and enumerations to utils/constants.tsx.
- **Feature Flags**: Gate features using selectors that check both the config and the feature flag.

---

## Standards Still Needing Refinement or Definition

These items are gaps identified in the code analysis. They are areas for active refactoring and cleanup.

- **Styling: !important**: Needs to be eliminated. Over 300 instances remain, primarily in legacy modal overrides.
- **Styling: Hard-Coded Values**: Hard-coded border-radius, box-shadow, and other non-color literals (e.g., 4px) should be replaced with theme variables (e.g., var(--radius-s), var(--elevation-1)).
- **Styling: Responsive Mixins**: Hard-coded @media queries are common and should be migrated to use the shared breakpoint mixins.
- **Styling: Legacy Selectors**: Older SCSS files with element selectors (li, button) or non-BEM class names (PascalCase, camelCase) should be refactored to use modern, scoped BEM patterns when touched.
- **Styling: Units**: We need to settle on a convention of either px, em or rem. **px** is used the most.
- **Navigation Utilities**: Mixed usage of getHistory() from browser_history vs. the useHistory() hook from React Router.
- **Validation & Submission Handling**: Needs Review; validation remains ad-hoc with no shared framework.
- **Virtualized Lists**: Mixed usage; only implemented in a few key areas, with legacy lists still using manual scrolling.
- **useEffect Composition**: Mixed usage; some legacy modules still use single "mega-effects" with internal branching instead of separate effects for separate concerns.
- **Component Prop Typing**: Mixed usage; some legacy files still use any or are untyped.
- **Sanitization & Safe Rendering**: Mixed Usage; potential gaps in unsanitized string interpolation in older components.
- **Local Contexts**: Mixed usage; prop drilling persists in many areas, with contexts only used for a few component families like menus.
- **Handler Placement**: Needs Review; inconsistent naming and placement of event handlers.
- **Direct Downloads & Blob Handling**: Mixed usage of in-component fetch/blob handling vs. legacy server-triggered redirects.
